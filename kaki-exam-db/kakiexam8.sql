/*
SQLyog Ultimate v12.14 (64 bit)
MySQL - 8.0.16 : Database - kaki_exam
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`kaki_exam` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `kaki_exam`;

/*Table structure for table `t_exam_article` */

DROP TABLE IF EXISTS `t_exam_article`;

CREATE TABLE `t_exam_article` (
  `id` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT 'ID',
  `columnid` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '专栏ID',
  `userid` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '用户ID',
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标题',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_croatian_ci COMMENT '文章正文',
  `image` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '文章封面',
  `createtime` datetime DEFAULT NULL COMMENT '发表日期',
  `updatetime` datetime DEFAULT NULL COMMENT '修改日期',
  `ispublic` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '是否公开',
  `istop` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '是否置顶',
  `visits` int(20) DEFAULT NULL COMMENT '浏览量',
  `thumbup` int(20) DEFAULT NULL COMMENT '点赞数',
  `comment` int(20) DEFAULT NULL COMMENT '评论数',
  `state` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '审核状态',
  `channelid` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '所属频道',
  `url` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT 'URL',
  `type` varchar(50) COLLATE utf8mb4_croatian_ci DEFAULT NULL COMMENT '文章类型',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_croatian_ci COMMENT='文章';

/*Data for the table `t_exam_article` */

insert  into `t_exam_article`(`id`,`columnid`,`userid`,`title`,`content`,`image`,`createtime`,`updatetime`,`ispublic`,`istop`,`visits`,`thumbup`,`comment`,`state`,`channelid`,`url`,`type`) values 
('1223530234607943680',NULL,NULL,'orm,技术','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h2_1\"></span> \n <h2><strong>OA系统</strong></h2> \n <p>办公自动化（Office Automation）是将现代化办公和计算机网络功能结合起来的一种新型的办公方式</p> \n <span id=\"OSC_h2_2\"></span> \n <h2><strong>CRM系统</strong></h2> \n <p>客户关系管理系统（Customer Relationship Management）是以客户数据的管理为核心，利用信息科学技术，实现市场营销、销售、服务等活动自动化，并建立一个客户信息的收集、管理、分析、利用的系统，帮助企业实现以客户为中心的管理模式。客户关系管理既是一种管理理念，又是一种软件技术。</p> \n <p>客户关系管理系统主要有高可控性的数据库、更高的安全性、数据实时更新等特点，提供日程管理、订单管理、发票管理、知识库管理等功能。</p> \n <span id=\"OSC_h2_3\"></span> \n <h2><strong>ERP系统</strong></h2> \n <p>ERP系统是企业资源计划(Enterprise Resource Planning )的简称，是指建立在信息技术基础上，集信息技术与先进管理思想于一身，以系统化的管理思想，为企业员工及决策层提供决策手段的管理平台。它是从MRP（物料需求计划）发展而来的新一代集成化管理信息系统，它扩展了MRP的功能，其核心思想是供应链管理。它跳出了传统企业边界，从供应链范围去优化企业的资源，优化了现代企业的运行模式，反映了市场对企业合理调配资源的要求。它对于改善企业业务流程、提高企业核心竞争力具有显著作用。</p> \n <span id=\"OSC_h2_4\"></span> \n <h2><strong>BPM系统</strong></h2> \n <p>BPM软件中BPM是英文字母缩写，大致有二个意思。</p> \n <p>第一、Business Process Management，即业务流程管理，是一套达成企业各种业务环节整合的全面管理模式。</p> \n <p>第二、Business Process Modeling，即业务流程建模，是对业务流程进行表述的方式，它是过程分析与重组的重要基础。</p> \n <span id=\"OSC_h2_5\"></span> \n <h2><strong>其之间的关系</strong></h2> \n <p>我们假设你是某机械行业的销售，一切从今天你收到公司的邮件，去上海参加展会开始</p> \n <p>首先，你打开OA登陆，填写出差申请表，送交主管审批<br> 填表--审批--行政订票酒店</p> \n <p>然后呢，你飞去上海参加展会收了一堆名片，你回公司开crm，登陆，把名片输入leads 然后一个一个电话打过去，把一个leads变成了客户，谈价格、成交、修改crm、创建订单</p> \n <p>erp那边收到crm来的订单，先看具体型号，根据型号确定材料 （erp 中的bom），排生产计划 （sap 中pp），同时财务部门处理合同 （credit control），负责收款（SD），排产 入库出库 （MM WM），送到客户手中。</p> \n <p>&nbsp;</p> \n <p>这时请注意 几点</p> \n <ol> \n  <li>你去参展的机票 也就是OA的最后一步 如果好的oa系统会和hr系统串联，那么无需修改hr的请假出差系统，在你选定了日期后即可串联起来</li> \n  <li>你在crm 创建了订单，应该通过接口直接导入sap，这也就是为什么erp中我没有写创建订单的原因</li> \n  <li>反过来如果你的产品型号在erp中修改了那么导致的价格变更等，sap需要反推回crm</li> \n  <li>这几个系统一个是做办公流程，一个是做销售流程，一个是做生产流程</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n\n </ol> \n</div>',NULL,'2020-02-01 16:55:08',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926434988032',NULL,NULL,' SessionManager支持token认证  ','<div class=\"content\" id=\"articleContent\"> \n <h3>1.定义一个SessionManager类</h3> \n <p>创建一个类，继承<code>AuthorizingRealm</code>&nbsp;，然后在<code>doGetAuthenticationInfo</code>中重写认证的方法</p> \n <pre><code class=\"language-java\">/**\n * 重写 SessionId 获取方式\n * @param request 请求\n * @param response 响应\n * @return id\n */\n@Override\nprotected Serializable getSessionId(ServletRequest request, ServletResponse response) {\n    String id = WebUtils.toHttp( request ).getHeader( AUTHORIZATION );\n    //如果请求头中有 Authorization 则其值为sessionId\n    if (!StringUtils.isEmpty( id )) {\n        request.setAttribute( REFERENCED_SESSION_ID_SOURCE, REFERENCED_SESSION_ID_SOURCE );\n        request.setAttribute( ShiroHttpServletRequest.REFERENCED_SESSION_ID, id );\n        request.setAttribute( ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE );\n        return id;\n    } else {\n        //否则按默认规则从cookie取sessionId\n        return super.getSessionId( request, response );\n    }\n}\n</code></pre> \n</div>',NULL,'2020-02-01 16:55:27',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926439182336',NULL,NULL,' 内功心法  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h3_1\"></span> \n <h3><span style=\"font-size: 18px;\">九九乘法表</span></h3> \n <p>1、执行第一个for，不执行i++。</p> \n <p>2、执行第二个for。（第二个for执行的次数是变量i决定）<br></p> \n <p>3、第二个for执行完毕。</p> \n <p>4、返回第一个for。</p> \n <p>5、第一个for变量i++。</p> \n <p>6、第一个for判断条件，满足继续执行2-5步，不满足直接退出。</p> \n <pre class=\"brush:php;toolbar: true; auto-links: false;\"><code>for($i=1;$i&lt;10;$i++){\n&nbsp;&nbsp;&nbsp;&nbsp;for($j=1;$j&lt;=$i;$j++){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;\"{$j}X{$i}=\".$i*$j;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;\"&amp;nbsp;\";\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;\"&lt;br/&gt;\";\n}</code></pre> \n <p></p> \n <p><span style=\"font-size: 14px; background-color: rgb(216, 216, 216);\">程序效果图</span><span style=\"font-size: 18px;\"><br></span><img src=\"http://static.oschina.net/uploads/space/2015/0118/102949_l2Cj_1765961.png\"></p> \n <p><br></p> \n <span id=\"OSC_h3_2\"></span> \n <h3><span style=\"font-size: 18px;\">递归函数</span><br></h3> \n <p><span style=\"font-size: 14px;\">1、执行test(2)，echo 2，if(2&gt;0)，执行test(2-1)。</span><span style=\"font-size: 14px; background-color: rgb(216, 216, 216);\">后面的代码暂时不执行</span></p> \n <p><span style=\"background-color: rgb(255, 255, 255);\">2、echo \"-----\";</span><br></p> \n <p><span style=\"background-color: rgb(255, 255, 255);\">3、执行第三部分echo 0，echo 1， echo 2</span></p> \n <pre class=\"brush:php;toolbar: true; auto-links: false;\"><code>function&nbsp;test($_string\n&nbsp;&nbsp;&nbsp;&nbsp;//第一部分代码\n&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$_string;\n&nbsp;&nbsp;&nbsp;&nbsp;if($_string&gt;0){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;test($_string-1);\n&nbsp;&nbsp;&nbsp;&nbsp;//第二部分执行代码\n&nbsp;&nbsp;&nbsp;&nbsp;}else{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;\"-----\";\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;//第三部分执行echo&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$_string;\n}\ntest(2);</code></pre> \n <p></p> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \r\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li>   <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li>   <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li>   <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li>   <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n\n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n  <li>我想你注意到了，我很注重几个系统的串联，通过bpm可以很容易做到这一点</li> \n <p><span style=\"font-size: 18px;\"><span style=\"font-size: 14px;\"></span></span><br></p> \n</div>',NULL,'2020-02-01 16:55:34',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926443376640',NULL,NULL,' python安装MySQLdb的问题 ImportError: DLL load failed  ','<div class=\"content\" id=\"articleContent\"> \n <p> 在windows下面默认安装的python2.6再安装MySQLdb会遇到很多神奇的问题，如缺少库，编译错误等 </p> \n <p> 例如python2.5出现 </p> \n <p> import MySQLdb<br> Traceback (most recent call last):<br> &nbsp; File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;<br> &nbsp; File \"C:\\Python25\\Lib\\site-packages\\MySQLdb\\__init__.py\", line 19, in &lt;module&gt;<br> &nbsp;&nbsp;&nbsp; import _mysql<br> ImportError: DLL load failed: 找不到指定的程序。 </p> \n <p> 解决方案： </p> \n <p> 把mysql安装目录的bin\\libmySQL.dll文件复制到python安装目录的Lib\\site-packages下 </p> \n <p> python2.6出现 </p> \n <p> Python 2.6 (r26:66721, Oct&nbsp; 2 2008, 11:35:03) [MSC v.1500 32 bit (Intel)] on win32<br> Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.<br> &gt;&gt;&gt; import MySQLdb<br> Traceback (most recent call last):<br> &nbsp; File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;<br> &nbsp; File \"C:\\Python26\\Lib\\site-packages\\MySQLdb\\__init__.py\", line 19, in &lt;module&gt; &nbsp;&nbsp;&nbsp; import _mysql<br> ImportError: DLL load failed: 找不到指定的模块。 </p> \n <p> 下载libmmd.dll和libguide40.dll两个dll文件并复制到python安装目录的Lib\\site- packages下 </p> \n <p> 两个dll文件Google一下即可找到 </p> \n <p> 还有一个 </p> \n <p> Python 2.6 (r26:66721, Oct&nbsp; 2 2008, 11:35:03) [MSC v.1500 32 bit (Intel)] on win32<br> Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.<br> &gt;&gt;&gt; import MySQLdb<br> D:\\usr\\local\\Python26\\lib\\site-packages\\MySQLdb\\__init__.py:34: DeprecationWarning: the sets module is deprecated<br> &nbsp; from sets import ImmutableSet </p> \n <p> 解决方案： </p> \n <p> 1) 在文件 \"__init__\" 中将:<br> <br> from sets import ImmutableSet&nbsp;<br> class DBAPISet(ImmutableSet):&nbsp;<br> <br> 替换为<br> <br> class DBAPISet(frozenset)<br> <br> 2) 在文件 \"converters.py\"中移除:<br> <br> from sets import BaseSet, Set<br> <br> 3) 在文件 \"converters.py\", 把 \"Set\" 改为 \"set\" (重要提示: 只有2个地方要改):<br> <br> line 48: return set([ i for i in s.split(\',\') if i ])<br> line 128: set: Set2Str, </p> \n <p> 参见： </p> \n <p> <a href=\"http://sourceforge.net/projects/mysql-python/forums/forum/70460/topic/2316047?message=5808948\" target=\"_blank\" rel=\"nofollow\">http://sourceforge.net/projects/mysql-python/forums/forum/70460/topic/2316047?message=5808948<br> </a> </p> \n <p> 最后再介绍一个无敌方法： </p> \n <span id=\"OSC_h1_1\"></span> \n <h1> <strong><span style=\"background-color:#FFFFFF;\">国外有个大牛直接帮我们编译好了不会出问题的MySQLdb, 去下面的网址下载安装就能解决了<br> </span></strong><a href=\"http://www.codegood.com/archives/4\" target=\"_blank\" rel=\"nofollow\"><strong><span style=\"background-color:#FFFFFF;\">http://www.codegood.com/archives/4</span></strong></a> </h1> \n</div>',NULL,'2020-02-01 16:56:01',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926451765248',NULL,NULL,' import _mysql--ImportError: DLL load failed: %1  ','<div class=\"content\" id=\"articleContent\"> \n <p>错误：import &nbsp;_mysql--ImportError: DLL load failed: %1 不是有效的 Win32 应用程序。</p> \n <p>一定是版本的问题！！</p> \n <p>就是系统，以及安装的python，以及第三方module的位数要一致！系统是64位，其他就一定也要是64位。</p> \n <p><strong>我的python安装的没问题，module也没问题，因为之前MySQLdb模块都正常的用着，昨天却出现了问题（如题的错误）</strong>，花了一个晚上没找到问题所在，百思不得其解的情况下卸载了python，结果今天早晨发现卸载的python是无辜的啊~</p> \n <p>前几天查看chromium源码时安装了chromium的部署工具depot_tools，后来就忘记了这回事！<strong>问题就在这里</strong>，depot_tools里自带的有python啊啊啊，只不过自带的是32位的python（而我电脑是64位的），而且当时配置depot_tools时，将depot_tools路径放在了PATH最前面，所以使用的python是depot自带的2.7.6，我自己安装的2.7.15就这么被覆盖了。。。</p> \n <p>无奈只能重新安装了！</p> \n</div>',NULL,'2020-02-01 16:55:47',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926451765249',NULL,NULL,' Bootstrap 3 排版  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h3_1\"></span> \n <h3>导航栏</h3> \n <p><span style=\"font-size: 14px;\">导航栏默认有圆角边框，设置导航.navbar-fixed-top可以去掉边框。</span></p> \n <p><span style=\"font-size: 14px;\">图一无圆角（放大看）</span></p> \n <p><img src=\"http://static.oschina.net/uploads/space/2015/0116/142155_jPi6_1765961.png\"></p> \n <p><span style=\"font-size: 14px;\">图二有圆角（放大看）</span></p> \n <p><img src=\"http://static.oschina.net/uploads/space/2015/0116/142155_xanh_1765961.png\"></p> \n <p><img src=\"http://static.oschina.net/uploads/img/201501/16142749_gcNy.png\"><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(216, 216, 216);\">为了防止导航栏与页面主体中的其他内容的顶部相交错，请向 &lt;body&gt; <span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 12px; background-color: rgb(216, 216, 216);\">标签添加至少 50 像素的内边距</span>（padding），内边距的值可以根据您的需要进行设置。</span></p> \n <p><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 12px; background-color: rgb(255, 255, 255);\"><br></span></p> \n <span id=\"OSC_h3_2\"></span> \n <h3><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 18px; background-color: rgb(255, 255, 255);\">左侧手风琴</span></h3> \n <p><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\">手风琴效果使用data-toggle=\"collapse\"(这是一个bootstrap插件)。</span></p> \n <p><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\">a标签的href值对应隐藏标签的ID值。</span></p> \n <pre class=\"brush:html;toolbar: true; auto-links: false;\"><code>&lt;ul&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&nbsp;class=\"top-li\"&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href=\"#learn-more-content\"&nbsp;data-toggle=\"collapse\"&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;i&nbsp;class=\"glyphicon&nbsp;glyphicon-flash\"&nbsp;style=\"color:#fff\"&gt;&lt;/i&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;span&gt;显示下拉菜单&lt;/span&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/a&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--------in=首次加载页面时显示------out=首次加载页面时隐藏---------------------&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&nbsp;id=\"learn-more-content\"&nbsp;class=\"collapse&nbsp;in\"&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;账号管理&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;1-2&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;1-3&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;1-4&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;1-5&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;1-6&lt;/li&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;\n&lt;/ul&gt;</code></pre> \n <p></p> \n <p><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\"></span><br></p> \n <p><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(255, 255, 255);\"><img src=\"http://static.oschina.net/uploads/img/201501/16142749_gcNy.png\"><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; background-color: rgb(216, 216, 216);\">手风琴效果中的元素不能设置固定高度，只能用padding撑出高度。</span></span></p> \n <p><span style=\"font-size: 14px; background-color: rgb(255, 255, 255);\"><img src=\"http://static.oschina.net/uploads/space/2015/0117/102542_sAky_1765961.png\" width=\"195\" height=\"300\" title=\"\"></span><span style=\"font-size: 12px; background-color: rgb(255, 255, 255);\"><img src=\"http://static.oschina.net/uploads/space/2015/0117/102337_LlII_1765961.png\" width=\"195\" height=\"300\" title=\"\">l</span></p> \n <p><span style=\"font-size: 12px; background-color: rgb(255, 255, 255);\"><br></span></p> \n <span id=\"OSC_h3_3\"></span> \n <h3><span style=\"font-size: 18px; background-color: rgb(255, 255, 255);\">路径效果</span></h3> \n <p><span style=\"font-size: 14px; background-color: rgb(255, 255, 255);\">路径效果时采用官方效果<br></span></p> \n <pre class=\"brush:html;toolbar: true; auto-links: false;\"><code>&lt;ol&nbsp;class=\"breadcrumb\"&gt;\n&nbsp;&nbsp;&lt;li&gt;&lt;a&nbsp;href=\"#\"&gt;后台管理系统&lt;/a&gt;&lt;/li&gt;\n&nbsp;&nbsp;&lt;li&gt;&lt;a&nbsp;href=\"#\"&gt;用户管理&lt;/a&gt;&lt;/li&gt;\n&nbsp;&nbsp;&lt;li&nbsp;class=\"active\"&gt;Data&lt;/li&gt;\n&nbsp;&nbsp;&lt;/ol&gt;</code></pre> \n <p></p> \n <p><span style=\"font-size: 14px; background-color: rgb(255, 255, 255);\"></span><img src=\"http://static.oschina.net/uploads/space/2015/0117/133650_Igd6_1765961.png\"></p> \n <h3><br></h3> \n <span id=\"OSC_h3_4\"></span> \n <h3>浮动</h3> \n <p><span style=\"font-size: 14px;\">通过添加&nbsp;.navbar-left&nbsp;和&nbsp;.navbar-right&nbsp;工具类让导航链接、表单、按钮或文本对齐。两个类都会通过 CSS 设置特定方向的浮动样式。</span></p> \n <p><span style=\"font-size: 14px;\">清除浮动 .clearfix</span></p> \n <p><span style=\"font-size: 14px;\"><img src=\"http://static.oschina.net/uploads/img/201501/16142749_gcNy.png\"><span style=\"font-size: 14px; background-color: rgb(216, 216, 216);\">pull-left、pull-right也可以让&lt;nav&gt;标签中的&lt;ul&gt;实现浮动</span><span style=\"font-family: \'Microsoft Yahei\', \'Helvetica Neue\', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 22.5px; background-color: rgb(216, 216, 216);\">。</span></span></p> \n</div>',NULL,'2020-02-01 16:55:40',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926455959552',NULL,NULL,' OS X系统 手势终极设置方法+BetterTouchTool详细设置中文翻译  ','<div class=\"content\" id=\"articleContent\"> \n <div>\n   相信用过罗技G系鼠标的同学都对罗技鼠标强大的自定义功能留下过深刻的印象。对于那些表示只愿追求简单拒绝功能复杂而去使用三键鼠标的同学，我很怀疑他们是否真正了解到多键鼠标或手势功能对电脑操作便捷上带来的重大意义。复制粘贴，前进后退，关闭等等这些操作看似简单，但有的需要键盘配合，有的需要右手精确操作(随着屏幕越来越大，鼠标为点击关闭等按钮而滑行的距离越来越长)，如果这些操作都能由右手在盲操作的情况下完成，那将给电脑的使用体验带来巨大的变化。 \n </div> \n <br> \n <div>\n   在pc上一直使用逻辑G300，完美的官方驱动软件给小小的G300注入了强大的自定义功能，唯一的遗憾是滚轮不带左右拨和有线。而换在imac上，由于苹果键盘鼠标触控板都是无线(吐槽一下键盘，虽然盖上膜以后手感差到极点，但其轻巧的体积和蓝牙连接还是给桌面的整洁起到很重要的作用)，所以加的这个有线鼠标马上会变成眼中钉。随后入了一只罗技M705，被其3年的待机时间所迷惑，脑残的光头设计使用起来简直让人头晕。然后考虑罗技G700，了解到G700已停产，而G700s丑陋的涂漆及缩水的自定义键(据说升级后的G700s功能键全由之前的微动换成了贴片)实在让人失望，而且待机时间跟手机差不多，并且价格高昂，对于不玩儿游戏的我来说，实在找不出理由狠这个心。 \n </div> \n <br> \n <div>\n   寻觅了很久适合imac的多功能无线鼠标，一无所获。不经意间看到介绍BetterTouchTool的文章，如获至宝。第一次使用os x 的时候，就非常喜欢触控板的一些手势操作，以至于好多人已完全放弃鼠标。但一直觉得，os x对触控板的设置并没有完全发挥出它的潜力，右手能干的事情还可以更多。 \n </div> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">BetterTouchTool(简称BTT)就是这样一款软件，把触控板的潜力发挥到淋漓尽致。平时使用方面(非游戏)，功能上秒杀G700s，即便是20多个功能键的G600也望尘莫及。(鼠标上密密麻麻的按钮太挑战记忆力了)。chiphell好像不能加附件，软件请自行搜索下载，最新版本：0.981</span> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210513_420B.png\" width=\"534\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">下面先贴一下我的简单设置(系统级别的)</span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210513_A3fd.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">1.返回 双指左滑(finder、浏览器)</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">2.前进 双指右滑(finder、浏览器)</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">3.音量减少 两指同时触摸板面，以中指为支点不动，食指不停轻拍板面</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">4.音量增加 两指同时触摸板面，以食指为支点不动，中指不停轻拍板面</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">5.屏幕变亮 食中无三指同时触摸板面，以食指中指为支点不动，无名指不停轻拍板面</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">6.屏幕变暗 食中无三指同时触摸板面，以无名指中指为支点不动，食指不停轻拍板面</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">7.关闭(网页标签，程序，finder等) 三指，轻拍板面两次</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">8.复制 选中目标，三指上滑(记忆方法：好像把数据推上了剪贴板)</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">9.粘贴 订好位置，三指下滑(记忆方法：好像吧数据从剪贴板上拽下来)</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">10.撤销 三指向左滑(记忆方法：做错了，扇了一巴掌，一般右撇子都往左扇)</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">11.反撤销&nbsp;&nbsp;三指向右滑(记忆方法：又做错了，从左面再扇回来)</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">12.重启BTT。三指同时点击触控板。</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">以上只是简单的设置了常用的一些功能。还有大量功能没有设置。</span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">由于软件没有汉化版，下面大致讲一下软件的设置。</span> \n <br> \n <br> \n <span style=\"background-color:#FFFFFF;\"><span>一、系统偏好的设置</span></span> \n <br> \n <br> \n <span style=\"background-color:#FFFFFF;\"><span><br> </span></span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">由于BTT里大量的手势设置难免会和系统默认手势发生冲突，所以要先把系统偏好里面的设置处理好。</span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210513_RMAZ.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210514_Z32K.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">“轻拍点按”&nbsp;&nbsp;非常重要，要勾选，轻拍选中窗口，马上再次拍住，这是窗口就粘在你手指上了，可以随便拖动。这样可以不用 “三指拖移”，减少以后的三指误操作，“查找”功能也不选，这个需要三指轻按，容易给后面的设置带来误操作，而且查找内容仅限于苹果软件内。例如chrom就不能用。</span> \n <br> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210514_jlxP.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">滚动方向 勾不勾因人而异，不勾的时候跟window下是一样的。</span> \n <br> \n <br> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210515_IgmD.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">在屏幕之间推送&nbsp; &nbsp;这个不要选。这个切换其实就是 前进和后退。os x 对这个切换处理的很不理想，有的地方要用两个手指滑动，有的地方要用三个手指滑动，所以直接取消，交个btt来设置。BTT可以设置系统级别的 前进和后退，大部分软件和finder都适用。区别是，safari失去了翻页效果，也无所谓了。</span> \n <br> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">如果不常用到通知功能，通知中心也不要选。双指边缘滑动也用容易给后面的操作带来误操作。</span> \n <br> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">系统偏好设置到此为止。</span> \n <br> \n <br> \n <br> \n <span style=\"background-color:#FFFFFF;\"><span>二、简单设置</span><br> </span> \n <br> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210516_EIy4.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210516_yqjL.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210517_0U6A.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">鼠标手势翻译(部分手势可以直接看小方框内的演示)：</span> \n <br> \n <div>\n   单手指 \n </div> \n <div>\n   corner click bottom left&nbsp;&nbsp;左下角单击 \n </div> \n <div>\n   corner click bottom right右下角单击 \n </div> \n <div>\n   single finger tap top left&nbsp;&nbsp;单指轻拍左上角 \n </div> \n <div>\n   single finger tap top middle 单指轻拍上边中点 \n </div> \n <div>\n   single finger tap top right&nbsp;&nbsp;单指轻拍右上角 \n </div> \n <div>\n   single finger bottom tap left 单指轻拍左下角 \n </div> \n <div>\n   single finger bottom tap middle 单指轻拍下边中点 \n </div> \n <div>\n   single finger bottom tap right 单指轻拍右下角 \n </div> \n <div>\n   single finger tap left side middle 单指轻拍左边中点 \n </div> \n <div>\n   single finger tap right side middle 单指轻拍右边中点 \n </div> \n <br> \n <div>\n   双手指 \n </div> \n <div>\n   tipap left&nbsp; &nbsp; 中指拍住中央食指轻拍面板&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; \n </div> \n <div>\n   tipap right&nbsp;&nbsp;食指拍住中央中指轻拍面板&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; \n </div> \n <div>\n   pinchi in&nbsp; &nbsp;&nbsp; &nbsp;两个手指捏 \n </div> \n <div>\n   pinch out&nbsp; &nbsp; 两个手指放开 \n </div> \n <div>\n   rotate left&nbsp; &nbsp; 张开两指以两指中心为圆轴逆时针 \n </div> \n <div>\n   rotate righ&nbsp; &nbsp;张开两指以两指中心为圆轴顺时针 \n </div> \n <div>\n   scroll up(modifier key needed)双指按滚动方向滑动(需设定下面的功能键) \n </div> \n <div>\n   scroll down(modifier key needed)双指按滚动方向相反滑动(需设定下面的功能键) \n </div> \n <div>\n   tow finger swipe up 双指上划 \n </div> \n <div>\n   tow finger swipe down 双指下滑 \n </div> \n <div>\n   tow finger swipe left 双指左滑 \n </div> \n <div>\n   tow finger swipe right 双指右滑 \n </div> \n <div>\n   tow finger swipe from top edge 双指从上边缘下滑 \n </div> \n <div>\n   tow finger swipe from bottom edge 双指从下边缘上滑 \n </div> \n <div>\n   tow finger swipe from left edge 双指从左边缘右滑 \n </div> \n <div>\n   tow finger swipe from right edge 双指从右边缘左滑 \n </div> \n <br> \n <div>\n   三手指 \n </div> \n <div>\n   three finger tap 三指轻拍 \n </div> \n <div>\n   three finger double tap 三指双轻拍 \n </div> \n <div>\n   three finger tap top 三指拍顶端 \n </div> \n <div>\n   three finger tap bottom 三指拍底部 \n </div> \n <div>\n   three finger click 三指点击 \n </div> \n <div>\n   three finger swipe up 三指上划 \n </div> \n <div>\n   three finger swipe down 三指下划 \n </div> \n <div>\n   three finger swipe left&nbsp; &nbsp; 三指左划 \n </div> \n <div>\n   three finger swipe right&nbsp;&nbsp;三指右划 \n </div> \n <div>\n   three finger clickswipe up&nbsp; &nbsp;&nbsp; &nbsp; 三指点击并向上滑 \n </div> \n <div>\n   three finger clickswipe down 三指点击并向下滑 \n </div> \n <div>\n   three finger clickswipe left&nbsp; &nbsp;三指点击并向左滑 \n </div> \n <div>\n   three finger clickswipe right 三指点击并向右滑 \n </div> \n <div>\n   tow finger tip tap left&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;两指轻拍住，拍左 \n </div> \n <div>\n   tow finger tip tap middle 两指轻拍住，第三拍中 \n </div> \n <div>\n   tow finger tip tap right&nbsp; &nbsp;&nbsp; &nbsp;两指轻拍住，第三拍右 \n </div> \n <div>\n   tipswipe left finger up&nbsp; &nbsp;&nbsp; &nbsp; 右二指固定拍住，左一上滑 \n </div> \n <div>\n   tipswipe left finger down 右二指固定拍住，左一下滑 \n </div> \n <div>\n   tipswipe left finger left&nbsp; &nbsp;&nbsp; &nbsp;右二指固定拍住，左一左滑 \n </div> \n <div>\n   tipswipe left finger righ&nbsp; &nbsp;&nbsp;&nbsp;右二指固定拍住，左一右滑 \n </div> \n <br> \n <div>\n   四手指 \n </div> \n <div>\n   four finger tap 四指轻拍 \n </div> \n <div>\n   four finger double tap 四指双轻拍 \n </div> \n <div>\n   four finger click 四指单击 \n </div> \n <div>\n   four finger swipe up 四指上滑 \n </div> \n <div>\n   four finger swipe down 四指下滑 \n </div> \n <div>\n   four finger swipe left 四指左滑 \n </div> \n <div>\n   four finger swipe right 四指右滑 \n </div> \n <div>\n   three finger tiptop left&nbsp; &nbsp;中指无名小拍住，食单击 \n </div> \n <div>\n   three finger tiptop right 食中指无名拍住，小单击 \n </div> \n <br> \n <div>\n   五手指 \n </div> \n <div>\n   five finger tap 五手指轻拍 \n </div> \n <div>\n   five finger click 五手指点击 \n </div> \n <div>\n   five finger swipe up 五手指上滑 \n </div> \n <div>\n   five finger swipe down 五手指下滑 \n </div> \n <div>\n   five finger swipe left 五手指左滑 \n </div> \n <div>\n   five finger swipe right 五手指右滑 \n </div> \n <div>\n   five finger touch/move 类似五手指轻拍 \n </div> \n <div>\n   11 finger tap /whole hand 这哥们儿是六指儿... \n </div> \n <br> \n <div>\n   自定义 好像是四个手指依照不同的次序拍在面板上，有点像弹吉他或弹钢琴的感觉。 \n </div> \n <br> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210518_Bl4n.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <br> \n <br> \n <br> \n <span style=\"background-color:#FFFFFF;\"><span>三、附加设置</span><br> </span> \n <br> \n <br> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\">BTT除了可以用手势代替普通快捷键，还可以实现打开软件控制音量等其他功能：</span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210518_xX4d.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210519_wZKL.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210519_Xv6L.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210520_igc0.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210521_wazb.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210521_JeUQ.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210522_5cYg.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <br> \n <span style=\"background-color:#FFFFFF;\"><span>四、高级功能</span><br> </span> \n <br> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210523_tGTO.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210523_piQy.png\" width=\"780\">&nbsp; \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <img src=\"http://static.oschina.net/uploads/img/201410/24210524_rHlN.jpg\" width=\"780\">&nbsp; \n <div> \n  <div> \n   <p> <span style=\"font-weight:700;\">屏幕快照 2013-10-13 下午5.00.25副本.jpg</span><span style=\"color:#666666;\">(97.89 KB, 下载次数: 0)</span> </p> \n   <p> <a href=\"http://www.chiphell.com/forum.php?mod=attachment&amp;aid=Mjg0MDAwNHxhZjVlMTQzNXwxNDE0MTU1NzQ1fDB8ODc2NjE5&amp;nothumb=yes\" target=\"_blank\" rel=\"nofollow\">下载附件</a> </p> \n   <p style=\"color:#999999 !important;\"> 2013-10-13 20:08 上传 </p> \n  </div> \n  <div> \n  </div> \n </div> \n <span style=\"color:#444444;font-family:微软雅黑, Tahoma, \'Microsoft Yahei\', Simsun;font-size:15px;line-height:22.5px;background-color:#FFFFFF;\"></span> \n <br> \n <br> \n <br> \n</div>',NULL,'2020-02-01 16:55:54',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531926460153856',NULL,NULL,' 如何优雅的选择字体(font-family)  ','<div class=\"content\" id=\"articleContent\"> \n <p>大家都知道，在不同操作系统、不同游览器里面默认显示的字体是不一样的，并且相同字体在不同操作系统里面渲染的效果也不尽相同，那么如何设置字体显示效果会比较好呢？下面我们逐步的分析一下：</p> \n <p>&nbsp;</p> \n <p>一、首先我们看看各平台的默认字体情况</p> \n <p>&nbsp;</p> \n <p>1、Window下：</p> \n <p>·宋体（SimSun）：Win下大部分游览器的默认字体，<code>宋体</code>在小字号下（如12px、14px）的显示效果还可以接受，但是字号一大就非常糟糕了，所以使用的时候要注意。</p> \n <p>·微软雅黑（\"Microsoft Yahei\"）：从 Vista 开始，微软提供了这款新的字体，一款无衬线的黑体类字体，并且拥有<em>Regular</em>、<em>Bold</em>&nbsp;两种粗细的字重，显著提高了字体的显示效果。现在这款字体已经成为Windows游览器中最值得使用的中文字体。从Win8开始，<code>微软雅黑</code>又加入了&nbsp;<em>Light</em>&nbsp;这款更细的字重，对于喜欢细字体的设计、开发人员又多了一个新的选择。</p> \n <p>·Arial：Win平台上默认的无衬线西文字体（为什么要说英文字体后面会解释），有多种变体，显示效果一般。</p> \n <p>·Tahoma：十分常见的无衬线字体，被采用为Windows 2000、Windows XP、Windows Server 2003及Sega游戏主机Dreamcast等系统的预设字型，显示效果比<code>Arial</code>要好。</p> \n <p>·Verdana：无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。</p> \n <p>·其他：Windows 下默认字体列表：微软官网、维基百科、Office字体</p> \n <p>结论：<code>微软雅黑</code>为Win平台上最值得选择的中文字体，但非游览器默认，需要设置；西文字体的选择以<code>Arial</code>、<code>Tahoma</code>等无衬线字体为主。</p> \n <p>2、Mac OS下：</p> \n <p>·华文黑体（STHeiti）、华文细黑（STXihei）：属于同一字体家族系列，OS X 10.6 之前的简体中文系统界面默认字体，也是目前Chrome游览器下的默认字体，有&nbsp;<em>Regular</em>&nbsp;和&nbsp;<em>Bold</em>&nbsp;两个字重，显示效果可以接受，<code>华文细黑</code>也曾是我最喜欢的字体之一。</p> \n <p>·黑体-简（Heiti SC）：从 10.6 开始，<code>黑体-简</code>代替<code>华文黑体</code>用作简体中文系统界面默认字体，苹果生态最常用的字体之一，包括iPhone、iPad等设备用的也是这款字体，显示效果不错，但是喇叭口设计遭人诟病。</p> \n <p>·冬青黑体（ Hiragino Sans GB ）：听说又叫<code>苹果丽黑</code>，日文字体<code>Hiragino KakuGothic</code>的简体中文版，简体中文有&nbsp;<em>常规体</em>和&nbsp;<em>粗体</em>&nbsp;两种，<code>冬青黑体</code>是一款清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。</p> \n <p>·Times New Roman：Mac平台Safari下默认的字体，是最常见且广为人知的西文衬线字体之一，众多网页浏览器和文字处理软件都是用它作为默认字体。</p> \n <p>·Helvetica、Helvetica Neue：一种被广泛使用的传奇般的西文字体（这货还有专门的记录片呢），在微软使用山寨货的<code>Arial</code>时，乔布斯却花费重金获得了<code>Helvetica</code>苹果系统上的使用权，因此该字体也一直伴随着苹果用户，是苹果生态中最常用的西文字体。<code>Helvetica Neue</code>为<code>Helvetica</code>的改善版本，且增加了更多不同粗细与宽度的字形，共拥有51种字体版本，极大的满足了日常的使用。</p> \n <p>·苹方（PingFang SC）：在Mac OS X EL Capitan上，苹果为中国用户打造了一款全新中文字体--<code>苹方</code>，去掉了为人诟病的喇叭口，整体造型看上去更加简洁，字族共六枚字体：<em>极细体、纤细体、细体、常规体、中黑体、中粗体</em>。</p> \n <p>·San Francisco：同样是Mac OS X EL Capitan上最新发布的西文字体，感觉和<code>Helvetica</code>看上去差别不大，目前已经应用在Mac OS 10.11+、iOS 9.0+、watch OS等最新系统上。</p> \n <p>·其他：Mac下默认字体列表：苹果官网、维基百科</p> \n <p>·结论：目前<code>苹方</code>和<code>San Francisco</code>为苹果推出的最新字体，显示效果也最为优雅，但只有最新系统才能支持，而<code>黑体-简</code>和<code>Helvetica</code>可以获得更多系统版本支持，显示效果也相差无几，可以接受。</p> \n <p>&nbsp;</p> \n <p>3、Android系统：</p> \n <p>·Droid Sans、Droid Sans Fallback：<code>Droid Sans</code>为安卓系统中默认的西文字体，是一款人文主义无衬线字体，而<code>Droid Sans Fallback</code>则是包含汉字、日文假名、韩文的文字扩展支持。</p> \n <p>·结论：<code>Droid Sans</code>为默认的字体，并结合了中英文，无需单独设置。</p> \n <p>&nbsp;</p> \n <p>4、iOS系统：</p> \n <p>·iOS系统的字体和Mac OS系统的字体相同，保证了Mac上的字体效果，iOS设备就没有太大问题。</p> \n <p>&nbsp;</p> \n <p>5、Linux：</p> \n <p>·文泉驿点阵宋体：类似<code>宋体</code>的衬线字体，一般不推荐使用。</p> \n <p>·文泉驿微米黑：几乎是 Linux 社区现有的最佳简体中文字体。</p> \n <span id=\"OSC_h3_1\"></span> \n <h3>二、选择字体需要注意的问题</h3> \n <p>&nbsp;</p> \n <p>1、字体的中英文写法：</p> \n <p>我们在操作系统中常常看到<code>宋体</code>、<code>微软雅黑</code>这样的字体名称，但实际上这只是字体的显示名称，而不是字体文件的名称，一般字体文件都是用英文命名的，如<code>SimSun</code>、<code>Microsoft Yahei</code>。在大多数情况下直接使用显示名称也能正确的显示，但是有一些用户的特殊设置会导致中文声明无效。<br> 因此，保守的做法是使用字体的字体名称（英文）或者两者兼写。如下示例：</p> \n <pre><code>font-family: STXihei, \"Microsoft YaHei\";\nfont-family: STXihei, “华文细黑”, “Microsoft YaHei”, “微软雅黑”;</code></pre> \n <p>2、声明英文字体：</p> \n <p>绝大部分中文字体里都包含英文字母和数字，不进行英文字体声明是没有问题的，但是大多数中文字体中的英文和数字的部分都不是特别漂亮，所以建议也对英文字体进行声明。<br> 由于英文字体中大多不包含中文，我们可以先进行英文字体的声明，这样不会影响到中文字体的选择，因此优先使用最优秀的英文字体，中文字体声明则紧随其次。如下示例：</p> \n <p>&nbsp;</p> \n <pre><code>font-family: Arial, \"Microsoft YaHei\";</code></pre> \n <p>3、照顾不同的操作系统：</p> \n <p>·英文、数字部分：在默认的操作系统中，Mac和Win都会带有<code>Arial</code>,&nbsp;<code>Verdana</code>,&nbsp;<code>Tahoma</code>等几个预装字体，从显示效果来看，<code>Tahoma</code>要比<code>Arial</code>更加清晰一些，因此字体设置<code>Tahoma</code>最好放到前面，当找不到<code>Tahoma</code>时再使用<code>Arial</code>；而在Mac中，还拥有一款更加漂亮的<code>Helvetica</code>字体，所以为了照顾Mac用户有更好的体验，应该更优先设置<code>Helvetica</code>字体；Android系统下默认的无衬线字体就可以接受，因此无需单独设置。最后，英文、数字字体的最佳写法如下：</p> \n <p>&nbsp;</p> \n <pre><code>font-family: Helvetica, Tahoma, Arial;</code></pre> \n <p>·中文部分：在Win下，<code>微软雅黑</code>为大部分人最常使用的中文字体，由于很多人安装Office的缘故，Mac电脑中也会出现微软雅黑字体，因此把显示效果不错的<code>微软雅黑</code>加入到字体列表是个不错的选择；同样，为了保证Mac中更为优雅字体<code>苹方（PingFang SC）</code>、<code>黑体-简（Heiti SC）</code>、<code>冬青黑体（ Hiragino Sans GB ）</code>的优先显示，需要把这些字体放到中文字体列表的最前面；同时为了照顾到Linux操作系统的体验，还需要添加<code>文泉驿微米黑</code>字体。最后，中文字体部分最佳写法如下：</p> \n <p>&nbsp;</p> \n <pre><code>font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\";</code></pre> \n <p>中英文整合写法：</p> \n <pre><code>font-family: Helvetica, Tahoma, Arial, \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\";\nfont-family: Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\";</code></pre> \n <p>&nbsp;</p> \n <p>4、注意向下兼容</p> \n <p>如果还需要考虑旧版本操作系统用户的话，不得不加上一些旧版操作系统存在的字体：Mac中的<code>华文黑体</code>、<code>冬青黑体</code>，Win中的<code>黑体</code>等。同样按照显示效果排列在列表后面，写法如下：</p> \n <pre><code>font-family: Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", STXihei, \"Microsoft YaHei\", SimHei, \"WenQuanYi Micro Hei\";</code></pre> \n <p>&nbsp;</p> \n <p>加入了<code>&nbsp;STXihei（华文细黑）</code>和<code>&nbsp;SimHei（黑体）</code>。</p> \n <p>5、补充字体族名称</p> \n <p>字体族大体上分为两类：<code>sans-serif（无衬线体）</code>和<code>serif（衬线体）</code>，当所有的字体都找不到时，我们可以使用字体族名称作为操作系统最后选择字体的方向。一般非衬线字体在显示器中的显示效果会比较好，因此我们需要在最后添加<code>&nbsp;sans-serif</code>，写法如下：。</p> \n <p>&nbsp;</p> \n <pre><code>font-family: Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif;</code></pre> \n <p>&nbsp;</p> \n <span id=\"OSC_h3_2\"></span> \n <h3>三、我们看一下大公司的常见写法（2016.07查看）</h3> \n <p>&nbsp;</p> \n <p>1、小米</p> \n <pre><code>font: 14px/1.5 \"Helvetica Neue\",Helvetica,Arial,\"Microsoft Yahei\",\"Hiragino Sans GB\",\"Heiti SC\",\"WenQuanYi Micro Hei\",sans-serif;</code></pre> \n <p>小米公司优先使用<code>Helvetica Neue</code>这款字体以保证最新版本Mac用户的最佳体验，选择了<code>Arial</code>作为Win下默认英文字体及Mac的替代英文字体；中文字体方面首选了<code>微软雅黑</code>，然后选择了<code>冬青黑体</code>及<code>黑体-简</code>作为Mac上的替代方案；最后使用<code>文泉驿微米黑</code>兼顾了Linux系统。</p> \n <p>2、淘宝</p> \n <p>鉴于淘宝网改版频率较频繁，这里截图保存了一下，点此查看。</p> \n <pre><code>font: 12px/1.5 tahoma,arial,\'Hiragino Sans GB\',\'\\5b8b\\4f53\',sans-serif;</code></pre> \n <p>其实从图中明显看出淘宝网的导航及内容有着大量的衬线字体，鉴于淘宝网站大部分字号比较小，显示效果也还可以接受。代码中可以看出淘宝使用了<code>Tahoma</code>、<code>Arial</code>作为首选英文字体，中文字体首选了<code>冬青黑体</code>，由于Win下没有预装该款字体，所以显示出了后面的宋体（<code>5b8b4f53</code>为汉字<code>宋体</code>用 unicode 表示的写法，不用<code>SimSun</code>是因为 Firefox 的某些版本和 Opera 不支持&nbsp;<code>SimSun</code>的写法）</p> \n <p>3、简书</p> \n <pre><code>font-family: \"lucida grande\", \"lucida sans unicode\", lucida, helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif;</code></pre> \n <p>&nbsp;</p> \n <p>自认为简书的阅读体验很棒，我们看看简书所用的字体，简书优先选择了<code>lucida</code>家族的系列字体作为英文字体，该系列字体在Mac和Win上都是预装的，并且有着不俗的表现；中文字体方面将<code>冬青黑体</code>作为最优先使用的字体，同样考虑了Linux系统。</p> \n <p><em>各大公司的字体设置大同小异，这里不再一一举例查看，有兴趣的可以自己多多查看。</em></p> \n <p>&nbsp;</p> \n <span id=\"OSC_h3_3\"></span> \n <h3>四、其他的一些注意点</h3> \n <p>&nbsp;</p> \n <p>1、字体何时需要添加引号</p> \n <p>当字体具体某个取值中若有一种样式名称包含空格，则需要用双引号或单引号表示，如：</p> \n <pre><code>font-family: \"Microsoft YaHei\", \"Arial Narrow\", sans-serif;</code></pre> \n <p>如果书写中文字体名称为了保证兼容性也会添加引号，如：</p> \n <pre><code>font-family: \"黑体-简\", \"微软雅黑\", \"文泉驿微米黑\";</code></pre> \n <p>&nbsp;</p> \n <p>2、引用外部字体</p> \n <p>大多数的中文字体由于版权原因不能随意使用，这里推荐一个免版权而且漂亮的中文字体<code>思源黑体</code>，该字体为Adobe与Google推出的一款开源字体， 有七种字体粗细<em>（ExtraLight、Light、Normal、Regular、Medium、Bold 和 Heavy）</em>，完全支持日文、韩文、繁体中文和简体中文，字形优美，依稀记得小米公司好像有使用过。<br> 鉴于中文字体的体积比较大（一般字库全一点的中文字体动辄几Mb），所以较少人会使用外部字体，如果真的需要引入，也可以考虑通过工具根据页面文字的使用多少单独生成中文字体，以减小文件大小。</p> \n <span id=\"OSC_h3_4\"></span> \n <h3>五、最后，推荐写法</h3> \n <p>由于每个人的审美不一样，钟爱的字体也会有所有不同，这里给出我个人的常用写法：</p> \n <pre><code>font-family: \"Helvetica Neue\", Helvetica, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif;</code></pre> \n <p>&nbsp;</p> \n <p>另外推荐两个github上的关于中文字体和排版的项目：</p> \n <p>Fonts.css -- 跨平台中文字体解决方案</p> \n <p>typo.css -- 中文网页重设与排版：一致化浏览器排版效果</p> \n <span id=\"OSC_h3_5\"></span> \n <h3>--参考资料</h3> \n <p>&nbsp;</p> \n <ul> \n  <li> <p>如何保证网页的字体在各平台都尽量显示为最高质量的黑体？</p> </li> \n  <li> <p>Web 中文字体应用指南</p> </li> \n  <li> <p>\"5b8b4f53\"的意思</p> </li> \n </ul> \n</div>',NULL,'2020-02-01 16:56:07',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223531927156408320',NULL,NULL,' Windows下通过pip安装PyTorch 0.4.0 import 不成功 anaconda  ','<div class=\"content\" id=\"articleContent\"> \n <p>问题：通过pip安装PyTorch 0.4.0成功，但是import时报错。</p> \n <p>&nbsp; import torch<br> &nbsp; File \"D:\\Python\\Python36\\lib\\site-packages\\torch\\__init__.py\", line 78, in &lt;module&gt;<br> &nbsp;&nbsp;&nbsp; from torch._C import *<br> ImportError: DLL load failed: 找不到指定的模块。</p> \n <p>解决：</p> \n <ul> \n  <li>Download&nbsp;<strong><a href=\"https://anaconda.org/anaconda/intel-openmp/files\" target=\"_blank\" rel=\"nofollow\">win-64/intel-openmp-2018.0.0-8.tar.bz2</a></strong></li> \n </ul> \n <ul> \n  <li>put the dll files in&nbsp;<strong>Library\\bin</strong>&nbsp;into a dir</li> \n </ul> \n <ul> \n  <li>append the path of it to the environment variable&nbsp;<strong>PATH</strong>.</li> \n </ul> \n <p>参考：</p> \n <p><a href=\"https://github.com/pytorch/pytorch/issues/4518\" target=\"_blank\" rel=\"nofollow\">from torch._C import * (ImportError: DLL load failed: The specified module could not be found.</a></p> \n</div>',NULL,'2020-02-01 16:56:50',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532271638757376',NULL,NULL,' 基于CMS的组件复用实践   ','<div class=\"content\" id=\"articleContent\"> \n <p><span style=\"color:#000000\">目前前端项目大多基于Vue、React、Angular等框架来实现，这一类框架都有一个明显的特点：基于模块化以及组件化思维。所以，开发者在使用上述框架时，实际上是在写一个一个的组件，并且组件与组件之间呈嵌套的形式。当一个项目中多次出现同一功能时，</span><span style=\"color:#000000\">他们会选择</span><span style=\"color:#000000\">将其提取出来，并且放到components文件夹中，以达到复用的目的，但是这些</span>复用都是基于同一项目的，所以，当写另一个项目时，又要开始写一些重复的代码。</p> \n <p style=\"text-align:justify\"><span style=\"background-color:#ffffff\"><span style=\"color:#000000\">个推拥有多条业务线，在进行前端项目时总会遇到重复写代码的困境，所以，我们</span></span><span style=\"background-color:#ffffff\"><span style=\"color:#000000\">做了PCMS项目，主要为了解决跨项目之间的组件复用</span></span><span style=\"background-color:#ffffff\"><span style=\"color:#000000\">问题</span></span><span style=\"background-color:#ffffff\"><span style=\"color:#000000\">，其中的技术栈是基于Vue的，所以PCMS同时也是基于Vue项目实现的。</span></span>&nbsp;</p> \n <p style=\"text-align:justify\"><span style=\"color:#000000\">接下来我将基于自己在前端工作过程中的实践，跟大家分享基于CMS的组件复用实践。</span></p> \n <p><span style=\"color:#000000\">想要实现跨项目之间的组件复用，</span><span style=\"color:#000000\">需要</span><span style=\"color:#000000\">解决以下问题，</span></p> \n <p><span style=\"color:#000000\">1.组件与组件之间，组件与项目之间需要解耦</span></p> \n <p><span style=\"color:#000000\">2.组件需要给出使用方法（文档）</span></p> \n <p><span style=\"color:#000000\">3.组件需要能够独立运行</span></p> \n <p><span style=\"color:#000000\">4.组件需要有版本管理并且可以按需加载</span></p> \n <p><span style=\"color:#000000\">5</span>.需要一个工具把这些组件管理并且展示出来</p> \n <p>在上述五大问题中，首先要解决组件与组件以及项目之间的解耦问题，为此，我们需要将组件内部和其它组件以及项目耦合的部分剔除，然后通过props传入，为了方便区分这些props与普通props，我们把他们放到了一个名为ds的对象中 。通常，这些耦合部分会是一些API或VUEX调用或者前端路由操作等。</p> \n <p>同时， 为了方便这些组件的编写和维护，我们给组件制定了更加严格的约束，同时将这些符合约束的复用组件称为“区块”，意思是可以独立于项目的一个功能区域。</p> \n <p>在解耦过程中，我们发现这些区块的代码可以有一些重复部分，比如ds的一些优化和mock的注册等，所以我们开发了一个vue插件。在项目使用区块时，为了完成按需加载时的引用方式以及生产环境下Mock数据的剔除，我们又开发了一个webpack插件。</p> \n <p>在具体实践过程中，为了实现组件的复用，需要按照固定的结构去写组件，还需要在项目中修改main.js和webpack配置工作，所以，我们开发了CLI工具和GUI工具来生成项目和组件基本文件，同时管理和调试组件。</p> \n <p><span style=\"color:#000000\">完成了CLI和GUI工具之后，</span><span style=\"color:#000000\">具体的</span><span style=\"color:#000000\">开发流程如下所示：</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 使用CLI生成项目</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 开发页面</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 从GUI工具查找合适的区块，直接使用或者下载代码微调</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 页面开发完成</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 对于可复用的功能，使用CLI生成区块基本文件，进行区块开发</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 开发完毕，项目上线发布区块库</span></p> \n <p><span style=\"color:#000000\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7. 下一次开发项目时，可以直接使用该区块或者下载代码</span></p> \n <p><span style=\"color:#000000\">使用了区块的开发模式后，虽然开发流程与之前</span><span style=\"color:#000000\">相比</span><span style=\"color:#000000\">并没有太大区别，但有效提升了开发的速度，同时还能将任务拆分得更细，对于团队中的初学者来说，一个有使用文档的业务组件更加容易被他们接受，对于业务的上手速度也更快。</span></p> \n <p><span style=\"color:#000000\">本文根据个推</span><span style=\"color:#000000\">高级前端开发工程师沈创</span><span style=\"color:#000000\">在</span><span style=\"color:#000000\">个推TechDay全国巡回沙龙</span><span style=\"color:#000000\">广州站的演讲内容进行整理，略有删减。</span></p> \n <p><span style=\"color:#000000\">接下来，</span><span style=\"color:#000000\">个推</span><span style=\"background-color:#ffffff\"><span style=\"color:#000000\">TechDay</span></span><span style=\"background-color:#ffffff\"><span style=\"color:#000000\">全国</span></span><span style=\"color:#000000\">沙龙还将走进成都、杭州、上海、深圳几大城市，邀请业内技术大咖跟大家一起交流学习，敬请期待！</span></p> \n</div>',NULL,'2020-02-01 17:03:13',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532330224795648',NULL,NULL,' JAVA多线程和并发基础面试问答  ','<div class=\"content\" id=\"articleContent\"> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 多线程和并发问题是Java技术面试中面试官比较喜欢问的问题之一。在这里，从面试的角度列出了大部分重要的问题，但是你仍然应该牢固的掌握Java多线程基础知识来对应日后碰到的问题。（<em>校对注：非常赞同这个观点</em>） </p> \n <span id=\"OSC_h2_1\"></span> \n <h2> Java多线程面试问题 </h2> \n <span id=\"OSC_h3_2\"></span> \n <h3> 1. 进程和线程之间有什么不同？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。<span></span> </p> \n <span id=\"OSC_h3_3\"></span> \n <h3> 2. 多线程编程的好处是什么？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。 </p> \n <span id=\"OSC_h3_4\"></span> \n <h3> 3. 用户线程和守护线程有什么区别？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。 </p> \n <span id=\"OSC_h3_5\"></span> \n <h3> 4. 我们如何创建一个线程？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在<a href=\"http://www.journaldev.com/1016/java-thread-example-extending-thread-class-and-implementing-runnable-interface\" rel=\"nofollow\">Java中创建线程</a>的文章。 </p> \n <span id=\"OSC_h3_6\"></span> \n <h3> 5. 有哪些不同的线程生命周期？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 当我们在Java程序中新建一个线程时，它的状态是<em>New。</em>当我们调用线程的start()方法时，状态被改变为<em>Runnable</em>。线程调度器会为<i>Runnable</i>线程池中的线程分配CPU时间并且讲它们的状态改变为<em>Running。</em>其他的线程状态还有<em>Waiting，Blocked</em>&nbsp;和<em>Dead</em>。读这篇文章可以了解更多关于<a href=\"http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java\" rel=\"nofollow\">线程生命周期</a>的知识。 </p> \n <span id=\"OSC_h3_7\"></span> \n <h3> 6. 可以直接调用Thread类的run()方法么？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。 </p> \n <span id=\"OSC_h3_8\"></span> \n <h3> 7. 如何让正在运行的线程暂停一段时间？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为<em>Runnable</em>，并且根据线程调度，它将得到执行。 </p> \n <span id=\"OSC_h3_9\"></span> \n <h3> 8. 你对线程优先级的理解是什么？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。 </p> \n <span id=\"OSC_h3_10\"></span> \n <h3> 9. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 线程调度器是一个操作系统服务，它负责为<em>Runnable</em>状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的<em>Runnable</em>线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 </p> \n <span id=\"OSC_h3_11\"></span> \n <h3> 10. 在多线程中，什么是上下文切换(context-switching)？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。 </p> \n <span id=\"OSC_h3_12\"></span> \n <h3> 11. 你如何确保main()方法所在的线程是Java程序最后结束的线程？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。这里有一篇文章关于<a href=\"http://www.journaldev.com/1024/java-thread-join-example-with-explanation\" rel=\"nofollow\">Thread类的joint()方法</a>。 </p> \n <span id=\"OSC_h3_13\"></span> \n <h3> 12.线程之间是如何通信的？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\\notify()\\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击<a href=\"http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example\" rel=\"nofollow\">这里</a>有更多关于线程wait, notify和notifyAll. </p> \n <span id=\"OSC_h3_14\"></span> \n <h3> 13.为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法 </p> \n <span id=\"OSC_h3_15\"></span> \n <h3> 14. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 </p> \n <span id=\"OSC_h3_16\"></span> \n <h3> 15. 为什么Thread类的sleep()和yield()方法是静态的？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 </p> \n <span id=\"OSC_h3_17\"></span> \n <h3> 16.如何确保线程安全？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。在<a href=\"http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples\" rel=\"nofollow\">线程安全教程</a>中，你可以学到更多。 </p> \n <span id=\"OSC_h3_18\"></span> \n <h3> 17. volatile关键字在Java中有什么作用？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。 </p> \n <span id=\"OSC_h3_19\"></span> \n <h3> 18. 同步方法和同步块，哪个是更好的选择？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 </p> \n <span id=\"OSC_h3_20\"></span> \n <h3> 19.如何创建守护线程？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。 </p> \n <span id=\"OSC_h3_21\"></span> \n <h3> 20. 什么是ThreadLocal? </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 每个线程都会拥有他们自己的Thread变量，它们可以使用get()\\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在<a href=\"http://www.journaldev.com/1076/java-threadlocal-example-to-create-thread-local-variables\" rel=\"nofollow\">ThreadLocal例子</a>这篇文章中你可以看到一个关于ThreadLocal的小程序。 </p> \n <span id=\"OSC_h3_22\"></span> \n <h3> 21. 什么是Thread Group？为什么建议使用它？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> ThreadGroup是一个类，它的目的是提供关于线程组的信息。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> ThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了<em>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</em>&nbsp;方法，所以ThreadGroup是已经过时的，不建议继续使用。 </p> \n <div> \n  <div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 1 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> t1.setUncaughtExceptionHandler(new&nbsp;UncaughtExceptionHandler(){ </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 2 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> &nbsp; </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 3 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> @Override </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 4 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> public&nbsp;void&nbsp;uncaughtException(Thread t, Throwable e) { </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 5 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> System.out.println(\"exception occured:\"+e.getMessage()); </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 6 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> } </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 7 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> &nbsp; </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 8 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> }); </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n  </div> \n </div> \n <span id=\"OSC_h3_23\"></span> \n <h3> 22. 什么是Java线程转储(Thread Dump)，如何得到它？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。读这篇文档可以了解更多关于<a href=\"http://www.journaldev.com/1053/how-to-generate-thread-dump-in-java\" rel=\"nofollow\">产生线程转储</a>的知识。 </p> \n <span id=\"OSC_h3_24\"></span> \n <h3> 23. 什么是死锁(Deadlock)？如何分析和避免死锁？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法，阅读这篇文章去学习<a href=\"http://www.journaldev.com/1058/java-deadlock-example-and-how-to-analyze-deadlock-situation\" rel=\"nofollow\">如何分析死锁</a>。 </p> \n <span id=\"OSC_h3_25\"></span> \n <h3> 24. 什么是Java Timer类？如何创建一个有特定时间间隔的任务？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 这里有关于<a href=\"http://www.journaldev.com/1050/java-timer-and-timertask-example-tutorial\" rel=\"nofollow\">java Timer的例子</a>。 </p> \n <span id=\"OSC_h3_26\"></span> \n <h3> 25. 什么是线程池？如何创建一个Java线程池？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> java.util.concurrent.Executors提供了一个&nbsp;java.util.concurrent.Executor接口的实现用于创建线程池。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" rel=\"nofollow\">线程池例子</a>展现了如何创建和使用线程池，或者阅读<a href=\"http://www.journaldev.com/2340/java-scheduledthreadpoolexecutor-example-to-schedule-tasks-after-delay-and-execute-periodically\" rel=\"nofollow\">ScheduledThreadPoolExecutor</a>例子，了解如何创建一个周期任务。 </p> \n <span id=\"OSC_h2_27\"></span> \n <h2> Java并发面试问题 </h2> \n <span id=\"OSC_h3_28\"></span> \n <h3> 1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解<a href=\"http://www.journaldev.com/1095/java-atomic-operations-atomicinteger-example\" rel=\"nofollow\">Java的atomic类</a>。 </p> \n <span id=\"OSC_h3_29\"></span> \n <h3> 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 它的优势有： </p> \n <ul> \n  <li> 可以使锁更公平 </li> \n  <li> 可以使线程在等待锁的时候响应中断 </li> \n  <li> 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 </li> \n  <li> 可以在不同的范围，以不同的顺序获取和释放锁 </li> \n </ul> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 阅读更多<a href=\"http://www.journaldev.com/2377/java-lock-example-and-concurrency-lock-vs-synchronized\" rel=\"nofollow\">关于锁的例子</a> </p> \n <span id=\"OSC_h3_30\"></span> \n <h3> 3. 什么是Executors框架？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池，阅读这篇文章可以了解<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" rel=\"nofollow\">如何使用Executor框架创建一个线程池</a>。 </p> \n <span id=\"OSC_h3_31\"></span> \n <h3> 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> BlockingQueue&nbsp;接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 阅读这篇文章了解<a href=\"http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem\" rel=\"nofollow\">如何使用阻塞队列实现生产者-消费者问题。</a> </p> \n <span id=\"OSC_h3_32\"></span> \n <h3> 5. 什么是Callable和Future? </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 阅读这篇文章了解更多<a href=\"http://www.journaldev.com/1090/java-callable-future-example\" rel=\"nofollow\">关于Callable，Future的例子</a>。 </p> \n <span id=\"OSC_h3_33\"></span> \n <h3> 6. 什么是FutureTask? </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，单当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读<a href=\"http://www.journaldev.com/1650/java-futuretask-example-program\" rel=\"nofollow\">Java FutureTask例子</a>，学习如何使用它。 </p> \n <span id=\"OSC_h3_34\"></span> \n <h3> 7.什么是并发容器的实现？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 并发容器支持并发的遍历和并发的更新。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> 主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet，阅读这篇文章了解<a href=\"http://www.journaldev.com/378/how-to-avoid-concurrentmodificationexception-when-using-an-iterator\" rel=\"nofollow\">如何避免ConcurrentModificationException</a>。 </p> \n <span id=\"OSC_h3_35\"></span> \n <h3> 8. Executors类是什么？ </h3> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 </p> \n <p style=\"color:#666666;font-family:Arial, Helvetica, sans-serif;font-size:14px;\"> Executors可以用于方便的创建线程池。 </p> \n</div>',NULL,'2020-02-01 17:03:30',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532374478897152',NULL,NULL,' JAVA多线程和并发基础面试问答  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h2_1\"></span> \n <h2> Java多线程面试问题 </h2> \n <span id=\"OSC_h3_2\"></span> \n <h3> 1. 进程和线程之间有什么不同？ </h3> \n <p> 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。<span></span> </p> \n <span id=\"OSC_h3_3\"></span> \n <h3> 2. 多线程编程的好处是什么？ </h3> \n <p> 在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。 </p> \n <span id=\"OSC_h3_4\"></span> \n <h3> 3. 用户线程和守护线程有什么区别？ </h3> \n <p> 当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。 </p> \n <span id=\"OSC_h3_5\"></span> \n <h3> 4. 我们如何创建一个线程？ </h3> \n <p> 有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在<a href=\"http://www.journaldev.com/1016/java-thread-example-extending-thread-class-and-implementing-runnable-interface\" rel=\"nofollow\">Java中创建线程</a>的文章。 </p> \n <span id=\"OSC_h3_6\"></span> \n <h3> 5. 有哪些不同的线程生命周期？ </h3> \n <p> 当我们在Java程序中新建一个线程时，它的状态是<em>New。</em>当我们调用线程的start()方法时，状态被改变为<em>Runnable</em>。线程调度器会为<i>Runnable</i>线程池中的线程分配CPU时间并且讲它们的状态改变为<em>Running。</em>其他的线程状态还有<em>Waiting，Blocked</em>&nbsp;和<em>Dead</em>。读这篇文章可以了解更多关于<a href=\"http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java\" rel=\"nofollow\">线程生命周期</a>的知识。 </p> \n <span id=\"OSC_h3_7\"></span> \n <h3> 6. 可以直接调用Thread类的run()方法么？ </h3> \n <p> 当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。 </p> \n <span id=\"OSC_h3_8\"></span> \n <h3> 7. 如何让正在运行的线程暂停一段时间？ </h3> \n <p> 我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为<em>Runnable</em>，并且根据线程调度，它将得到执行。 </p> \n <span id=\"OSC_h3_9\"></span> \n <h3> 8. 你对线程优先级的理解是什么？ </h3> \n <p> 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。 </p> \n <span id=\"OSC_h3_10\"></span> \n <h3> 9. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ </h3> \n <p> 线程调度器是一个操作系统服务，它负责为<em>Runnable</em>状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的<em>Runnable</em>线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 </p> \n <span id=\"OSC_h3_11\"></span> \n <h3> 10. 在多线程中，什么是上下文切换(context-switching)？ </h3> \n <p> 上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。 </p> \n <span id=\"OSC_h3_12\"></span> \n <h3> 11. 你如何确保main()方法所在的线程是Java程序最后结束的线程？ </h3> \n <p> 我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。这里有一篇文章关于<a href=\"http://www.journaldev.com/1024/java-thread-join-example-with-explanation\" rel=\"nofollow\">Thread类的joint()方法</a>。 </p> \n <span id=\"OSC_h3_13\"></span> \n <h3> 12.线程之间是如何通信的？ </h3> \n <p> 当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\\notify()\\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击<a href=\"http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example\" rel=\"nofollow\">这里</a>有更多关于线程wait, notify和notifyAll. </p> \n <span id=\"OSC_h3_14\"></span> \n <h3> 13.为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？ </h3> \n <p> Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法 </p> \n <span id=\"OSC_h3_15\"></span> \n <h3> 14. 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？ </h3> \n <p> 当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 </p> \n <span id=\"OSC_h3_16\"></span> \n <h3> 15. 为什么Thread类的sleep()和yield()方法是静态的？ </h3> \n <p> Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 </p> \n <span id=\"OSC_h3_17\"></span> \n <h3> 16.如何确保线程安全？ </h3> \n <p> 在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。在<a href=\"http://www.journaldev.com/1061/java-synchronization-and-thread-safety-tutorial-with-examples\" rel=\"nofollow\">线程安全教程</a>中，你可以学到更多。 </p> \n <span id=\"OSC_h3_18\"></span> \n <h3> 17. volatile关键字在Java中有什么作用？ </h3> \n <p> 当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。 </p> \n <span id=\"OSC_h3_19\"></span> \n <h3> 18. 同步方法和同步块，哪个是更好的选择？ </h3> \n <p> 同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 </p> \n <span id=\"OSC_h3_20\"></span> \n <h3> 19.如何创建守护线程？ </h3> \n <p> 使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。 </p> \n <span id=\"OSC_h3_21\"></span> \n <h3> 20. 什么是ThreadLocal? </h3> \n <p> ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 </p> \n <p> 每个线程都会拥有他们自己的Thread变量，它们可以使用get()\\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在<a href=\"http://www.journaldev.com/1076/java-threadlocal-example-to-create-thread-local-variables\" rel=\"nofollow\">ThreadLocal例子</a>这篇文章中你可以看到一个关于ThreadLocal的小程序。 </p> \n <span id=\"OSC_h3_22\"></span> \n <h3> 21. 什么是Thread Group？为什么建议使用它？ </h3> \n <p> ThreadGroup是一个类，它的目的是提供关于线程组的信息。 </p> \n <p> ThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了<em>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</em>&nbsp;方法，所以ThreadGroup是已经过时的，不建议继续使用。 </p> \n <div> \n  <div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 1 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> t1.setUncaughtExceptionHandler(new&nbsp;UncaughtExceptionHandler(){ </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 2 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> &nbsp; </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 3 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> @Override </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 4 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> public&nbsp;void&nbsp;uncaughtException(Thread t, Throwable e) { </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 5 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> System.out.println(\"exception occured:\"+e.getMessage()); </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 6 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> } </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 7 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> &nbsp; </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n   <div> \n    <table style=\"margin:0px !important;padding:0px !important;width:auto !important;border:0px !important;height:auto !important;font-size:1em !important;\"> \n     <tbody> \n      <tr> \n       <td style=\"border:0px !important;vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;color:#787878 !important;\"> 8 </td> \n       <td style=\"vertical-align:top !important;font-family:Consolas, \'Bitstream Vera Sans Mono\', \'Courier New\', Courier, monospace !important;font-size:1em !important;\"> }); </td> \n      </tr> \n     </tbody> \n    </table> \n   </div> \n  </div> \n </div> \n <span id=\"OSC_h3_23\"></span> \n <h3> 22. 什么是Java线程转储(Thread Dump)，如何得到它？ </h3> \n <p> 线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。读这篇文档可以了解更多关于<a href=\"http://www.journaldev.com/1053/how-to-generate-thread-dump-in-java\" rel=\"nofollow\">产生线程转储</a>的知识。 </p> \n <span id=\"OSC_h3_24\"></span> \n <h3> 23. 什么是死锁(Deadlock)？如何分析和避免死锁？ </h3> \n <p> 死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。 </p> \n <p> 分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。 </p> \n <p> 避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法，阅读这篇文章去学习<a href=\"http://www.journaldev.com/1058/java-deadlock-example-and-how-to-analyze-deadlock-situation\" rel=\"nofollow\">如何分析死锁</a>。 </p> \n <span id=\"OSC_h3_25\"></span> \n <h3> 24. 什么是Java Timer类？如何创建一个有特定时间间隔的任务？ </h3> \n <p> java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。 </p> \n <p> java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。 </p> \n <p> 这里有关于<a href=\"http://www.journaldev.com/1050/java-timer-and-timertask-example-tutorial\" rel=\"nofollow\">java Timer的例子</a>。 </p> \n <span id=\"OSC_h3_26\"></span> \n <h3> 25. 什么是线程池？如何创建一个Java线程池？ </h3> \n <p> 一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。 </p> \n <p> java.util.concurrent.Executors提供了一个&nbsp;java.util.concurrent.Executor接口的实现用于创建线程池。<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" rel=\"nofollow\">线程池例子</a>展现了如何创建和使用线程池，或者阅读<a href=\"http://www.journaldev.com/2340/java-scheduledthreadpoolexecutor-example-to-schedule-tasks-after-delay-and-execute-periodically\" rel=\"nofollow\">ScheduledThreadPoolExecutor</a>例子，了解如何创建一个周期任务。 </p> \n <span id=\"OSC_h2_27\"></span> \n <h2> Java并发面试问题 </h2> \n <span id=\"OSC_h3_28\"></span> \n <h3> 1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？ </h3> \n <p> 原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 </p> \n <p> int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 </p> \n <p> 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解<a href=\"http://www.journaldev.com/1095/java-atomic-operations-atomicinteger-example\" rel=\"nofollow\">Java的atomic类</a>。 </p> \n <span id=\"OSC_h3_29\"></span> \n <h3> 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？ </h3> \n <p> Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 </p> \n <p> 它的优势有： </p> \n <ul> \n  <li> 可以使锁更公平 </li> \n  <li> 可以使线程在等待锁的时候响应中断 </li> \n  <li> 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 </li> \n  <li> 可以在不同的范围，以不同的顺序获取和释放锁 </li> \n </ul> \n <p> 阅读更多<a href=\"http://www.journaldev.com/2377/java-lock-example-and-concurrency-lock-vs-synchronized\" rel=\"nofollow\">关于锁的例子</a> </p> \n <span id=\"OSC_h3_30\"></span> \n <h3> 3. 什么是Executors框架？ </h3> \n <p> Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 </p> \n <p> 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池，阅读这篇文章可以了解<a href=\"http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor\" rel=\"nofollow\">如何使用Executor框架创建一个线程池</a>。 </p> \n <span id=\"OSC_h3_31\"></span> \n <h3> 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？ </h3> \n <p> java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。 </p> \n <p> 阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。 </p> \n <p> 阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。 </p> \n <p> BlockingQueue&nbsp;接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。 </p> \n <p> 阅读这篇文章了解<a href=\"http://www.journaldev.com/1034/java-blockingqueue-example-implementing-producer-consumer-problem\" rel=\"nofollow\">如何使用阻塞队列实现生产者-消费者问题。</a> </p> \n <span id=\"OSC_h3_32\"></span> \n <h3> 5. 什么是Callable和Future? </h3> \n <p> Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。 </p> \n <p> Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。 </p> \n <p> 阅读这篇文章了解更多<a href=\"http://www.journaldev.com/1090/java-callable-future-example\" rel=\"nofollow\">关于Callable，Future的例子</a>。 </p> \n <span id=\"OSC_h3_33\"></span> \n <h3> 6. 什么是FutureTask? </h3> \n <p> FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，单当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读<a href=\"http://www.journaldev.com/1650/java-futuretask-example-program\" rel=\"nofollow\">Java FutureTask例子</a>，学习如何使用它。 </p> \n <span id=\"OSC_h3_34\"></span> \n <h3> 7.什么是并发容器的实现？ </h3> \n <p> Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。 </p> \n <p> 并发容器支持并发的遍历和并发的更新。 </p> \n <p> 主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet，阅读这篇文章了解<a href=\"http://www.journaldev.com/378/how-to-avoid-concurrentmodificationexception-when-using-an-iterator\" rel=\"nofollow\">如何避免ConcurrentModificationException</a>。 </p> \n <span id=\"OSC_h3_35\"></span> \n <h3> 8. Executors类是什么？ </h3> \n <p> Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 </p> \n <p> Executors可以用于方便的创建线程池。 </p> \n</div>',NULL,'2020-02-01 17:03:42',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532426190471168',NULL,NULL,' 【转】115个Java面试题和答案——终极列表  ','<div class=\"content\" id=\"articleContent\"> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">本文我们将要讨论Java面试中的各种不同类型的面试题，它们可以让雇主测试应聘者的Java和通用的面向对象编程的能力。下面的章节分为上下两篇，<a href=\"http://www.admin10000.com/document/4285.html\" rel=\"nofollow\">第一篇</a>将要讨论面向对象编程和它的特点，关于Java和它的功能的常见问题，Java的集合类，垃圾收集器，<a href=\"http://www.admin10000.com/document/4286.html\" rel=\"nofollow\">第二篇</a>主要讨论异常处理，Java小应用程序，Swing，JDBC，远程方法调用(RMI)，Servlet和JSP。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　开始！</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　目录</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a href=\"http://www.admin10000.com/document/4285.html#oop\" target=\"_self\" rel=\"nofollow\">面向对象编程（OOP）</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a href=\"http://www.admin10000.com/document/4285.html#general\" target=\"_self\" rel=\"nofollow\">常见的Java问题</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a href=\"http://www.admin10000.com/document/4285.html#thread\" target=\"_self\" rel=\"nofollow\">Java线程</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a href=\"http://www.admin10000.com/document/4285.html#collection\" target=\"_self\" rel=\"nofollow\">Java集合类</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a href=\"http://www.admin10000.com/document/4285.html#gc\" target=\"_self\" rel=\"nofollow\">垃圾收集器</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a name=\"oop\" rel=\"nofollow\"></a><strong>面向对象编程（OOP）</strong></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：</p> \n <ul> \n  <li><p>代码开发模块化，更易维护和修改。</p></li> \n  <li><p>代码复用。</p></li> \n  <li><p>增强代码的可靠性和灵活性。</p></li> \n  <li><p>增加代码的可理解性。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　封装</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　下面列出了使用封装的一些好处：</p> \n <ul> \n  <li><p>通过隐藏对象的属性来保护对象内部的状态。</p></li> \n  <li><p>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</p></li> \n  <li><p>禁止对象之间的不良交互提高模块化。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　参考<a href=\"http://examples.javacodegeeks.com/java-basics/encapsulation-in-java/\" target=\"_blank\" rel=\"nofollow\">这个文档</a>获取更多关于封装的细节和示例。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　多态</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　继承</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　抽象</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　抽象和封装的不同点</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a name=\"general\" rel=\"nofollow\"></a><strong>常见的Java问题</strong></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　2.JDK和JRE的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　4.是否可以在static环境中访问非static变量？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　5.Java支持的数据类型有哪些？什么是自动拆装箱？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java语言支持的8中基本数据类型是：</p> \n <ul> \n  <li><p>byte</p></li> \n  <li><p>short</p></li> \n  <li><p>int</p></li> \n  <li><p>long</p></li> \n  <li><p>float</p></li> \n  <li><p>double</p></li> \n  <li><p>boolean</p></li> \n  <li><p>char</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　6.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　7.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　8.Java支持多继承么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　9.接口和抽象类的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：</p> \n <ul> \n  <li><p>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</p></li> \n  <li><p>类可以实现很多个接口，但是只能继承一个抽象类</p></li> \n  <li><p>类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p></li> \n  <li><p>抽象类可以在不提供接口方法实现的情况下实现接口。</p></li> \n  <li><p>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。</p></li> \n  <li><p>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。</p></li> \n  <li><p>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　也可以参考<a href=\"http://www.javacodegeeks.com/2014/04/abstract-class-versus-interface-in-the-jdk-8-era.html\" target=\"_blank\" rel=\"nofollow\">JDK8中抽象类和接口的区别</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　10.什么是值传递和引用传递？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a name=\"thread\" rel=\"nofollow\"></a><strong>Java线程</strong></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　11.进程和线程的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　12.创建线程有几种不同的方式？你喜欢哪一种？为什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　有三种方式可以用来创建线程：</p> \n <ul> \n  <li><p>继承Thread类</p></li> \n  <li><p>实现Runnable接口</p></li> \n  <li><p>应用程序可以使用Executor框架来创建线程池</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　13.概括的解释下线程的几种可用状态。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　线程在执行过程中，可以处于下面几种状态：</p> \n <ul> \n  <li><p>就绪(Runnable):线程准备运行，不一定立马就能开始执行。</p></li> \n  <li><p>运行中(Running)：进程正在执行线程的代码。</p></li> \n  <li><p>等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。</p></li> \n  <li><p>睡眠中(Sleeping)：线程被强制睡眠。</p></li> \n  <li><p>I/O阻塞(Blocked on I/O)：等待I/O操作完成。</p></li> \n  <li><p>同步阻塞(Blocked on Synchronization)：等待获取锁。</p></li> \n  <li><p>死亡(Dead)：线程完成了执行。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　14.同步方法和同步代码块的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　15.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　16.什么是死锁(deadlock)？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　17.如何确保N个线程可以访问N个资源同时又不导致死锁？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a name=\"collection\" rel=\"nofollow\"></a><strong>Java集合类</strong></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　18.Java集合类框架的基本接口有哪些？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</p> \n <ul> \n  <li><p>Collection：代表一组对象，每一个对象都是它的子元素。</p></li> \n  <li><p>Set：不包含重复元素的Collection。</p></li> \n  <li><p>List：有顺序的collection，并且可以包含重复元素。</p></li> \n  <li><p>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　19.为什么集合类没有实现Cloneable和Serializable接口？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　20.什么是迭代器(Iterator)？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的<br>迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　21.Iterator和ListIterator的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　下面列出了他们的区别：</p> \n <ul> \n  <li><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</p></li> \n  <li><p>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</p></li> \n  <li><p>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　22.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　23.Java中的HashMap的工作原理是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　24.hashCode()和equals()方法的重要性体现在什么地方？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　25.HashMap和Hashtable有什么区别？</p> \n <ul> \n  <li><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</p></li> \n  <li><p>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</p></li> \n  <li><p>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</p></li> \n  <li><p>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。</p></li> \n  <ul> \n   <li><p>一般认为Hashtable是一个遗留的类。</p></li> \n  </ul> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　26.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　下面列出了Array和ArrayList的不同点：</p> \n <ul> \n  <li><p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。</p></li> \n  <li><p>Array大小是固定的，ArrayList的大小是动态变化的。</p></li> \n  <li><p>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。</p></li> \n  <li><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　27.ArrayList和LinkedList有什么区别？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</p> \n <ul> \n  <li><p style=\"margin-top: 10px; padding: 0px;\">ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</p></li> \n  <li><p style=\"margin-top: 10px; padding: 0px;\">相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</p></li> \n  <li><p style=\"margin-top: 10px; padding: 0px;\">LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　也可以参考<a href=\"http://www.javacodegeeks.com/2013/12/arraylist-vs-linkedlist.html\" target=\"_blank\" rel=\"nofollow\">ArrayList vs. LinkedList</a>。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　28.Comparable和Comparator接口是干什么的？列出它们的区别。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　29.什么是Java优先级队列(Priority Queue)？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　30.你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。<br>大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　31.如何权衡是使用无序的数组还是有序的数组？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　32.Java集合类框架的最佳实践有哪些？</p> \n <ul> \n  <li><p>根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。</p></li> \n  <li><p>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。</p></li> \n  <li><p>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。</p></li> \n  <li><p>使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。</p></li> \n  <li><p>编程的时候接口优于实现。</p></li> \n  <li><p>底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。</p></li> \n </ul> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　33.Enumeration接口和Iterator接口的区别有哪些？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　34.HashSet和TreeSet有什么区别？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　<a name=\"gc\" rel=\"nofollow\"></a><strong>垃圾收集器(Garbage Collectors)</strong></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　35.Java中垃圾回收有什么目的？什么时候进行垃圾回收？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　36.System.gc()和Runtime.gc()会做什么事情？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　37.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　38.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　不会，在下一个垃圾回收周期中，这个对象将是可被回收的。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　39.Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　40.串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　41.在Java中，对象什么时候可以被垃圾回收？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　42.JVM的永久代中会发生垃圾回收么？</p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下<a href=\"http://www.javacodegeeks.com/2013/02/java-8-from-permgen-to-metaspace.html\" target=\"_blank\" rel=\"nofollow\">Java8：从永久代到元数据区</a></p> \n <p style=\"margin-top: 10px; padding: 0px; color: rgb(85, 85, 85); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 23.799999237060547px; white-space: normal; background-color: rgb(249, 249, 249);\">　　(译者注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p> \n <p><br></p> \n</div>',NULL,'2020-02-01 17:03:52',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532449624047616',NULL,NULL,' MySQL学习笔记（二） 白银  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1>约束：CONSTRAINTS</h1> \n <p style=\"text-align:justify\"><strong><span style=\"color:#c00000\">数据完整性</span></strong><strong><span style=\"color:blue\">（</span><span style=\"color:blue\">Data Integrity</span></strong><strong><span style=\"color:blue\">）是指</span></strong><strong><span style=\"color:#c00000\">数据的精确性</span></strong><strong><span style=\"color:blue\">（</span><span style=\"color:blue\">Accuracy</span></strong><strong><span style=\"color:blue\">）和</span></strong><strong><span style=\"color:#c00000\">可靠性</span></strong><strong><span style=\"color:blue\">（</span><span style=\"color:blue\">Reliability</span></strong><strong><span style=\"color:blue\">）。它是应</span></strong><strong><span style=\"color:#c00000\">防止</span></strong><strong><span style=\"color:blue\">数据库中存在</span></strong><strong><span style=\"color:#c00000\">不符合语义</span></strong><strong><span style=\"color:blue\">规定的数据和防止因错误信息的输入输出造成</span></strong><strong><span style=\"color:#c00000\">无效</span></strong><strong><span style=\"color:blue\">操作或</span></strong><strong><span style=\"color:#c00000\">错误</span></strong><strong><span style=\"color:blue\">信息而提出的。</span></strong>数据的完整性要从以下四个方面考虑：</p> \n <ol> \n  <li>实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录</li> \n  <li>域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女”</li> \n  <li>引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门</li> \n  <li>用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li> \n </ol> \n <p style=\"text-align:justify\">根据约束的特点，分为几种：</p> \n <ul> \n  <li>键约束：主键约束、外键约束、唯一键约束</li> \n  <li>Not NULL约束：非空约束</li> \n  <li>Check约束：检查约束</li> \n  <li>Default约束：缺省约束</li> \n </ul> \n <span id=\"OSC_h2_2\"></span> \n <h2>主键约束PRIMARY KEY</h2> \n <p>主键：Primary key，简称PK，数据库主键作用保证实体的完整性，可以是一个列或多列的组合。</p> \n <ul> \n  <li>主键约束相当于<strong><span style=\"color:red\">唯一约束</span></strong><strong><span style=\"color:red\">+</span></strong><strong><span style=\"color:red\">非空约束</span></strong>的组合，主键约束列不允许重复，也不允许出现空值，如果是多列组合的主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li> \n  <li><strong><span style=\"color:red\">每个表有且最多只允许一个主键约束</span></strong>。</li> \n  <li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li> \n </ul> \n <p>当创建主键约束时，MySQL默认在对应的列上建立<strong><span style=\"color:red\">主键索引</span></strong>。删除主键时，也会直接删除主键索引。</p> \n <pre><code class=\"language-sql\">//直接添加主键\r\nCREATE TABLE t_stu(\r\n	sid INT PRIMARY KEY,\r\n	sname VARCHAR(100),\r\n	gender CHAR\r\n);\r\n\r\n//单独声明主键\r\nCREATE TABLE t_course(\r\n	cid INT ,\r\n	cname VARCHAR(100),\r\n	decription VARCHAR(200),\r\n	PRIMARY KEY(cid)\r\n);\r\n\r\n//建表后添加主键\r\nALTER TABLE t_stu ADD PRIMARY KEY(sid);\r\n\r\n\r\n//删除主键\r\nalter table表名称 drop primary key;</code></pre> \n <span id=\"OSC_h2_3\"></span> \n <h2>唯一键Unique key，简称UK</h2> \n <ul> \n  <li>同一个表可以有多个唯一约束。</li> \n  <li>唯一约束可以是某一个列的值唯一，也可以多个列组合值的唯一。</li> \n  <li>MySQL会给唯一约束的列上默认创建一个<strong><span style=\"color:red\">唯一索引</span></strong>。</li> \n  <li>删除唯一键只能通过删除唯一索引的方式删除，删除时需要指定唯一索引名，唯一索引名就是唯一约束名一样。</li> \n </ul> \n <pre><code class=\"language-sql\">--在某一列后面直接添加唯一性约束\r\nCREATE TABLE t_course(\r\n	cid INT PRIMARY KEY,\r\n	cname VARCHAR(100) UNIQUE,\r\n	description VARCHAR(200)\r\n);\r\n--单独指定表的唯一性约束\r\nCREATE TABLE t_stu(\r\n	sid INT PRIMARY KEY,\r\n	sname VARCHAR(100),\r\n	card_id CHAR(18),\r\n	CONSTRAINT uk_card_id UNIQUE KEY(card_id)\r\n);\r\n--在建表后修改表结构：\r\nalter table 【数据库名.】表名称 add unique key(字段名);\r\nalter table 【数据库名.】表名称 add unique key(字段列表);  #复合唯一\r\n\r\n--删除唯一键\r\nalter table 【数据库名.】表名称 drop index 索引名;\r\nalter table emp drop index cardid;</code></pre> \n <p>如果不知道索引名，可以通过如下的语句查询：<br> show index from 表名称;</p> \n <p>唯一键和主键的区别：<br> （1）主键不能为空，唯一键可以为空<br> （2）主键约束，一个表只能有一个，而唯一键可以有很多个</p> \n <span id=\"OSC_h2_4\"></span> \n <h2>外键：Foreign key，简称FK</h2> \n <p>外键约束不是必须的，而且现在很多大的公司，数据量比较大时，不建议在数据库层面设计外键，<br> 因为他觉得这样效率低，把这个数据的约束挪到代码层面去判断。</p> \n <p>特点：<br> （1）约束的是两张表的关系<br> &nbsp;&nbsp; &nbsp;需要两张表，或者一张表虚拟成两张表<br> （2）两张表分为主表（父表）和从表（子表）<br> &nbsp; &nbsp; 外键的建立/指定是在子表上建立。&nbsp;&nbsp; &nbsp;<br> （3）被参考的表称为主表，主表的被参考列必须是主键或唯一键&nbsp;&nbsp; &nbsp;<br> （4）一个表可以有多个外键</p> \n <ul> \n  <li><strong>添加/修改从表记录时，引用主表的列的值必须是存在的。</strong></li> \n  <li><strong>默认情况下，如果主表的被参考列的值被引用，那么就不能轻易的被删除和修改。</strong></li> \n </ul> \n <pre><code class=\"language-sql\">--先建主表，再建从表\r\ncreate table emp(\r\n字段1 数据类型  primary key,\r\n字段2 数据类型 【unique key】【not null】【default 默认值】,\r\nforeign key(从表的外键列) references 主表名(主表被参考的列名)\r\n);\r\n\r\n\r\n\r\n--建表后指定外键\r\nalter table 从表名称 add foreign key(从表的字段) references 主表名(主表被参考的列名);\r\n\r\n</code></pre> \n <span id=\"OSC_h2_5\"></span> \n <h2>非空和默认值约束</h2> \n <ul> \n  <li>NOT NULL 非空约束，规定某个字段不能为空</li> \n </ul> \n <ul> \n  <li> <p style=\"text-align:justify\">default：默认值，在插入数据时某列如果没指定其他的值,那么会将默认值添加到新记录。</p> </li> \n </ul> \n <pre><code class=\"language-sql\">\r\n\r\n--建表\r\ncreate table 【数据库名.】表名称(\r\n	字段1 数据类型 primary key,\r\n	字段2 数据类型 【unique key】【not null】【default 默认值】,\r\n	字段2 数据类型 【unique key】【not null】【default 默认值】,\r\n	...\r\n);\r\n--实例\r\ncreate table emp(\r\n	eid int primary key,  #员工编号\r\n	ename varchar(20) not null,   #姓名\r\n	cardid varchar(18)  unique key not null ,		#身份证号\r\n	tel varchar(11) unique key not null,\r\n	gender char not null default \'男\'\r\n);\r\n\r\n--修改\r\nalter table 表名 modify 列名 数据类型 【unique key】 【not null】 ;\r\n\r\nalter table emp modify cardid varchar(18) unique key  not null;\r\nalter table emp modify tel varchar(11)   not null;\r\nalter table emp modify gender char not null default \'男\';\r\n\r\n--去掉非空和默认值约束\r\n\r\nalter table emp modify gender char ;</code></pre> \n <span id=\"OSC_h2_6\"></span> \n <h2>自增列：AUTO_INCREMENT</h2> \n <p>关键字：auto_increment</p> \n <p>特点：</p> \n <ul> \n  <li>（1）一个表只能有一个自增列</li> \n  <li>（2）自增列必须是整型的</li> \n  <li>（3）自增列必须是键列，例如：主键，唯一键</li> \n </ul> \n <pre><code class=\"language-sql\">create table emp(\r\n	eid int primary key auto_increment,\r\n	ename varchar(20) not null\r\n);</code></pre> \n <p>&nbsp;</p> \n</div>',NULL,'2020-02-01 17:04:00',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532473204424704',NULL,NULL,' Mybatis 学习笔记三 搭配pageHelper分页插件使用  ','<div class=\"content\" id=\"articleContent\"> \n <h1>Mybatis 学习笔记三 搭配pageHelper分页插件使用</h1> \n <p>基于《<a href=\"https://my.oschina.net/mengzhang6/blog/2877178\">Mybatis 学习笔记二 与spring搭配</a>》</p> \n <h2>maven依赖</h2> \n <pre><code>        &lt;dependency&gt;\n            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;\n            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;\n            &lt;version&gt;5.1.6&lt;/version&gt;\n        &lt;/dependency&gt;\n\n</code></pre> \n <h2>配置</h2> \n <h3>mybatis配置</h3> \n <p>conf.xml</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n\n&lt;/configuration&gt;\n</code></pre> \n <p>注意：保持基本配置即可；</p> \n <h3>spring配置</h3> \n <p>applicationContext.xml</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt;\n\n    &lt;!--\n    driver=com.mysql.jdbc.Driver\n    url=jdbc:mysql://127.0.0.1:3306/mybatis\n    username=root\n    password=root\n    --&gt;\n    &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt;\n        &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt;\n        &lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis\"/&gt;\n        &lt;property name=\"username\" value=\"root\"/&gt;\n        &lt;property name=\"password\" value=\"root\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- MyBatis配置 --&gt;\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n        &lt;property name=\"configLocation\" value=\"classpath:conf.xml\"/&gt;\n        &lt;property name=\"mapperLocations\" value=\"classpath:mapper/**/*Mapper.xml\"/&gt;\n        &lt;property name=\"plugins\"&gt;\n            &lt;array&gt;\n                &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt;\n                    &lt;property name=\"properties\"&gt;\n                        &lt;value&gt;\n                            helperDialect=mysql\n                        &lt;/value&gt;\n                    &lt;/property&gt;\n                &lt;/bean&gt;\n            &lt;/array&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n        &lt;!--UserMapper接口所在位置--&gt;\n        &lt;property name=\"basePackage\" value=\"meng.mybatis.test\"/&gt;\n        &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre> \n <h3>mapper配置</h3> \n <p>userMapper.xml</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;!-- 命名空间 --&gt;\n&lt;mapper namespace=\"meng.mybatis.test.UserMapper\"&gt;\n    &lt;!-- resultType可以定义简称 --&gt;\n    &lt;select id=\"findUserByUserid\" parameterType=\"int\" resultType=\"meng.mybatis.test.User\"&gt;\n		select * from users where id = #{id}\n	&lt;/select&gt;\n\n    &lt;select id=\"findUsers\" resultType=\"meng.mybatis.test.User\"&gt;\n		select * from users\n	&lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre> \n <p>meng.mybatis.test.UserMapper类</p> \n <pre><code>public interface UserMapper {\n    List&lt;User&gt; findUsers();\n\n    User findUserByUserid(int id);\n}\n</code></pre> \n <h2>测试</h2> \n <pre><code>        ApplicationContext context = \n            new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\");\n\n        UserMapper userMapper = context.getBean(UserMapper.class);\n\n        // 第三页 每页5条\n        PageHelper.startPage(3, 5);\n\n        // 从下标为3的开始 每页5条\n        //PageHelper.offsetPage(3, 5);\n\n        PageInfo pageInfo = new PageInfo(userMapper.findUsers());\n        System.out.println(pageInfo);\n</code></pre> \n <h2>源码</h2> \n <ul> \n  <li><a href=\"https://github.com/mengzhang6/mybatis-demo/tree/mybatis-spring\">sample github地址</a></li> \n  <li><a href=\"https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md\">官方资料</a></li> \n </ul> \n</div>',NULL,'2020-02-01 17:04:08',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532505957744640',NULL,NULL,' 读《PHP和MySQL Web开发》  ','<div class=\"content\" id=\"articleContent\"> \n <p> 【第一部分】PHP基础与入门 </p> \n <p> 1、PHP学习笔记1：基础知识快速浏览 </p> \n <div> \n  <a href=\"http://my.oschina.net/bluefly/blog/472673\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/472673</a> \n </div> \n <div> \n  <br> \n </div> \n <div>\n   2、PHP学习笔记2：文件 \n </div> \n <p> <a href=\"http://my.oschina.net/bluefly/blog/477601\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/477601</a> </p> \n <p> 3、PHP学习笔记3：数组 </p> \n <p> <span style=\"line-height:1.5;\"><a href=\"http://my.oschina.net/bluefly/blog/519014\" target=\"_blank\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/519014</a></span> </p> \n <p> 4、PHP学习笔记4：字符串与正则 </p> \n <p> <a href=\"http://my.oschina.net/bluefly/blog/519015\" target=\"_blank\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/519015</a> </p> \n <p> 5、<span>PHP学习笔记5：代码重用和函数</span> </p> \n <p> <span><a href=\"http://my.oschina.net/bluefly/blog/521109\" target=\"_blank\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/521109</a><br> </span> </p> \n <p> 6、PHP学习笔记6：面向对象的PHP </p> \n <p> <a href=\"http://my.oschina.net/bluefly/blog/522354\" target=\"_blank\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/522354</a> </p> \n <p> 7、PHP学习笔记7：错误和异常处理 </p> \n <p> <a href=\"http://my.oschina.net/bluefly/blog/522358\" target=\"_blank\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/522358</a> </p> \n <p> <br> </p> \n <p> <br> </p> \n <p> 【第二部分】使用MySQL </p> \n <p> 8、PHP和MySQL学习笔记8：重要概念与设计Web数据库 </p> \n <p> <a href=\"http://my.oschina.net/bluefly/blog/532934\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/532934</a> </p> \n <p> <span>9、PHP和MySQL学习笔记9：创建Web数据库</span> </p> \n <p> <span><a href=\"http://my.oschina.net/bluefly/blog/620323\" target=\"_blank\" rel=\"nofollow\">http://my.oschina.net/bluefly/blog/620323</a><br> </span> </p> \n</div>',NULL,'2020-02-01 17:04:16',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532545308704768',NULL,NULL,' Android快速开发框架-ZBLibrary 源码分享    ','<div class=\"content\" id=\"articleContent\"> \n <p>坐标标准库ZBLibrary，是一个MVP架构的Android快速开发框架，提供一套开发标准（View,Data,Event）以及模板和工具类并规范代码。 封装层级少，简单高效兼容性好。Android Studio、Eclipse多平台支持。</p> \n <p>OKHttp、UIL图片加载、ZXing二维码、沉浸状态栏、下载安装、自动缓存以及各种Base、Demo、UI、Util直接用。</p> \n <p>全新的手势，侧滑返回、全局右滑返回都OUT啦！</p> \n <p>BaseHttpListActivity，几行代码搞定http请求列表 加载和缓存;</p> \n <p>BaseView，自定义View竟然如此简单;</p> \n <p>万能的Entry，两个变量的Model/JavaBean再也不用写了;</p> \n <p>100多个常用style，一行搞定View属性，一键统一配置UI...</p> \n <p>&nbsp;</p> \n <p><strong>丰富的功能</strong></p> \n <p><strong><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110906_5081.jpg\"></strong></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110906_ig9M.png\"></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110906_oSZs.jpg\"></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110906_kUm6.jpg\"><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110907_aQms.jpg\"></p> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n <p><strong>简单的实现</strong></p> \n <p>&nbsp;<img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110907_hJNn.jpg\"></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110907_50I7.jpg\"><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110907_JTDK.jpg\"></p> \n <p>&nbsp;</p> \n <p><strong>详细的注释</strong></p> \n <p>&nbsp;<img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110907_xlfP.jpg\"></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110908_LPak.jpg\"><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110908_nQVX.jpg\"><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110908_OuPg.jpg\"></p> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n <p><strong>规范的风格</strong></p> \n <p>&nbsp;<img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110908_ryRF.jpg\"></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110908_JGSf.jpg\"><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110908_k72s.jpg\"></p> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201607/25110909_z0R0.jpg\"></p> \n <p>&nbsp;</p> \n <p><strong>下载地址（欢迎Star，欢迎Fork）</strong></p> \n <p>​<a href=\"https://github.com/TommyLemon/Android-ZBLibrary\" target=\"_blank\" rel=\"nofollow\">https://github.com/TommyLemon/Android-ZBLibrary</a></p> \n <p><strong>下载试用</strong></p> \n <p><a href=\"http://files.cnblogs.com/files/tommylemon/ZBLibraryDemoApp.apk\" rel=\"nofollow\">ZBLibraryDemoApp.apk</a></p> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n</div>',NULL,'2020-02-01 17:04:26',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532569249792000',NULL,NULL,' 开源项目中如何同时支持Git@OSC和Github   ','<div class=\"content\" id=\"articleContent\"> \n <p><span style=\"font-size: 20px;\">我的开源项目托管在Github，同时在Git@OSC也有备份，有两个地方，是不是很麻烦呢？非也非也，下面介绍一下我是怎么做的。</span></p> \n <p><span style=\"font-size: 20px;\">1、先在Github新建一个项目，点击Github主页右上角的加号 -&gt; New Repository，接着输入Repository name：jsearch，最后点击页面最下面的Create repository按钮，搞定。</span></p> \n <p><span style=\"font-size: 20px;\">2、接着我们在本地检出刚在Github新建的项目，我们切换到本地机器的工作目录，然后执行命令：</span></p> \n <pre class=\"brush:shell;toolbar: true; auto-links: false;\"><code>git&nbsp;clone&nbsp;https://github.com/ysc/jsearch.git</code></pre> \n <p><span style=\"font-size: 20px; line-height: 22.5px;\">3、下面点击<span style=\"font-size: 20px; line-height: 22.5px;\">Git@OSC主页<span style=\"font-size: 20px; line-height: 22.5px;\">右上角的加号 -&gt;&nbsp;Github导入，选择项目jsearch上面的导入按钮即可。</span></span></span></p> \n <p><span style=\"font-size: 20px; line-height: 22.5px;\"><span style=\"font-size: 20px; line-height: 22.5px;\"><span style=\"font-size: 20px; line-height: 22.5px;\">4、在本地切换到jsearch目录，执行命令：</span></span></span></p> \n <pre class=\"brush:shell;toolbar: true; auto-links: false;\"><code>git&nbsp;remote&nbsp;add&nbsp;origin2&nbsp;https://git.oschina.net/ysc/jsearch.git</code></pre> \n <p><span style=\"font-size: 20px;\">5、为项目添加</span><span style=\"font-size: 20px;\">LICENSE.txt和</span><span style=\"font-size: 20px;\">README.md，执行git commit命令提交代码：</span><br></p> \n <pre class=\"brush:shell;toolbar: true; auto-links: false;\"><code>git&nbsp;add&nbsp;LICENSE.txt\ngit&nbsp;commit&nbsp;-m&nbsp;\"采用GNU&nbsp;GENERAL&nbsp;PUBLIC&nbsp;LICENSE,&nbsp;Version&nbsp;3作为开源协议\"&nbsp;LICENSE.txt\ngit&nbsp;add&nbsp;README.md\ngit&nbsp;commit&nbsp;-m&nbsp;\"jsearch是一个高性能的全文检索工具包\"&nbsp;README.md</code></pre> \n <p><span style=\"font-size: 20px; line-height: 22.5px;\"><span style=\"font-size: 20px; line-height: 22.5px;\">6、新建一个脚本文件p，内容为：</span></span></p> \n <pre class=\"brush:shell;toolbar: true; auto-links: false;\"><code>git&nbsp;push&nbsp;origin&nbsp;master\ngit&nbsp;push&nbsp;origin2&nbsp;master</code></pre> \n <p><span style=\"font-size: 20px;\">7、将提交的代码同时推送到</span><span style=\"font-size: 20px;\">Git@OSC和Github，执行命令：</span><br></p> \n <pre class=\"brush:shell;toolbar: true; auto-links: false;\"><code>chmod&nbsp;+x&nbsp;p&nbsp;&amp;&nbsp;p</code></pre> \n <p><span style=\"font-size: 20px; line-height: 22.5px;\">好了，以后推送代码只需要执行p命令即可，不用区分Git@OSC和Github了。</span></p> \n</div>',NULL,'2020-02-01 17:04:31',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532598165323776',NULL,NULL,' 究竟啥才是互联网架构“高可用”  ','<div class=\"content\" id=\"articleContent\"> \n <p>原创&nbsp;<em>2016-12-05</em>&nbsp;<em>58沈剑</em>&nbsp;<a rel=\"nofollow\">架构师之路</a></p> \n <p>&nbsp;<strong>一、什么是高可用</strong></p> \n <p><strong>高可用HA</strong><strong>（</strong>High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p> \n <p>假设系统一直能够提供服务，我们说系统的可用性是100%。</p> \n <p>如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。</p> \n <p>很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。</p> \n <p>百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度HA最高的褒奖。</p> \n <p>&nbsp;</p> \n <p><strong>二、如何保障系统的高可用</strong></p> \n <p>我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。</p> \n <p><strong>保证系统高可用，架构设计的核心准则是：冗余。</strong></p> \n <p>有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。</p> \n <p>接下来我们看下典型互联网架构中，如何通过<strong>冗余+自动故障转移</strong>来保证系统的高可用特性。</p> \n <p>&nbsp;</p> \n <p><strong>三、常见的互联网分层架构</strong></p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfG8PWEuTHibe1esjn7luyCtazdzwCtVOXooa4qzVqkEbLADEnJ7vaJqRQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 常见互联网分布式架构如上，分为：</p> \n <p>（1）<strong>客户端层</strong>：典型调用方是浏览器browser或者手机应用APP</p> \n <p>（2）<strong>反向代理层</strong>：系统入口，反向代理</p> \n <p>（3）<strong>站点应用层</strong>：实现核心应用逻辑，返回html或者json</p> \n <p>（4）<strong>服务层</strong>：如果实现了服务化，就有这一层</p> \n <p>（5）<strong>数据</strong><strong>-</strong><strong>缓存层</strong>：缓存加速访问存储</p> \n <p>（6）<strong>数据</strong><strong>-</strong><strong>数据库层</strong>：数据库固化数据存储</p> \n <p>整个系统的高可用，又是通过每一层的<strong>冗余</strong><strong>+</strong><strong>自动故障转移</strong>来综合实现的。</p> \n <p>&nbsp;</p> \n <p><strong>四、分层高可用架构实践</strong></p> \n <p><strong>【客户端层-&gt;</strong><strong>反向代理层】的高可用</strong></p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGW76dBwjO10j7aKNOz3gud6smtCGczwsLhoe6KAOsGEL68dfqczVtMQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 【客户端层】到【反向代理层】的<strong>高可用</strong>，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGasDdhCicBUbqDEgaibkRmD6jOUlziaCcSpm9Fm16mncWibPjZN1bdNvUhw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>自动故障转移</strong>：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p> \n <p>&nbsp;</p> \n <p><strong>【反向代理层-&gt;</strong><strong>站点层】的高可用</strong></p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGxZwNZAVYBYMZ0kx5CL8Xd5licNL0LRaNhr6P1wOu7WmJgqSOsciaicHow/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 【反向代理层】到【站点层】的<strong>高可用</strong>，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGMchdES6v0NmZckrIh9LYU6PkcA7KIokib55FcwgMN4iajr2gMbJWic7jQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>自动故障转移</strong>：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。</p> \n <p>&nbsp;</p> \n <p><strong>【站点层-&gt;</strong><strong>服务层】的高可用</strong></p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfG1iaQwN54JCv5RYC21LlD83CFDxJbicLv9TJGGbeG9E6BicdZs9NPI610Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 【站点层】到【服务层】的<strong>高可用</strong>，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGcrpCknA0M0eXVk9HjnHWA0OKSK1nWMHTjq7ocmYT5MWLq9VRluowgg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>自动故障转移</strong>：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。</p> \n <p>&nbsp;</p> \n <p><strong>【服务层&gt;</strong><strong>缓存层】的高可用</strong></p> \n <p><img height=\"1\" src=\"https://static.oschina.net/uploads/space/2016/1206/100316_Do0I_222931.png\" width=\"1\"><br> 【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。</p> \n <p>缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGaaRmZHrjuhjicWbicibDOrsjjHvsE85JiaiciaTur2ggCY96OPQkyvZyXicbg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 缓存层也可以通过支持主从同步的缓存集群来解决缓存层的<strong>高可用</strong>问题。</p> \n <p>以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGdiaPuQmUGr1JqaQ4MsPibP8UjzlXibaVIk6W9oSDFVcmK31ibGTibPF6dicw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>自动故障转移</strong>：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。</p> \n <p>&nbsp;</p> \n <p>说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。</p> \n <p>这类允许“cache miss”的业务场景，缓存架构的建议是：</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfG6ibqmZXiclFlLAz7KcHt0iaKNOkoib7eYkJLxIKia4YicoI2ZaZN2Ts2cUWw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGmGgPtUdTY7MTwVicS3kBMWcvdMCGrZeJM8ibk3cV7TY5R9BXic1pP59LQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>缓存实例挂了屏蔽</strong>：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。</p> \n <p>&nbsp;</p> \n <p><strong>【服务层&gt;</strong><strong>数据库层】的高可用</strong></p> \n <p>大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。</p> \n <p>&nbsp;</p> \n <p><strong>【服务层&gt;</strong><strong>数据库层“读”】的高可用</strong></p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGvlyLhdDQprCwKM09642AvxZUzvZxRbLg3vwtAeeSNQ2kVhs1eA1SrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 【服务层】到【数据库读】的<strong>高可用</strong>，是通过读库的冗余来实现的。</p> \n <p>既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGR4X9glYtU23ThQ251I6Xb6hHDLASbYzlupexhhjmjAf8ib8NnNibvu8g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>自动故障转移</strong>：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。</p> \n <p>&nbsp;</p> \n <p><strong>【服务层&gt;</strong><strong>数据库层“写”】的高可用</strong></p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfGEEupewicyaRavGSO1GbNbe8h78g7jOwnuAbHWKJSsNZCAWMZeqia4dZw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> 【服务层】到【数据库写】的<strong>高可用</strong>，是通过写库的冗余来实现的。</p> \n <p>以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOxZeXfbW7Kckceh9CscyyfG9tWoA9eLB2pUeBkeq7VS3BneDkfbZoxGqibeDud4YslUl53dInkNMjw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\"><br> <strong>自动故障转移</strong>：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p> \n <p>&nbsp;</p> \n <p><strong>五、总结</strong></p> \n <p>高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p> \n <p>方法论上，高可用是通过<strong>冗余</strong><strong>+</strong><strong>自动故障转移</strong>来实现的。</p> \n <p>整个互联网分层系统架构的高可用，又是通过每一层的<strong>冗余</strong><strong>+</strong><strong>自动故障转移</strong>来综合实现的，具体的：</p> \n <p>（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p> \n <p>（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移</p> \n <p>（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移</p> \n <p>（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性</p> \n <p>（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移</p> \n <p>（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p> \n <p>&nbsp;</p> \n <p>末了，希望文章的思路是清晰的，希望大家对高可用的概念和实践有个系统的认识，感谢大家。</p> \n <p>==【完】==</p> \n</div>',NULL,'2020-02-01 17:04:38',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532621259161600',NULL,NULL,' 专访携程李亚锋：大数据技术融合下的Spark更具魅力  ','<div class=\"content\" id=\"articleContent\"> \n <p>“大数据”作为当下最火热的IT行业词汇，在主流的数据处理工具当中hadoop和Spark都被大家所熟悉。不过，目前基于内存计算的Spark适合各种迭代算法和交互式数据分析，能够提升大数据处理的实时性和准确性，已经逐渐获得很多企业的支持。这是否意味着我们应该彻底抛弃Hadoop？在前不久的北京Spark亚太峰会上 ，记者有机会专访到携程大数据平台高级经理李亚锋，为大家分享如何通过Spark与Hadoop大数据技术间的融合，实现优势互补，引导企业发现用户的潜在需求。<br> <br> <br> 李亚锋，携程大数据平台高级经理，负责大数据底层平台的运营和开发。2002年起一直专注于IT互联网领域，从事过网络会议、IPTV、安全网关、游戏架构、搜索引擎、推荐引擎等，主要偏后台架构和底层开发。加入携程后，开始转向大数据领域。<br> <br> 以下为51CTO记者对李亚锋老师的专访录音整理<br> 您在携程主要负责什么工作？目前我们大数据的应用情况和规模是怎么样的？<br> 目前我是携程DI（Data infrastructure）团队高级经理，主要负责大数据底层平台的运营和开发。我2002年毕业后一直在IT互联网的领域工作，加入携程之后，转向大数据领域。我们从4个节点的hadoop集群做起，目前达到200个节点的规模，数据达3PB，每天job数3万以上，每天数据增量40TB，有力支持了携程大数据相关业务的发展。<br> <br> 大数据对我们公司业务的支持作用非常大，包括海量日志和metrics处理、推荐引擎、爬虫、用户行为日志分析、BI报表、风控、搜索引擎、机器学习、监控报警等都使用到大数据技术。<br> <br> 目前DI团队有多少人？<br> 包括我在内，总共6人。<br> <br> 咱们现在团队里有六个人，成员不是很多，团队的分工情况大致是什么状况？<br> 携程的业务线比较长，部门比较多，相对于我们要支持的业务部门和数据规模来说，DI团队人手确实偏紧。我们采用了一种比较新的工作方式，就是DevOps（开发运维），用来提高整个团队的效率。团队成员既做开发又做运维，把运维的工作化解掉。我们要求团队成员除了能解决生产环境出现的各种问题外，还能修复bug，开发工具，并且为社区贡献代码。这样对团队成员的能力要求比较高，这方面的人才也比较紧缺。<br> <br> 携程大数据平台正在快速发展中，我们希望有志之士加盟，大家一起成长。<br> <br> 作为专门做在线旅游服务的公司，大数据给携程的业务带来什么转变呢？<br> 用户到携程的平台，一般都有一个比较明确的消费目的，但并不等于说他没有个性化方面的需求。这些个性化的需求在传统的小数据时代是不能满足的。当我们积累到足够的用户数据，大数据技术就能分析出用户的喜好与购买习惯，得出的结果有时甚至比用户自己还要了解自己。通过对数据的分析，了解用户的行为特征，以及他们对服务的期待，然后利用这些数据，我们就可以对用户做到精准细分，有针对性地对用户提供个性化服务和推荐，从而使用户得到更好的服务体验。<br> <br> 携程业务正在从PC端往移动端转型，目前大概有一半的业务是在移动端完成的，应该说这个转型还是非常成功的。移动端的用户行为数据会远大于PC端，这对我们来说是一个挑战，同时也是一个机会。<br> <br> 作为OTA（在线旅游服务商）的龙头，携程在这个行业深耕十多年，有非常庞大的交易数据和用户数据，这是我们一个非常大的优势。利用这些庞大的历史数据，加上我们的品牌优势，在大数据方向进行突破，加大投入和研发，未来肯定会产生很多意想不到的成果。<br> <br> 总而言之，利用大数据技术可以帮助公司明确市场定位，分析用户行为，发现潜在需求，进行趋势预测，营销创新，智能决策等等。<br> <br> 在使用Spark之前，我们还用过什么大数据的处理方法？<br> 以前使用Hadoop/HBase，现在我们还在用。目前我们是把Spark和Hadoop/HBase结合起来在用。<br> <br> 我个人认为，实时性要求不高的，传统的MapReduce还是可以的。第一它技术很成熟，第二它比较稳定，缺点就是慢一点，其他没什么。另外，存储那块现在HDFS还是不可能取代的，高容错，高吞吐，分布式，也很稳定。还有实时读写方面，HBase也不会被spark取代。我认为底层存储还是要用Hadoop/HBase。<br> <br> 随着技术的不断发展，我们的选择更多了，选择也更趋于理性，关键是要看你的需求是什么。如果两边都差不多，那我们选择一个稳定的。比方说这个job跑一小时能接受，跑两个小时也能接受，但我们要求稳定，肯定用MapReduce更合适。如果只是单纯考虑效率，肯定是选择一个执行速度快的系统。原来是没有选择，只能通过各种手段优化，但是这个治标不治本，因为它受框架限制，性能不可能提升很多倍。现在有像Spark这样更好的分布式计算引擎出来了，能够数倍的提高效率。那么我们的考虑是，对延迟要求比较高的job，可以考虑挪一部分出来放在spark引擎计算；延迟要求不高的，还是放在传统的mapreduce引擎计算。这两个并不矛盾，关键还是要看哪个更适合你的需求。<br> <br> 对Spark来说，最大的优势在于速度，那这个速度是怎么实现的呢？它相当于是用空间换时间，所以它耗资源，占内存。从运营的角度看，它的成本会比MapReduce要高。spark在资源管理这块目前还不够成熟，但这都是发展中的问题，以后应该会解决。从整个架构来讲，我认为Spark和Hadoop两个应该是互补，并不是说完全排斥、对立的。<br> <br> 您认为Spark以后会代替Hadoop吗？<br> 我觉得是不太可能代替。因为Hadoop毕竟被很多大公司验证过，是没有问题的，它肯定是可用的东西。Spark有很多的做法也是参考Hadoop来实现的。现在Spark还在推广阶段，还没有被大规模的使用。我认为Hadoop的地位未来会降一点，这个是肯定的，但是它不会消失，不可能被Spark取代。<br> <br> Spark基于内存上面进行计算，像您说相当于“空间换时间”，我们会不会考虑它会造成我们资源的浪费？<br> <br> Spark里面分了几大块，第一块叫Spark SQL，可以部分取代Hadoop hive；第二个是机器学习MLLib，可以取代mahout；第三个是图计算GraphX，可以取代Pregel；第四块是流式计算spark streaming，可以取代storm。每一块解决不同的问题，不同的模块可以有不同的集群，它可以独立扩容。<br> <br> Spark对资源是有一定的浪费，但浪费也是相对的，要看你使用的频率高不高。如果这个集群很繁忙，经常不断地有人提交工作，RDD重用率很高，那就不是浪费。这就好比建了个大房子，如果一年只住一次，那其实很浪费。如果这个房子住了很多人，而且天天住，那就不浪费。<br> <br> 您觉得在整个行业来看，目前spark发展的是什么样？我们在这块儿有什么优势呢？<br> 我个人的感觉，spark现在已经是逐步走向生产环节，开始真正投入使用了，但是大规模的使用还是不太多。横向比较的话，我们携程应该是走在前面的，我们是真正在用了，很多公司还在尝试使用阶段，有的在测试阶段，还没有真正地在生产环境大规模使用。大家可能认为这个技术还不是非常成熟，从商业角度来讲投入到项目中还是有一定的风险。任何新技术都会有风险，这个是很正常的。但只要在驾驭范围之内，风险还是可以控制的。<br> <br> 整体来看，大家对这个东西比较期待，发展势头很猛，但目前还是比较谨慎。<br> <br> 现在的数据规模增长的这么厉害，数量大，种类多，我们怎么对它进行具体地分析挖掘，来为业务创造价值的？<br> 现在是移动互联网时代，移动互联网时代一个突出的问题是有很多用户数据。PC不便携带和移动，传统手机操作不方便、应用少，智能手机通过APP和触摸屏彻底解决了交互性和易用性问题，从而导致产生更多的用户行为数据。数据增长速度会远远超过业务增长速度，比如携程2014年的大数据增长了6倍，但是业务并没有增长6倍，两者并非1：1关系。<br> <br> 数据大量增加有两个原因：<br> 1）用户的行为确实变多了，因为应用越来越多，操作也越来越便捷。<br> <br> 2）大家尝到了大数据的甜头了，然后就会到处埋点，到处收集数据。这样一来，原来认为没用的数据，现在就变成有用的数据，自然而然数据就多了。<br> <br> 数据规模肯定是爆炸式增长，所有行业趋势都是这样。如果某一天我们换一种角度来思考当下发生的问题，原来可能觉得没有价值的数据，可能一下子变得很有价值。前提是有历史数据，否则无法进行分析。<br> <br> 现在很多公司提倡量化管理，或者说数字化管理。量化管理的前提是要有数据，所有的行为和现象都要数字化。所有的决策必须基于事实，数据就是事实，因为数据是不会说假话（尽管存在数据噪音和数据质量问题，但这些可以通过技术手段处理掉）。也许有些数据不一定有用，但是它不会说假话。这样一来就产生了各种各样的数据，全部收集起来，量就非常大。像我们携程每天量化指标数据四百多亿个条，如果放在传统的数据库，而且要实时读写/查询，传统的技术很难实现。我们是通过HBase来处理，可以做到实时读写海量metrics。很多东西在过去认为不可能的，现在变成可能，或者已经做到了，所以大数据整个发展前景还是不错的。<br> <br> 现在在大数据里面有没有其他的技术是您现在还想比较多关注的，还正在研究的，有这样的技术吗？如何做技术选择？<br> 除了HDFS/HBase/mapreduce/hive/spark/storm之外，我们还关注presto。Presto是facebook新发布的产品，与spark sql类似，主要解决hive查询慢的问题。<br> <br> 对下一代大数据处理技术，比如Caffeine、Pregel、Dremel，我们也在关注和跟进相关产品或项目。<br> <br> 我的个人观点是，做技术选择的时候，选择A而不选择B的原因，并不是说A就一定比B好，而是因为它是一个系统，是一个完整的东西。如果形成了一个生态圈的话，那么它有很多东西在内部可以消化掉，不用一会儿跟这个系统做接口，一会儿跟那个系统做接口，数据都在同一个系统内部流动。如果是自成一体，有时一个问题解决了，可能导致三个问题一起解决。如果是三个独立系统，同一个问题可能需要在三个系统分别去解决，效率会低不少。<br> <br> 对于分布式系统而言，扩展性和伸缩性一般都不是问题，all in one系统运营成本更低。比如spark可以同时解决多个问题，无需部署多套不同系统，而storm只解决流式计算问题，因此我个人更偏向spark。<br> - 原文地址：http://www.bi168.cn/&gt;&gt;http://www.bi168.cn/thread-4792-1-1.html</p> \n</div>',NULL,'2020-02-01 17:04:44',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223532646638895104',NULL,NULL,' 那些年，UI设计师还在手工标注和切图时走的弯路  ','<div class=\"content\" id=\"articleContent\"> \n <p>在我从事UI设计师这几年的工作中逐渐发现，最让人糟心的不是应付各种奇葩的需求，完成设计稿，而是交付。每次交付的设计稿和最后开发出来的产品总是让我心塞无比，很少最终产品和我的设计稿是完全一致的。</p> \n <p><strong>UI设计师对接产品经理是个问题，</strong><strong>UI设计师对接前端工程师是个问题。</strong></p> \n <p>UI设计师处于整个产品开发链条中最为重要也是最为尴尬的一环，产品界面设计完全出自设计师，但是却不是由设计师来最终实现。</p> \n <p>根据我的经验，其实大部分问题都出在了沟通上，开发工程师没有完全理解设计稿，他们完全依赖我们的标注和切图来进行开发，设计师的切图和标注，是否规范和精确，直接影响视觉效果的还原度。往往设计做的越精致创意，交付过程就越煎熬。</p> \n <p>然而，最后界面长的不好看,老板不会怪程序猿,是会怪你的。</p> \n <span id=\"OSC_h2_1\"></span> \n <h2><strong>标注难</strong></h2> \n <p>“这里的间距是多少啊，没有标我怎么写？”</p> \n <p>“这里的字体需不需要加粗？”</p> \n <p>“这个字需要多大的字号？”</p> \n <p>“这个是Android的尺寸？iOS的呢？我要自己算啊？”</p> \n <p>“这里的icon为什么不没有高度和宽度呢”</p> \n <p>...........</p> \n <p>我想大多数的设计师和我一样，时常因为漏标元素被开发追问这些问题。开发能不能完美的的还原设计稿，很大一部分取决于我们设计师的标注，但是哪些该标，哪些不用标，我们设计师往往不好把握，尤其是新手设计师。我们往往就尽量标得详细一些，手动标注占领了我们日常大部分的时间，还不能有效的完成交付，经常加班，有时还会有开发人员来问或者直接不问就自己做主随便做的情况。手动标注加大了沟通和时间的成本，让人精疲力尽。</p> \n <p><img alt=\"\" height=\"656\" src=\"https://oscimg.oschina.net/oscnet/2c2acb0ba23acdb0ff607c67567e9cb528d.jpg\" width=\"800\"></p> \n <span id=\"OSC_h2_2\"></span> \n <h2><strong>切图难</strong></h2> \n <p><strong>难点1：</strong>作为UI设计师，在日常工作中一个非常重要的设计输出物，就是切图。只要是无法用代码不好实现和表达出来的，就需要切图。规范的切图，会直接影响到开发工程师对设计效果的展示。光一个苹果应用中的图标就需要3种不同的大小，安卓的要求更是五花八门，最后还得打包交给开发，太多无用和低效的琐事浪费了大量的时间。</p> \n <p><strong>难点2：</strong>切图的命名格式在不同的公司都不尽相同，需要UI设计师和对接的开发工程师进行沟通，或者是团队内部进行沟通规范，才能达到良好的切图命名规范，大大降低了工作效率。</p> \n <p>&nbsp;<img alt=\"\" height=\"373\" src=\"https://oscimg.oschina.net/oscnet/6308113e2edf3b40b790463c404afe801e2.jpg\" width=\"700\"></p> \n <span id=\"OSC_h2_3\"></span> \n <h2><strong>设计协作更难</strong></h2> \n <p>设计师和程序员作为专业性很强的工作者，他们之间需要沟通和协作的工作内容太多，但往往两者不能很好的互相理解对方的工作，设计师不懂代码，程序员不懂设计，这给产品交付带来了巨大的困难，但是设计又是一个与其他部门有着很多沟通需求的工作，在协作上设计一直有着很多痛点。虽然现在市面上有许多协作应用，但始终缺少一款能让设计师得心应手，解决他们实际痛点的协作设计工具。</p> \n <p><img alt=\"\" height=\"354\" src=\"https://oscimg.oschina.net/oscnet/9bb522ba646b9b0ecc2da61507e5c564a05.jpg\" width=\"554\"></p> \n <p><strong><a href=\"https://www.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">摹客iDoc</a></strong>是由Mockplus团队开发的协作设计工具，是一款更快更简单的智能标注和切图工具，完美地解决了标注难，切图难，设计协作难的问题。</p> \n <span id=\"OSC_h2_4\"></span> \n <h2><strong>特色功能：</strong></h2> \n <ul> \n  <li>智能标注，让设计师解放双手，再也不需要手动做；可以完整而清晰地将PS、Sketch设计图中每个元素的尺寸、位置、颜色、间距、字号等样式信息自动同步到摹客iDoc，开发师可以随时查看。</li> \n  <li>还支持百分比标注；不仅可以选择单个图层，还可以连续选择多个图层，并智能标注需要的度量。设计师再也不用手动标注了，开发人员需要什么信息自己就能查看，开发人员也省心了。</li> \n </ul> \n <p><img alt=\"\" height=\"900\" src=\"https://oscimg.oschina.net/oscnet/fd18243cac4b5c6dc75a57490760870faa9.jpg\" width=\"751\"></p> \n <ul> \n  <li>全貌面板展示流程，设计稿可以随意拖动，还可以自由设置逻辑线，让设计图管理更轻松，更清晰。</li> \n </ul> \n <ul> \n  <li>支持图钉批注，还支持圆形、矩形、直线、箭头等多样批注</li> \n </ul> \n <p><img alt=\"\" height=\"524\" src=\"https://oscimg.oschina.net/oscnet/9604f655febdf4b795c188030057b0001d0.jpg\" width=\"960\"></p> \n <ul> \n  <li>可以弹出放大镜，查看微小距离的标注</li> \n </ul> \n <p><img alt=\"\" height=\"527\" src=\"https://oscimg.oschina.net/oscnet/a2c484b65aeef0f64a59cc82b0c25866079.jpg\" width=\"960\"></p> \n <span id=\"OSC_h2_5\"></span> \n <h2><strong>其他亮点功能：</strong></h2> \n <ul> \n  <li>设计规范自动采样生成，还可分类管理、同步应用、一键导出设计风格指南</li> \n  <li>自动获取切图，可下载多个或全部切图</li> \n  <li>一键查看页面中的重复元素</li> \n  <li>样式代码自动导出</li> \n  <li>支持多种附件文档支持，支持任何类型文件的上传共享，并支持多种产品文档的直接在线预览，包括Axure、Justinmind、<a href=\"https://www.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">Mockplus的原型演示</a>、office文档预览、图片文件预览、pdf和文本文件预览。</li> \n </ul> \n <span id=\"OSC_h2_6\"></span> \n <h2><strong>摹客</strong><strong>iDoc</strong><strong>让团队协作更高效，产品交付更轻松</strong></h2> \n <p><a href=\"https://www.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\"><strong><em>摹客iDoc</em></strong></a>的诞生不是偶然，是必然。中国的设计师们需要这样的一款产品来解放他们的繁杂的日常，让他们更加专注于设计，而非拘泥于如何完美的呈现交付稿。从产品、设计到开发只需要一个文档，告别混乱的文档和各种说明，让团队协作更加高效。如果你也是一名设计师，那么不凡试试这款产品吧。</p> \n</div>',NULL,'2020-02-01 17:04:50',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921530438766592',NULL,NULL,' mybatis(4) - TDDL下的getConnection是如何处理的  ','<div class=\"content\" id=\"articleContent\"> \n <p>首先我们来看看<strong><span style=\"color:#2980b9\">DataSourceUtils.doGetConnection</span></strong>的源码：spring-jdbc jar下的org.springframework.jdbc.datasource提供用来获取数据库连接</p> \n <p>通过前几篇幅对mybatis的执行过程分析可知：&nbsp;<br> 在新建defaultSqlSession实例时，其内部成员对象SpringManagedTransaction实例内拥有的connect对象还是null，但最终在执行SimpleExecutor.prepareStatement方法内获取真实连接时会跳入DataSourceUtils.doGetConnection<br> <img height=\"328\" src=\"https://oscimg.oschina.net/oscnet/4394cb5149eeae71a9552756edcbe2587de.jpg\" width=\"1026\"></p> \n <p>那关键来了，这个getConnection()做了什么呢？</p> \n <span id=\"OSC_h2_1\"></span> \n <h2>结论</h2> \n <ol> \n  <li>TDataSource 与 mycat的实现不同：<br> 前者是在应用程序内通过分库分表策略<span style=\"color:#2980b9\">(TableRule) </span>dispatcher到具体的单个库<span style=\"color:#2980b9\">（TGroupDataSource</span>）具体单个表，通过TDruidDataSource <span style=\"color:#27ae60\">(实际上内部还是DruidDataSource) </span>来具体处理； 而mycat是代理了数据库层，应用无感知，通过mycat配置table的dataNode与rule来确定分库分表规则。</li> \n  <li>在spring中的使用方式 DruidDataSource 与 TDataSource&nbsp; 基本相同。不同的是： 在常规的执行SimpleExecutor.prepareStatement方法准备prepareStatement前获取Connection时： \n   <ol> \n    <li>数据源 DruidDataSource：此刻是直接开启Druid连接；</li> \n    <li>数据源 TDataSource&nbsp;:&nbsp; 此时并不会直接开启！！而是在之后的<strong>PreparedStatementHandler调用PreparedStatement真正执行时， 将通过分库分表策略定位到具体的DruidDataSource，再开启Druid</strong><strong>连接</strong>。</li> \n   </ol> </li> \n </ol> \n <span id=\"OSC_h2_2\"></span> \n <h2>DruidDataSource</h2> \n <p>在执行getConnection方法会真正的初始化，并从DruidPooledConnection数据库连接池管理中获取连接。<span style=\"color:#27ae60\">（详见getConnectionDirect方法）</span></p> \n <p><img height=\"193\" src=\"https://oscimg.oschina.net/oscnet/738ffd2b100e3a2ea45830287545350d62d.jpg\" width=\"762\"></p> \n <p><img height=\"447\" src=\"https://oscimg.oschina.net/oscnet/122f8e73aa26aa6e0cb573d6180c32b7f95.jpg\" width=\"818\"></p> \n <span id=\"OSC_h2_3\"></span> \n <h2>TDataSource</h2> \n <ol> \n  <li><span style=\"color:#2c3e50\"><strong><span style=\"color:#c0392b\">每一个分表配置对应一个TableRule；每个库真实对应一个DruidDataSource， 多个DruidDataSource可以对应相同的一个 TGroupDataSource 。</span></strong></span><span style=\"color:#27ae60\">（当前只使用了分表分库功能，只有一个库对应一个group）</span><br> <img height=\"205\" src=\"https://oscimg.oschina.net/oscnet/62a83edab4b062360318425195d8cb15f4b.jpg\" width=\"821\"></li> \n  <li><span style=\"color:#2c3e50\">启动时会从远端配置服务上拉取分库分表配置，构建 VirtualTableRoot ：记录每一个分表配置 TableRule&nbsp;&nbsp;</span><span style=\"color:#27ae60\">（&nbsp;extends VirtualTable&nbsp;&nbsp;）</span> <pre><code class=\"language-java\">2019-02-28 16:45:50,796 [main] WARN  [com.taobao.tddl.interact.rule.VirtualTableRoot] [VirtualTableRoot.java:40] [trace=,span=,parent=,name=,app=,begintime=,endtime=] - virtual table start to init :decision_apply_data\r\n2019-02-28 16:45:50,995 [main] WARN  [com.taobao.tddl.interact.rule.VirtualTableRoot] [VirtualTableRoot.java:50] [trace=,span=,parent=,name=,app=,begintime=,endtime=] - virtual table inited :decision_apply_data\r\n2019-02-28 16:45:50,995 [main] WARN  [com.taobao.tddl.interact.rule.VirtualTableRoot] [VirtualTableRoot.java:40] [trace=,span=,parent=,name=,app=,begintime=,endtime=] - virtual table start to init :decision_exec_data_req\r\n2019-02-28 16:45:51,175 [main] WARN  [com.taobao.tddl.interact.rule.VirtualTableRoot] [VirtualTableRoot.java:50] [trace=,span=,parent=,name=,app=,begintime=,endtime=] - virtual table inited :decision_exec_data_req</code></pre> TableRule中有：<span style=\"color:#27ae60\">（VirtualTableRoot.init）</span> \n   <ol> \n    <li>每个真实的库Group与每个具体表的对应关系；</li> \n    <li>分表规则、分库规则。</li> \n    <li>库名、表名的格式<br> <img height=\"228\" src=\"https://oscimg.oschina.net/oscnet/a053471a9a943f0d26edc26384d71ca5bcd.jpg\" width=\"1180\"></li> \n   </ol> </li> \n </ol> \n <span id=\"OSC_h3_4\"></span> \n <h3>执行过程</h3> \n <p>本文直接从【<strong>执行SimpleExecutor.prepareStatement方法</strong>】开始讲述，前面的过程与常规过程类似。</p> \n <p><span style=\"color:#2980b9\"><strong>总</strong>（TDataSource &nbsp;-&gt;&nbsp;TConnectionImp -&gt;&nbsp;TPreparedStatementImp ）<strong>-&gt; </strong><strong>分库</strong>（TGroupDataSource -&gt;&nbsp;TGroupConnection -&gt;&nbsp;TGroupPreparedStatement<strong>）</strong> -&gt; <strong>实际</strong> （OneDBSelector -&gt;DataSourceWrapper -&gt;TDruidDataSource&nbsp;-&gt;&nbsp;DruidDataSource&nbsp;-&gt;&nbsp;DruidPooledConnection）</span></p> \n <p>具体的执行过程如下：</p> \n <ul> \n  <li>SimpleExecutor.prepareStatement方法构建的prepareStatement是由具体的Connection对象确定的：TDataSource.getConnection方法返回Connection是<strong><span style=\"color:#2980b9\">TConnectionImp</span></strong><span style=\"color:#2c3e50\">； 其</span>构建的prepareStatement是<span style=\"color:#2980b9\"><strong>TPreparedStatementImp</strong></span><span style=\"color:#2c3e50\"><strong>；</strong></span></li> \n  <li><span style=\"color:#2c3e50\">之后</span>常规<span style=\"color:#2c3e50\">执行</span>PreparedStatementHandler内具体方法<span style=\"color:#27ae60\">（execute等）</span>时，真实是使用<span style=\"color:#2980b9\"><strong>TPreparedStatementImp</strong></span>：<span style=\"color:#2c3e50\"><strong>&nbsp;</strong></span>其内部会确定具体的TGroupDataSource与真实的分表名<span style=\"color:#27ae60\">(原sql被改为真实执行sql)</span>。</li> \n  <li>再通过<strong><span style=\"color:#2980b9\">TGroupDataSource</span></strong>获取的连接<strong><span style=\"color:#2980b9\">TGroupConnection </span></strong>构建<strong><span style=\"color:#2980b9\">TGroupPreparedStatement</span></strong>；</li> \n  <li>进入<span style=\"color:#2c3e50\">TGroupPreparedStatement的具体方法</span><span style=\"color:#27ae60\">（execute等）</span>后 ：<span style=\"color:#2c3e50\">TGroupConnection.createNewConnection方法会真正调用</span><strong><span style=\"color:#2980b9\">TDruidDataSource</span></strong>.getConnection来真正获取到DruidDataSource进行真实数据库连接获取。</li> \n </ul> \n <p><img height=\"651\" src=\"https://oscimg.oschina.net/oscnet/48409353ba5fcb7b2f1a922e96d9496b1e8.jpg\" width=\"894\"></p> \n <span id=\"OSC_h3_5\"></span> \n <h3>getConnection</h3> \n <p>对getConnection的处理只是初始化了对象。一般默认使用<span style=\"color:#2980b9\">TConnectionImp</span>！</p> \n <p><img height=\"394\" src=\"https://oscimg.oschina.net/oscnet/ff6f0c86cbabe52b105082b8f1b811bf5f8.jpg\" width=\"1170\"></p> \n <p>很重要的是：会将所有的分库组TGroupDataSource 绑定在这个TConnectionImp上！<br> <img height=\"133\" src=\"https://oscimg.oschina.net/oscnet/bb7fa906e900cf994f85bd6f3e459eafe74.jpg\" width=\"1434\"></p> \n <span id=\"OSC_h3_6\"></span> \n <h3>TDDL什么时候真正开启连接</h3> \n <p>&nbsp;最终执行的步骤是在：SimpleExecutor调用PreparedStatementHandler调用具体执行方法<span style=\"color:#27ae60\">（execute等）</span>来dml。在这之前会通过prepareStatement方法来使用指定的connection封装PreparedStatementHandler对象。<br> TConnectionImp的prepareStatement方法构建的是<span style=\"color:#2980b9\">TPreparedStatementImp</span>对象。</p> \n <p>接着我们来看看是如果处理分库分表的：</p> \n <ol> \n  <li>首先我们看PreparedStatementHandler再执行时的入参中的sql，发现此时还是没有确定分表的<br> <img height=\"356\" src=\"https://oscimg.oschina.net/oscnet/f9528ac408c1090ac92edf64663c2da9571.jpg\" width=\"669\"></li> \n  <li><span style=\"color:#c0392b\"><strong>关键点</strong>：</span><br> 执行到<strong><span style=\"color:#2980b9\">TPreparedStatementImp （TStatementImp）</span></strong><span style=\"color:#2c3e50\">的executeQuery时，会调用&nbsp;</span><span style=\"color:#2980b9\"><strong>buildSqlExecutionContextUsePipeline</strong>&nbsp;</span>确定好具体要调用哪个库的哪个表等信息保存在<strong><span style=\"color:#2980b9\">RealSqlContextImp</span></strong>中<span style=\"color:#27ae60\">（&nbsp;SpringBasedDispatcherImpl implements SqlDispatcher）</span><br> <img height=\"416\" src=\"https://oscimg.oschina.net/oscnet/73437f5106b855d9c4883eca1dbb7ed0dc3.jpg\" width=\"1534\"><br> <span style=\"color:#2980b9\"><strong>PipelineBootstrap</strong></span>的bootstrap根据配置文件中的originalSql来判定是否走<strong><span style=\"color:#2980b9\">SimpleHintParser</span></strong><span style=\"color:#27ae60\">（有一些特殊的操作可以用到。eg. </span><a href=\"https://my.oschina.net/u/3434392/blog/3025684\" target=\"_blank\" rel=\"nofollow\">tddl 支持批量插入的方法</a><span style=\"color:#27ae60\">）</span><br> <img height=\"437\" src=\"https://oscimg.oschina.net/oscnet/c780a1fc9fad9eecaf7657951e84327c9bc.jpg\" width=\"858\"><br> <span style=\"color:#2980b9\">com.taobao.tddl.client.jdbc.executeplan.<strong>ExecutionPlanImp</strong></span>中的内容包含确定好的真实的执行sql及真实的库group等信息<br> <img height=\"582\" src=\"https://oscimg.oschina.net/oscnet/7fa045b08deceaeeed3571ce190c81d32c2.jpg\" width=\"1596\"></li> \n  <li>通过确定好的分组库配置获取连接TGroupConnection，并构建TGroupPreparedStatement。<br> <img height=\"711\" src=\"https://oscimg.oschina.net/oscnet/2a7183bee852563021a45a67853bfdb52ce.jpg\" width=\"973\"><br> <strong>此时的dbSelectorId为真实Group标识</strong><br> <img height=\"186\" src=\"https://oscimg.oschina.net/oscnet/b753361600ccf73d8d5c12d22bd793df441.jpg\" width=\"439\"><br> <img height=\"399\" src=\"https://oscimg.oschina.net/oscnet/2540f7c9669e5e18d12df14f1cdaa4f78c1.jpg\" width=\"1197\"></li> \n  <li><span style=\"color:#2980b9\">TGroupPreparedStatement.<strong>executeQuery:&nbsp;&nbsp;</strong></span><br> <img height=\"690\" src=\"https://oscimg.oschina.net/oscnet/cd054e45e553af3f2fe885228653e8a05d4.jpg\" width=\"1481\"><br> 着重看下这个方法的“gotoRead”标记。 根据originalSql的类型会判定在<strong><span style=\"color:#2980b9\">TGroupConnection</span></strong>的<strong><span style=\"color:#3498db\">getBaseConnection</span></strong>方法中是找读库还是写库<br> <img height=\"203\" src=\"https://oscimg.oschina.net/oscnet/95a3ae265d514b3f00302f248606bd7e483.jpg\" width=\"518\"></li> \n  <li><span style=\"color:#2980b9\">AbstractDBSelector.</span><strong><span style=\"color:#2980b9\">tryExecute: </span></strong>会根据策略选中指定group下的唯一的dataSource。<br> <img height=\"327\" src=\"https://oscimg.oschina.net/oscnet/9659b08c5e5b878307ac7063bfc69253fe3.jpg\" width=\"1116\"></li> \n  <li>通过<strong><span style=\"color:#2980b9\">TGroupConnection.createNewConnection</span></strong>最终调用<span style=\"color:#2980b9\"><strong>DruidDataSource.getConnection</strong></span>！！<br> <img height=\"261\" src=\"https://oscimg.oschina.net/oscnet/06eb9a1a8afe8d6004099ad77ef0341db21.jpg\" width=\"1153\"></li> \n </ol> \n</div>',NULL,'2020-02-02 18:50:05',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921547304062976',NULL,NULL,' linux的TCP超时重传--一次数据断开连接分析  ','<div class=\"content\" id=\"articleContent\"> \n <p>最近生产上发现一个问题，刚开始，应用连接数据库正常，如果长时间没有业务估计半小时以上，再发起业务时，</p> \n <p>发现应用重连不上数据库，一直挂在重连那里，如果重启应用又能很快连上数据库（数据库是Oracle)。后来经数</p> \n <p>据库专家的同学看了后，发现我们的生产是RAC的，而客户端配置了TAF，导致在发生会话切换的时候，可能原</p> \n <p>来的连接没有释放好，影响了重连。把Oracle客户端的TAF关掉，重连的问题解决了。但又出现了一个很奇怪的</p> \n <p>现象，就是今天要说的重点问题，如果长时间没业务的时候还是断，而且断了后执行SQL要15分钟左右应用才能</p> \n <p>返回，这将导致应用在15分钟内不能服务，应用返回的错误是 ORA-03113: end-of-file on communication channel</p> \n <p>从这个错误看，应该是Oracle客户端返回了连接断开的错误，但是为什么要15分钟后才返回这个错误呢？</p> \n <p>机器的网络情况如下：</p> \n <p>应用主机A ----&gt; FW1(防火墙1) ----&gt;FW2（防火墙2) ----&gt; 数据库主机(OracleDB)</p> \n <p>后来经网络专家的同学判断，有可能是防火墙设置了会话超时，如果长时间一个会话上没有数据防火墙就会删除</p> \n <p>会话，同时网上也有人遇到类似的情况：</p> \n <p><a href=\"http://static.oschina.net/uploads/img/201409/26142928_6I68.jpg\" rel=\"nofollow\"><img title=\"YQE[G(IFO0]9)UY9VOZ38IH\" alt=\"YQE[G(IFO0]9)UY9VOZ38IH\" src=\"http://static.oschina.net/uploads/img/201409/26142928_F41K.jpg\" width=\"439\" height=\"198\"></a></p> \n <p>我们做了类似的尝试，放开防火墙的时间限制后，问题没再出现。但是还有几个疑问没有解决：</p> \n <p>1.为什么防火墙删除会话后，主机要等15分钟?</p> \n <p>2.防火墙删除会话后，会不会通知主机（给主机发RST)?</p> \n <p>早上和同事讨论，猜测是由于防火墙删除了会话，但主机并不知道，有数据库操作的时候，由Oracle客户端</p> \n <p>发起TCP请求，但由于防火墙找不到会话，丢弃了这些包（目前是不是丢还不清楚），导致了TCP不停地超时</p> \n <p>重发。</p> \n <p>查看TCP/IP详解第一卷的21章节21.2节，都超时重发有这样的描述：</p> \n <p><a href=\"http://static.oschina.net/uploads/img/201409/26142928_3a2X.png\" rel=\"nofollow\"><img title=\"image\" alt=\"image\" src=\"http://static.oschina.net/uploads/img/201409/26142928_S3oD.png\" width=\"533\" height=\"217\"></a></p> \n <p>这里提到9分钟，不过这本书写得比较早，猜测linux有所不一样，不过原理差不了太多，google了一下，</p> \n <p>好像找到了15分钟的说法, <a href=\"http://blog.csdn.net/morphad/article/details/9020531\" target=\"_blank\" rel=\"nofollow\">参考资料[1]</a>中提到：</p> \n <p>TCP_RTO_MIN=(HZ/5)=0.2s <br>TCP_RTO_MAX=(120*HZ)=120s <br>linear_backoff_thresh = ilog2(120*5)=ilog2(0x258)=9 <br>timeout：未超过linear_backoff_thresh=9的部分按TCP_RTO_MIN 2的指数倍增长，超过的部分按TCP_RTO_MAX线性增长 <br>tcp_time_stamp：当前时钟时间 <br>例如数据发送阶段，sysctl_tcp_retries2=9，则timeout=1023*TCP_RTO_MIN=204.6s；sysctl_tcp_retries2=11时，timeout=1023*TCP_RTO_MIN+2*TCP_RTO_MAX=448.6s <br>默认sysctl_tcp_retries2=15，timeout=1023*TCP_RTO_MIN+6*TCP_RTO_MAX=920.6s，约15分钟</p> \n <p>是根据RTO及一定的算法算出来的（具体的算法，可以看<a href=\"http://blog.csdn.net/onelight1997/article/details/7334455\" target=\"_blank\" rel=\"nofollow\">参考资料[3]</a>) </p> \n <p>简单说，就是如果系统配置重传次数小于9的话，就是指数增长时间，如果大于9的话，就是最大超时时间。</p> \n <p>而linux默认是15，所以刚好是15分钟，查看我们主机的配置，确认是15：</p> \n <p>[steven@kfjk2 ~]$ cat /proc/sys/net/ipv4/tcp_retries2 <br>15</p> \n <p>现在还有一个问题没弄清楚，就是防火墙删除会话后，是否会通知主机？现在看起来应该是不会的，至少在主机上是没收到</p> \n <p>防火墙的RST，由于两个防火墙的两个厂商不一样，也有可能是一个吃掉另外一个的包也说不定。假如删除会话后，在原来</p> \n <p>的会话上来有包上来，是重建会话呢？还是直接把包丢弃？还是发RST呢？从目前主机的现象来看，猜测是：</p> \n <p>防火墙删除会话后，不会通知主机也就是不会给主机发RST，当有新包上来，找不到连接，但不是S包的时候，直接丢弃，</p> \n <p>导致主机用完了重发次数后，自己发RST后给应用报断开连接。</p> \n <p>不过。。。以上的东东都是根据现象来猜测的，最有效的办法是捉出tcpdump包来看，但由于是生产不敢乱动，也先这样吧！</p> \n <p>仅以此记，为避免以后踩坑，同时开发人员也要关心网络部署，当时我并没有考虑中间有两个防火墙。</p> \n <p>【参考资料】</p> \n <ol> \n  <li><a href=\"http://blog.csdn.net/morphad/article/details/9020531\" target=\"_blank\" rel=\"nofollow\">linux TCP超时重传</a></li> \n  <li><a href=\"http://www.cnblogs.com/ixxonline/archive/2011/09/10/2173292.html\" target=\"_blank\" rel=\"nofollow\">【探讨】linux下的tcp协议栈超时重传机制</a></li> \n  <li><a href=\"http://blog.csdn.net/onelight1997/article/details/7334455\" target=\"_blank\" rel=\"nofollow\">TCP/IP重传超时--RTO</a></li> \n </ol> \n</div>',NULL,'2020-02-02 18:50:11',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921565117272064',NULL,NULL,' druid之close connection error错误调整  ','<div class=\"content\" id=\"articleContent\"> \n <p>数据库：oracle</p> \n <p>数据源：druid</p> \n <p>现象：生产环境存在两套环境，k8s和rancher，k8s环境每隔几分钟会出现close connection error，或者close statement error或者对数据库访问Broken pipe,然而rancher不会，这种现象下我们排查的重点关注在k8s网络环境，一直没有解决这问题</p> \n <p>问题本质看这类错误表现为tcp连接被断开，排查的对象未k8s网络情况和防火墙情况，防火墙默认会关闭一定时间不活跃的连接，具体时间半小时还是多久看运维配置，因为只发生在k8s节点，这块一直在等运维同事处理，这块一直没有太大头绪，最终折中处理方式改为客户端处理，druid配置保活、配置对连接池中连接检测、配置验证sql超时时间、配置移除不活跃连接等，测试跟踪一天，确实没有类似错误了，具体网络层面原因再看了</p> \n <p>具体配置：</p> \n <pre><code>spring:\n  datasource:\n    driver-class-name: oracle.jdbc.OracleDriver\n    username: xx\n    password: xx\n    initialSize: 10\n    minIdle: 10\n    maxActive: 50\n    # 配置获取连接等待超时的时间\n    maxWait: 60000\n    # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\n    timeBetweenEvictionRunsMillis: 60000\n    # 配置一个连接在池中最小生存的时间，单位是毫秒\n    minEvictableIdleTimeMillis: 300000\n    validationQuery: SELECT 1 FROM DUAL\n    testWhileIdle: true\n    testOnBorrow: true\n    testOnReturn: false\n    # 打开PSCache，并且指定每个连接上PSCache的大小\n    poolPreparedStatements: true\n    maxPoolPreparedStatementPerConnectionSize: 30\n    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，wall用于防火墙\n    filters: stat,log4j\n    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=3000\n    #使用非公平锁\n    useUnfairLock: true\n    removeAbandoned: true\n    removeAbandonedTimeout: 1800\n    logAbandoned: false\n    validationQueryTimeout: 1\n    keepAlive: true\n</code></pre> \n <p>关键配置：</p> \n <p>//每次获取连接后执行validationQuery，一定程度会降低性能，但为了规避上述问题，需要配置</p> \n <p>testOnBorrow: true</p> \n <p>//非公平锁、重要，减少竞争等待时间</p> \n <p>useUnfairLock: true removeAbandoned: true removeAbandonedTimeout: 1800 logAbandoned: false</p> \n <p>//validationQueryTimeout 最好配置下，不然可能出现长达15分钟的校验时间，导致整个查询超时</p> \n <p>validationQueryTimeout: 1</p> \n <p>//在小于minIdle连接数的时候执行保活操作，防止防火墙断开连接</p> \n <p>keepAlive: true</p> \n <p>druid获取连接源码</p> \n <pre><code>public DruidPooledConnection getConnectionDirect(long maxWaitMillis) throws SQLException {\n    int notFullTimeoutRetryCnt = 0;\n    for (;;) {\n        // handle notFullTimeoutRetry\n        DruidPooledConnection poolableConnection;\n        try {\n            poolableConnection = getConnectionInternal(maxWaitMillis);\n        } catch (GetConnectionTimeoutException ex) {\n            if (notFullTimeoutRetryCnt &lt;= this.notFullTimeoutRetryCount &amp;&amp; !isFull()) {\n                notFullTimeoutRetryCnt++;\n                if (LOG.isWarnEnabled()) {\n                    LOG.warn(\"get connection timeout retry : \" + notFullTimeoutRetryCnt);\n                }\n                continue;\n            }\n            throw ex;\n        }\n\n        if (testOnBorrow) {\n            boolean validate = testConnectionInternal(poolableConnection.holder, poolableConnection.conn);\n            if (!validate) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"skip not validate connection.\");\n                }\n\n                Connection realConnection = poolableConnection.conn;\n                discardConnection(realConnection);\n                continue;\n            }\n        } else {\n            Connection realConnection = poolableConnection.conn;\n            if (poolableConnection.conn.isClosed()) {\n                discardConnection(null); // 传入null，避免重复关闭\n                continue;\n            }\n\n            if (testWhileIdle) {\n                long currentTimeMillis             = System.currentTimeMillis();\n                long lastActiveTimeMillis          = poolableConnection.holder.lastActiveTimeMillis;\n                long idleMillis                    = currentTimeMillis - lastActiveTimeMillis;\n\n                long timeBetweenEvictionRunsMillis = this.timeBetweenEvictionRunsMillis;\n\n                if (timeBetweenEvictionRunsMillis &lt;= 0) {\n                    timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;\n                }\n\n                if (idleMillis &gt;= timeBetweenEvictionRunsMillis\n                        || idleMillis &lt; 0 // unexcepted branch\n                        ) {\n                    boolean validate = testConnectionInternal(poolableConnection.holder, poolableConnection.conn);\n                    if (!validate) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"skip not validate connection.\");\n                        }\n\n                        discardConnection(realConnection);\n                         continue;\n                    }\n                }\n            }\n        }\n\n        if (removeAbandoned) {\n            StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n            poolableConnection.connectStackTrace = stackTrace;\n            poolableConnection.setConnectedTimeNano();\n            poolableConnection.traceEnable = true;\n\n            activeConnectionLock.lock();\n            try {\n                activeConnections.put(poolableConnection, PRESENT);\n            } finally {\n                activeConnectionLock.unlock();\n            }\n        }\n\n        if (!this.defaultAutoCommit) {\n            poolableConnection.setAutoCommit(false);\n        }\n\n        return poolableConnection;\n    }\n}\n</code></pre> \n</div>',NULL,'2020-02-02 18:50:15',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921586067820544',NULL,NULL,' 使用nGrinder执行socket.io应用负载测试  ','<div class=\"content\" id=\"articleContent\"> \n <p> 原文 ： &nbsp;<a href=\"http://www.cubrid.org/wiki_ngrinder/entry/using-ngrinder-to-perform-load-test-for-a-socket-io-app\" target=\"_blank\" rel=\"nofollow\">Using nGrinder to perform load test for a socket.io app</a> &nbsp; by &nbsp;<span></span><a href=\"http://www.cubrid.org/wiki_ngrinder/entry/using-ngrinder-to-perform-load-test-for-a-socket-io-app#\" rel=\"nofollow\">Mavlarn</a>&nbsp; </p> \n <p> &nbsp; &nbsp; nGrinder不仅可以用来测试通常的Web应用程序，也可以用于JDBC，Web服务或者像socket.io所提供的这样的实时应用。<br> &nbsp; &nbsp; socket.io旨在帮助我们在各种浏览器与移动设备上实现实时app功能。现在，基于浏览器和移动设备的应用越来越多，而我们也可以使用nGrinder对这些应用进行性能测试。因为我们可以使用扩展的java包来扩展测试脚本，所以，我们借助socket.io的java客户端，就可以实现对于基于socket.io的应用的性能测试。关于socket.io的java客户端，我们使用socket.io-java-client，有关这个包的使用，请参考github上的说明，其代码中也有实例。 </p> \n <p> &nbsp; &nbsp; 但是，这个java客户端使用了异步方式来发送请求和接收响应。而我们在进行测试的时候，需要记录每一个请求的处理时间，所以我们需要将对SocketIO类做一些修改，来实现同步的目的。 </p> \n <p> &nbsp; &nbsp; 其主要思想是，使用SocketIO对象创建一个与应用服务器的连接，借助java的同步机制，在发送请求之后，就等待返回值。在这个例子中，我使用了Java Lock和Condition来达到这一目标。我们创建一个SocketIO类的子类BlockingSocketIO，添加一个发送消息并等待返回结果的方法。下面是BlockingSocketIO类的源代码： &nbsp; &nbsp; </p> \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>package my;\n \nimport io.socket.IOAcknowledge;\nimport io.socket.IOCallback;\nimport io.socket.SocketIO;\nimport io.socket.SocketIOException;\n \nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n \nimport org.json.JSONObject;\n \n/**\n * Class description.\n *\n * @author Mavlarn\n * @since\n */\npublic class BlockingSocketIO implements IOCallback {\n     \n    private SocketIO socketIO;\n    private ReentrantLock transportLock;\n    private Condition responseCondition;\n    private String respMsg;\n     \n    public BlockingSocketIO (String url) {\n        try {\n            transportLock = new ReentrantLock();\n            responseCondition = transportLock.newCondition();\n            socketIO = new SocketIO(url, this);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n     \n    public String sendAndRcv (final String message) {\n        try {\n            transportLock.lock();\n            socketIO.send(message);\n            respMsg = null;\n            responseCondition.await();\n            return respMsg;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            transportLock.unlock();\n        }\n        return respMsg;\n    }\n     \n    public String sendAndRcv(final JSONObject json) {\n        try {\n            transportLock.lock();\n            socketIO.send(json);\n            respMsg = null;\n            responseCondition.await();\n            return respMsg;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            transportLock.unlock();\n        }\n        return respMsg;\n    }\n \n    public String emitAndRcv(String event, final Object args) {\n        try {\n            transportLock.lock();\n            socketIO.emit(event, args);\n            respMsg = null;\n            responseCondition.await();\n            return respMsg;\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            transportLock.unlock();\n        }\n        return respMsg;\n    }\n \n    @Override\n    public void onMessage(JSONObject json, IOAcknowledge ack) {\n        setResponse(json.toString());\n    }\n \n    @Override\n    public void onMessage(String data, IOAcknowledge ack) {\n        setResponse(data);\n    }\n \n    private void setResponse(String data) {\n        try {\n            transportLock.lock();\n            respMsg = data;\n            responseCondition.signal();\n            System.out.println(\"Server said:\" + data);\n        } finally {\n            transportLock.unlock();\n        }\n    }\n \n    @Override\n    public void onError(SocketIOException socketIOException) {\n        System.out.println(\"an Error occured\");\n        socketIOException.printStackTrace();\n    }\n \n    @Override\n    public void onDisconnect() {\n        System.out.println(\"Connection terminated.\");\n    }\n \n    @Override\n    public void onConnect() {\n        System.out.println(\"Connection established\");\n    }\n \n    @Override\n    public void on(String event, IOAcknowledge ack, Object... args) {\n        System.out.println(\"Server triggered event \'\" + event + \"\'\");\n        setResponse(args&lt;a href=\"/wiki_ngrinder/entry/0\" class=\"notexist\"&gt;0&lt;/a&gt;.toString());\n    }\n \n}</code></pre> \n <p> &nbsp; &nbsp; 我们需要把这个类打成jar包并上传到nGrinder的lib文件夹中。同时，也要上传socketio.jar及它所依赖的库WebSocket.jar和Json-org.jar。 </p> \n <p> &nbsp; &nbsp; 接下来，我们需要在nGrinder中执行测试场景的Python脚本。如下所示： </p> \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>from net.grinder.script.Grinder import grinder\nfrom net.grinder.script import Test\n \nfrom org.json import JSONObject\nfrom my import BlockingSocketIO\n \ntest1 = Test(1, \"Test1\")\n \nclass TestRunner:\n \n    def testSocketIO(self):\n        json = JSONObject()\n        user = \"Thread-%s\" % grinder.threadNumber\n        json.putOpt(\"user\", user)\n        msg = \"test message&lt;%s&gt;.\" % user\n        json.putOpt(\"message\", msg)\n        grinder.logger.info(\"msg:\" + json.toString())\n        respMsg = self.socketIO.emitAndRcv(\"user message\", json)\n        return respMsg\n     \n    def __init__(self):\n        grinder.statistics.delayReports=True\n        #init socket io\n        #create socket io object in thread init function. Then every thread will use its own socket.io connection.\n        self.socketIO = BlockingSocketIO(\"http://127.0.0.1:3000\")\n         \n        #send socket.io server to init user\n        json = JSONObject()\n        user = \"Thread-%s\" % grinder.threadNumber\n        json.putOpt(\"username\", user)\n        self.socketIO.emitAndRcv(\"user\", json)\n \n    # test method       \n    def __call__(self):\n        resp = self.testSocketIO()\n \n        if \"test message\" in resp :\n            grinder.statistics.forLastTest.success = 1\n        else :\n            grinder.statistics.forLastTest.success = 0\n \ntest1.record(TestRunner.testSocketIO)</code></pre> &nbsp; &nbsp; 在这个脚本中，在测试对象TestRunner的init函数中，我们创建了一个socket.io连接对象，然后这个线程的所有测试将使用相同的连接。这对基于socket.io的长连接池的应用是非常重要的。因为基于socket.io应用中，每个用户跟服务器之间是一直保持连接的。 \n <br> &nbsp; &nbsp; 然后，在这个init函数中，一个包含“user”事件的消息被发送到服务器，相当于在服务器端做用户登陆之类的初始化。&nbsp;再然后，在每一个测试函数中，我们都会发送一个包含““user message””事件的消息。 \n <br> &nbsp; &nbsp; 接下来，我们需要一个支持这个客户端脚本的服务器端的应用程序。服务器端使用node.js，安装socket.io模块。 \n <br> &nbsp; &nbsp; 然后再写一个名为server.js脚本，内容如下： \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>var http = require(\'http\'), io = require(\'socket.io\');\n \nvar app = http.createServer();\napp.listen(3000);\n \nconsole.log(\'Server running at http://127.0.0.1:3000/\');\n \n// Socket.IO server\nvar io = io.listen(app);\n \nio.sockets.on(\'connection\', function (socket) {\n  console.log(\"new connection from\" + socket); get and log connection\n  socket.on(\'user message\', function (msg) {  //accept a request with “user message” event\n    socket.emit(\'user message processed\', {user: msg.user, message: msg.message});\n  });\n \n  socket.on(\'user\', function (userMsg) { //accept a request with “user” event, like user login.\n    socket.user = userMsg.username;\n    socket.emit(\'user processed\', {user: userMsg.user, message: \"New user come in.\"});\n  });\n \n  socket.on(\'disconnect\', function () {\n    if (!socket.user) return;\n    socket.emit(\'announcement\', {user: socket.user, action: \'disconected\'});\n  });\n});</code></pre> &nbsp; &nbsp; 用下面的语句运行这个模拟服务器： \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>node server.js</code></pre> &nbsp; &nbsp; 你应该能够看到一条日志说这个服务器正运行在http://127.0.0.1:3000/。 \n <br> &nbsp; &nbsp; 然后，在nGrinder的脚本编辑页面中验证这个脚本以确认它能够正常运行。验证结果应该是这样的： \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>2013-03-11 13:13:08,844 INFO  elapsed time is 17 ms\n2013-03-11 13:13:08,844 INFO  Final statistics for this process:\n2013-03-11 13:13:08,854 INFO \n             Tests        Errors       Mean Test    Test Time    TPS         \n                                       Time (ms)    Standard                 \n                                                    Deviation                \n                                                    (ms)                     \n \nTest 1       1            0            3.00         0.00         58.82         \"Test1\"\n \nTotals       1            0            3.00         0.00         58.82       \n \n  Tests resulting in error only contribute to the Errors column.         \n  Statistics for individual tests can be found in the data file, including\n  (possibly incomplete) statistics for erroneous tests. Composite tests  \n  are marked with () and not included in the totals.                     \n \n \n……\n2013-03-11 13:13:08,750 INFO  validation-0: starting threads\nMar 11, 2013 1:13:08 PM io.socket.IOConnection sendPlain\nINFO: &gt; 5:::{\"args\":&lt;a href=\"/wiki_ngrinder/entry/usernamethread-0\" class=\"notexist\"&gt;{\"username\":\"Thread-0\"}&lt;/a&gt;,\"name\":\"user\"}\nMar 11, 2013 1:13:08 PM io.socket.IOConnection transportMessage\nINFO: &lt; 1::\nConnection established\nMar 11, 2013 1:13:08 PM io.socket.IOConnection transportMessage\nINFO: &lt; 5:::{\"name\":\"user processed\",\"args\":&lt;a href=\"/wiki_ngrinder/entry/messagenew-user-come-in\" class=\"notexist\"&gt;{\"message\":\"New user come in.\"}&lt;/a&gt;}\nServer triggered event \'user processed\'\nServer said:{\"message\":\"New user come in.\"}\nMar 11, 2013 1:13:08 PM io.socket.IOConnection sendPlain\nINFO: &gt; 5:::{\"args\":&lt;a href=\"/wiki_ngrinder/entry/messagetest-messagethread-0-userthread-0\" class=\"notexist\"&gt;{\"message\":\"test message&lt;Thread-0&gt;.\",\"user\":\"Thread-0\"}&lt;/a&gt;,\"name\":\"user message\"}\nMar 11, 2013 1:13:08 PM io.socket.IOConnection transportMessage\nINFO: &lt; 5:::{\"name\":\"user message processed\",\"args\":&lt;a href=\"/wiki_ngrinder/entry/userthread-0messagetest-messagethread-0\" class=\"notexist\"&gt;{\"user\":\"Thread-0\",\"message\":\"test message&lt;Thread-0&gt;.\"}&lt;/a&gt;}\nServer triggered event \'user message processed\'\nServer said:{\"message\":\"test message&lt;Thread-0&gt;.\",\"user\":\"Thread-0\"}\n2013-03-11 13:13:08,855 INFO  validation-0: finished</code></pre> \n <p> &nbsp; &nbsp; 从结果的信息我们可以看出这个测试是成功的，而且服务器处理了2个请求，一个是“user”，另一个是“user message”。而在用户的名字方面，我使用“线程－&lt;线程号&gt;”。 如果我们想要使用多个Vuser（虚拟用户）来进行测试，就要使用不同的名字。<br> &nbsp; &nbsp; 服务器端日志应与下面的内容类似： </p> \n <pre class=\"brush:html; toolbar: true; auto-links: false;\"><code>debug - client authorized\ninfo - handshake authorized gr0AYzAn7sAKTE_XsORt\ndebug - setting request GET /socket.io/1/websocket/gr0AYzAn7sAKTE_XsORt\ndebug - set heartbeat interval for client gr0AYzAn7sAKTE_XsORt\ndebug - client authorized for\ndebug - websocket writing 1::\nnew connection from&lt;a href=\"/wiki_ngrinder/entry/object-object\" class=\"notexist\"&gt;object Object&lt;/a&gt;\ndebug - websocket writing 5:::{\"name\":\"user processed\",\"args\":&lt;a href=\"/wiki_ngrinder/entry/messagenew-user-come-in\" class=\"notexist\"&gt;{\"message\":\"New user come in.\"}&lt;/a&gt;}\ndebug - websocket writing 5:::{\"name\":\"user message processed\",\"args\":&lt;a href=\"/wiki_ngrinder/entry/userthread-0messagetest-messagethread-0\" class=\"notexist\"&gt;{\"user\":\"Thread-0\",\"message\":\"test message&lt;Thread-0&gt;.\"}&lt;/a&gt;}\ninfo - transport end (socket end)\ndebug - set close timeout for client gr0AYzAn7sAKTE_XsORt\ndebug - cleared close timeout for client gr0AYzAn7sAKTE_XsORt\ndebug - cleared heartbeat interval for client gr0AYzAn7sAKTE_XsORt\ndebug - discarding transport</code></pre> \n <p> &nbsp; &nbsp; 这些服务器日志说的是，它收到了一个客户端连接并握手成功，然后处理了2个请求。最后，客户端断开。&nbsp;接下来，我们可以用这个测试脚本创建一个nGrinder测试。 </p> &nbsp; &nbsp; 下面是最终的报告： \n <p> <img src=\"http://static.oschina.net/uploads/img/201303/15100504_8IYp.png\" width=\"640\" height=\"463\" alt=\"\"> </p> \n <p> 最后，别忘了检查服务器端日志： </p> \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>......\ninfo  - transport end (socket end)\ndebug - set close timeout for client JFrRHYoO3__jN4pdsOSi\ndebug - cleared close timeout for client JFrRHYoO3__jN4pdsOSi\ndebug - cleared heartbeat interval for client JFrRHYoO3__jN4pdsOSi\ndebug - discarding transport\ninfo  - transport end (socket end)\ndebug - set close timeout for client pDHSiLJhTXaqVR5osOSk\ndebug - cleared close timeout for client pDHSiLJhTXaqVR5osOSk\ndebug - cleared heartbeat interval for client pDHSiLJhTXaqVR5osOSk\ndebug - discarding transport\ninfo  - transport end (socket end)\ndebug - set close timeout for client 7u_rypQFSZ2vcTGKsOSj\ndebug - cleared close timeout for client 7u_rypQFSZ2vcTGKsOSj\ndebug - cleared heartbeat interval for client 7u_rypQFSZ2vcTGKsOSj\ndebug - discarding transport\ninfo  - transport end (socket end)\ndebug - set close timeout for client fmxnHFQ_U-wsCmdMsOSg\ndebug - cleared close timeout for client fmxnHFQ_U-wsCmdMsOSg\ndebug - cleared heartbeat interval for client fmxnHFQ_U-wsCmdMsOSg\ndebug - discarding transport</code></pre> \n <p> &nbsp; &nbsp; 在服务器的日志中，应该会有一些连接被丢弃（discarded）的日志。在这个测试中，Vuser是10，所以在日志中应该出现10次“discarding transport”。这意味着，一个是Vuser模拟一个创建了一个连接的真实用户。如果你不想用一个线程对应一个连接，你可以将下面的代码移动到TestRunner之前： </p> \n <pre class=\"brush:python; toolbar: true; auto-links: false;\"><code>socketIO = BlockingSocketIO(\"http://127.0.0.1:3000\")</code></pre> 那么在这个处理过程中的所有线程将使用同一连接。 \n <br> \n <p> &nbsp; &nbsp; 顺便说一下，node服务器是行在我个人的笔记本上。从TPS和平均时间，我们可以看到socket.io服务器的性能是非常不错的。请在附件中查看这个test所使用的需要上传到lib目录的Java包。 &nbsp; &nbsp; </p> \n <p> &nbsp; &nbsp;附件1： <a href=\"http://www.cubrid.org/?module=file&amp;act=procFileDownload&amp;file_srl=608604&amp;sid=7f493e994e1d51564da8480452ea3861\" target=\"_blank\" rel=\"nofollow\">report.png</a>&nbsp; &nbsp;附件2：&nbsp;<a href=\"http://www.cubrid.org/?module=file&amp;act=procFileDownload&amp;file_srl=609703&amp;sid=c659c3ba9ff9545f064d4002813db5d0\" target=\"_blank\" rel=\"nofollow\">socket.io-test-libs.zip</a> </p> \n <p> <br> </p> \n <br> \n <p> <br> </p> \n <br> \n <br> \n <p> <br> </p> \n <p> <br> </p> \n <p> <br> </p> \n</div>',NULL,'2020-02-02 18:50:20',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921604958965760',NULL,NULL,' 为Phonegap Android平台增加websocket支持，使默认成为socket.io首选通  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h2_1\"></span> \n <h2> <a href=\"http://www.blogjava.net/yongboy/archive/2012/05/10/377787.html\" rel=\"nofollow\">为Phonegap Android平台增加websocket支持，使默认成为socket.io首选通道选择</a> </h2> \n <div> \n  <span id=\"OSC_h3_2\"></span> \n  <h3> <strong>广而告之</strong> </h3> \n  <p> 使用socket.io作为跨浏览器平台的实时推送首选，经测试在各个主流浏览器上测试都确实具有良好的下实时表现。这里为推广<a href=\"http://code.google.com/p/socketio-netty/\" target=\"_blank\" rel=\"nofollow\">socketio-netty</a>服务器端实现哈，做次广告，同时预热一下： </p> \n  <p> <a href=\"http://www.blogjava.net/yongboy/archive/2012/04/07/373552.html\" target=\"_blank\" rel=\"nofollow\">socketio-netty : 又一款socket.io服务器端实现，兼容0.9-1.0版本~</a> </p> \n  <p> &nbsp; </p> \n  <span id=\"OSC_h3_3\"></span> \n  <h3> <strong>示范目的</strong> </h3> \n  <p> &nbsp; </p> \n  <div> \n   <p> 我们要构建一个在市面上常见浏览器上都可以正常运行的集体聊天应用，保证在IE6+，Firefox，Chrome，Safari，Opear，IOS，Android等可以正常运转，根据具体环境自动选择最佳的通信通道。 </p> \n   <p> 嗯，既然是跨浏览器平台，那自然选择<a href=\"https://github.com/LearnBoost/socket.io-client\" target=\"_blank\" rel=\"nofollow\">socket.io(客户端js)</a>&nbsp;了。它也是本文的重心，本文的最终是让<a href=\"https://github.com/LearnBoost/socket.io-client\" target=\"_blank\" rel=\"nofollow\">socket.io(客户端js)</a>&nbsp;版本在Phonegap包装的Android Apk程序中可以使用Websocket协议，以达到快速交换数据的目的，提高交换性能。 </p> \n   <p> 同时也保证我们的示范应用尽可能的做到编写一次，到处运行哈。 </p> \n   <p> 还好，有了<a href=\"https://github.com/LearnBoost/socket.io-client\" target=\"_blank\" rel=\"nofollow\">socket.io(客户端js)</a>&nbsp;+&nbsp;<a href=\"http://code.google.com/p/socketio-netty/\" target=\"_blank\" rel=\"nofollow\">socketio-netty</a>（socket.io服务器端JAVA实现） +&nbsp;<a href=\"http://phonegap.com/\" target=\"_blank\" rel=\"nofollow\">Phonegap</a>, 我们构建各种交互性非常强的的跨浏览器、跨移动应用的HTML应用，是个不错的选择。 </p> \n   <p> 另，本文示范项目为仅仅为演示其功能，不保证样式。 </p> \n  </div> \n  <p> &nbsp; </p> \n  <span id=\"OSC_h3_4\"></span> \n  <h3> <strong>Phonegap</strong> </h3> \n  <p> <a href=\"http://phonegap.com/\" target=\"_blank\" rel=\"nofollow\">官网</a> </p> \n  <p> 官网定义为： </p> \n  <blockquote> \n   <p> <strong>PhoneGap</strong>&nbsp;is an HTML5 app platform that allows you to author native applications with web technologies and get access to APIs and app stores. </p> \n  </blockquote> \n  <p> 中文翻译为： </p> \n  <blockquote> \n   <p> PhoneGap是一个开源的开发框架，使用HTML，CSS和JavaScript来构建跨平台的的移动应用程序 </p> \n  </blockquote> \n  <p> 可使用HTML + CSS + Javascript构建跨平台的移动引用，确实很不错，值得推荐。 </p> \n  <p> 更棒的，可以利用其云构建服务（<a href=\"https://build.phonegap.com/apps\" rel=\"nofollow\">https://build.phonegap.com/apps</a>&nbsp;) ，本机编写好应用之后（保证首页为index.html，涉及到的css/js存放在一起），打包成zip，上传，自动会为我们自动构建不同平台下的部署包，十分方便。 </p> \n  <p> 表面上看，一切都很完美，但部署到Android系统之后，发现socket.io无法使用websocket双向的通道，socket.io默认采用xhr-long polling通信模式。有些无奈。 </p> \n  <p> 在实时交互数据量很大的情况下，相比xhr-long polling, jsonp polling，Websocket/Flashsocket具有无法超越的速度优势，同时双向数据传输通道，通过观察可以很明显的感觉到。 </p> \n  <span id=\"OSC_h3_5\"></span> \n  <h3> <strong></strong>&nbsp; </h3> \n  <span id=\"OSC_h3_6\"></span> \n  <h3> <strong>起因</strong> </h3> \n  <ol> \n   <li> 我的android系统是2.3的，其原生的浏览器不支持websocket通信协议（ucweb,qq,opear mini 等都支持较为完整的HTML5规范）。 </li> \n   <li> Phonegap转换的APK包，会调用android内置浏览器，因此导致websocket无法使用。 </li> \n   <li> 据调研Android 2/3.* 原生浏览器不支持websocket，至于Android 4.*，没有测试过。 </li> \n  </ol> \n  <p> 如何确认浏览器对html5的支持情况， 浏览器访问&nbsp;<a href=\"http://html5test.com/\" rel=\"nofollow\">http://html5test.com</a>&nbsp;即可查询对HTML5的支持情况，以及跑分等。 </p> \n  <p> 嗯，据传言，Phonegap会在2.0版本之后，添加对Android的websocket支持，但目前版本为1.7。 </p> \n  <span id=\"OSC_h3_7\"></span> \n  <h3> <strong></strong>&nbsp; </h3> \n  <span id=\"OSC_h3_8\"></span> \n  <h3> <strong>解决方式</strong> </h3> \n  <p> <a href=\"http://anismiles.wordpress.com/\" target=\"_blank\" rel=\"nofollow\">animesh kumar</a>&nbsp;开发的<a href=\"https://github.com/anismiles/websocket-android-phonegap\" target=\"_blank\" rel=\"nofollow\">websocket-android-phonegap</a>项目，已经做到了让Phonegap支持websocket客户端协议，使用java nio编写websocket客户端协议连接，同时Phonegap支持自定义组件，支持JS和JAVA代码的相互调用开放架构，这样就促成了伪装的webscoket.js。 </p> \n  <p> 其有些DWR的味道，但更为灵活。 </p> \n  <p> 另外还有一个单纯的socket.io android客户端实现： </p> \n  <span id=\"OSC_h3_9\"></span> \n  <h3> <a href=\"https://github.com/koush/android-websockets#readme\" rel=\"nofollow\">https://github.com/koush/android-websockets#readme</a> </h3> \n  <p> 有兴趣者，可以参考一下。 </p> \n  <p> 本打算使用Netty构建一个websocket客户端，然后结合js等，但有开源实现，不再闭门造车。 </p> \n  <ol> \n   <li> 在Eclipse中新建Android Project项目chatdemo </li> \n   <li> 把<a href=\"http://anismiles.wordpress.com/\" target=\"_blank\" rel=\"nofollow\">animesh kumar</a>的<strong>websocket-android-phonegap</strong>项目java文件打成<a href=\"https://skydrive.live.com/redir.aspx?cid=cf7746837803bc50&amp;resid=CF7746837803BC50!1279&amp;parid=CF7746837803BC50!546&amp;authkey=!AIjIaPhDpKIPz3k\" target=\"_blank\" rel=\"nofollow\">phonegap-websocket-support.jar</a>包，存放在 android project的libs目录下 </li> \n   <li> 把<a href=\"https://skydrive.live.com/redir.aspx?cid=cf7746837803bc50&amp;resid=CF7746837803BC50!1280&amp;parid=CF7746837803BC50!546&amp;authkey=!AJJLZtM2ynFCwS0\" target=\"_blank\" rel=\"nofollow\">websocket.js</a>存放在 assets/www/js目录下 </li> \n   <li> 修改项目启动类App.java </li> \n   <li> 添加&lt;script src=\"js/websocket.js\"&gt;&lt;/script&gt; </li> \n  </ol> \n  <p> &nbsp; </p> \n  <span id=\"OSC_h3_10\"></span> \n  <h3> <strong>简单说明</strong> </h3> \n  <p> 1. App.java修改后： </p> \n  <p> 确保继承DroidGap，并且指定绑定语句： </p> \n  <blockquote> \n   <pre><code><p> // 绑定websocket支持 </p>\n\n<p> appView.addJavascriptInterface(new WebSocketFactory(appView), </p>\n\n<p> \"WebSocketFactory\"); </p></code></pre> \n  </blockquote> \n  <p> JAVA端设定完毕。 </p> \n  <p> 2. 客户端的修改 </p> \n  <p> 需要在html页面端做些手脚，优先加载websocket.js进行一些环境变量的设定，这样socket.io就可以检测websocket的支持。 </p> \n  <p> websocekt.js的初始化代码： </p> \n  <p> 需要注意其初始化代码： </p> \n  <blockquote> \n   <p> // window object<br> var global = window; </p> \n   <p> // WebSocket Object. All listener methods are cleaned up!<br> var WebSocket = global.WebSocket = function(url) </p> ...... \n  </blockquote> \n  <p> &nbsp; </p> \n  <p> socket.io client websocket 代码片段： </p> \n  <p> 看一下websocket的检测函数： </p> \n  <blockquote> \n   <p> WS.check = function () {<br> &nbsp; return (\'WebSocket\' in global &amp;&amp; !(\'__addTask\' in WebSocket))<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || \'MozWebSocket\' in global;<br> }; </p> \n  </blockquote> \n  <p> 很自然的，自定义的websocket.js 和 socket.io两者就能够很自然的衔接在一起了。 </p> \n  <p> &nbsp; </p> \n  <p> 因此，必须的页面JS加载顺序为： </p> \n  <blockquote> \n   <p> &lt;!--android平台需要添加，其它移动平台，比如ios则不需要 --&gt;<br> &lt;!--一定要放在socket.io.min.js前面 --&gt;<br> &lt;script src=\"js/websocket.js\"&gt;&lt;/script&gt;<br> &lt;script src=\"js/socket.io.min.js\"&gt;&lt;/script&gt; </p> \n  </blockquote> \n  <p> 在HTML页面端，我们仅仅需要添加一行&lt;script src=\"js/websocket.js\"&gt;&lt;/script&gt;引用，就做到了让android平台下socket.io优先选择websocket，很简单，也很使用。 </p> \n  <p> 至于其它平台，则不需要考虑这么，仅仅把/chatdemo/assets/www目录下打包成zip包（切记把&lt;script src=\"js/websocket.js\"&gt;&lt;/script&gt;去除掉），上传到云构建平台自动构建即可。 </p> \n  <p> &nbsp; </p> \n  <span id=\"OSC_h3_11\"></span> \n  <h3> <strong>小总结</strong> </h3> \n  <p> Phonegap下让android平台支持websocket，步骤很简单： </p> \n  <ol> \n   <li> 在eclipse下搭建android project </li> \n   <li> 拷贝jar以及socekt.js到相应目录 </li> \n   <li> 修改App.java（其它android启动类，方法名不一样，但方法体一致） </li> \n   <li> 在首页或者需要的页面，在 socket.io js医用的前面，添加&lt;script src=\"js/websocket.js\"&gt;&lt;/script&gt;引用即可 </li> \n  </ol> \n  <p> &nbsp; </p> \n  <span id=\"OSC_h3_12\"></span> \n  <h3> <strong>示范代码</strong> </h3> \n  <ol> \n   <li> <a href=\"http://socket.io/\" target=\"_blank\" rel=\"nofollow\">socket.io</a>&nbsp;框架内置的chat聊天示范和<a href=\"http://code.google.com/p/socketio-netty/\" target=\"_blank\" rel=\"nofollow\">socketio-netty</a>所提供聊天示范完全一致，除了服务器端实现不同 </li> \n   <li> 简单包装成android项目，仅用于演示使用，因此界面有些大 </li> \n   <li> 需要一个服务器端,<a href=\"http://socket.io/\" target=\"_blank\" rel=\"nofollow\">socket.io</a>或者<a href=\"http://code.google.com/p/socketio-netty/\" target=\"_blank\" rel=\"nofollow\">socketio-netty</a>的都可以 </li> \n   <li> 本文Android示范chat下载&nbsp;<a href=\"https://skydrive.live.com/redir.aspx?cid=cf7746837803bc50&amp;resid=CF7746837803BC50!1278&amp;parid=CF7746837803BC50!546&amp;authkey=!AKImvowSw7Ab2bE\" target=\"_blank\" rel=\"nofollow\">下载</a> </li> \n   <li> <a href=\"https://skydrive.live.com/redir.aspx?cid=cf7746837803bc50&amp;resid=CF7746837803BC50!1279&amp;parid=CF7746837803BC50!546&amp;authkey=!AIjIaPhDpKIPz3k\" target=\"_blank\" rel=\"nofollow\">phonegap-websocket-support.jar</a> </li> \n  </ol> \n  <p> &nbsp; </p> \n </div> \n</div>',NULL,'2020-02-02 18:50:25',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921622122057728',NULL,NULL,' 《Spring Cloud Alibaba基础教程》连载目录   ','<div class=\"content\" id=\"articleContent\"> \n <ul> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-version/\">Spring Cloud Alibaba与Spring Boot、Spring Cloud之间不得不说的版本关系</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-significance/\">说说我为什么看好Spring Cloud Alibaba</a></li> \n  <li><a href=\"http://blog.didispace.com/bo-kengdie-spring-cloud-alibaba/\">Spring Cloud Alibaba到底坑不坑？</a></li> \n </ul> \n <p><em>注册中心与配置中心：Nacos</em></p> \n <ul> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-1/\">Spring Cloud Alibaba基础教程：使用Nacos实现服务注册与发现</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-1/\">Spring Cloud Alibaba基础教程：Nacos 生产级版本 0.8.0</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-2/\">Spring Cloud Alibaba基础教程：支持的几种服务消费方式（RestTemplate、WebClient、Feign）</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-3/\">Spring Cloud Alibaba基础教程：使用Nacos作为配置中心</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/\">Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/\">Spring Cloud Alibaba基础教程：Nacos配置的多环境管理</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-3/\">Spring Cloud Alibaba基础教程：Nacos配置的多文件加载与共享配置</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-4/\">Spring Cloud Alibaba基础教程：Nacos的数据持久化</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-5/\">Spring Cloud Alibaba基础教程：Nacos的集群部署</a></li> \n </ul> \n <p><em>分布式流量防卫兵：Sentinel</em></p> \n <ul> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-sentinel-1/\">Spring Cloud Alibaba基础教程：使用Sentinel实现接口限流</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-sentinel-2-1/\">Spring Cloud Alibaba基础教程：Sentinel使用Nacos存储规则</a></li> \n </ul> \n</div>',NULL,'2020-02-02 18:50:29',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921639134154752',NULL,NULL,' 公益：开放一台Nacos服务端给各位Spring Cloud爱好者  ','<div class=\"content\" id=\"articleContent\"> \n <p>之前开放过一台公益<a href=\"http://eureka.didispace.com/\">Eureka Server</a>给大家，以方便大家在阅读我博客中教程时候做实验。由于目前在连载Spring Cloud Alibaba，所以对应的也部署了一台Nacos，并且也开放出来，给大家学习测试之用。</p> \n <ul> \n  <li>Nacos控制台 \n   <ul> \n    <li>地址：<a href=\"http://nacos.didispace.com/nacos/index.html\">http://nacos.didispace.com/nacos/index.html</a></li> \n    <li>账户与密码均为：nacos</li> \n   </ul> </li> \n  <li>客户端使用配置 \n   <ul> \n    <li>使用注册中心服务：<code>spring.cloud.nacos.discovery.server-addr=nacos.didispace.com:80</code></li> \n    <li>使用配置中心服务：<code>spring.cloud.nacos.config.server-addr=nacos.didispace.com:80</code></li> \n   </ul> </li> \n </ul> \n <h3>Spring Cloud Alibaba系列专题</h3> \n <p>下面是当前已经发布的内容，后续内容也将基于Spring Cloud Alibaba 0.2.2进行。</p> \n <ul> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-1/\">Spring Cloud Alibaba基础教程：使用Nacos实现服务注册与发现</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-2/\">Spring Cloud Alibaba基础教程：支持的几种服务消费方式（RestTemplate、WebClient、Feign）</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-3/\">Spring Cloud Alibaba基础教程：使用Nacos作为配置中心</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/\">Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/\">Spring Cloud Alibaba基础教程：Nacos配置的多环境管理</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-3/\">Spring Cloud Alibaba基础教程：Nacos配置的多文件加载与共享配置</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-4/\">Spring Cloud Alibaba基础教程：Nacos的数据持久化</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-5/\">Spring Cloud Alibaba基础教程：Nacos的集群部署</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-sentinel-1/\">Spring Cloud Alibaba基础教程：使用Sentinel实现接口限流</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-sentinel-2-1/\">Spring Cloud Alibaba基础教程：Sentinel使用Nacos存储规则</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-sentinel-2-2/\">Spring Cloud Alibaba基础教程：Sentinel使用Apollo存储规则</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-learning/\">查看更多...</a></li> \n </ul> \n <p><strong>示例仓库</strong></p> \n <ul> \n  <li><em>Github：</em><a href=\"https://github.com/dyc87112/SpringCloud-Learning/tree/master/4-Finchley\">https://github.com/dyc87112/SpringCloud-Learning/</a></li> \n  <li><em>Gitee：</em><a href=\"https://gitee.com/didispace/SpringCloud-Learning/tree/master/4-Finchley\">https://gitee.com/didispace/SpringCloud-Learning/</a></li> \n </ul> \n <p><strong>如果您对这些感兴趣，欢迎star、follow、收藏、转发给予支持！</strong></p> \n <h3>后记</h3> \n <p>后续有更多资源之后，尽量再多部署一些，平时方便大家测试使用。汇总一下当前资源：</p> \n <ul> \n  <li>Eureka Server：<a href=\"http://eureka.didispace.com/\">http://eureka.didispace.com/</a></li> \n  <li>Nacos Server：<a href=\"http://nacos.didispace.com/nacos/index.html\">http://nacos.didispace.com/nacos/index.html</a></li> \n </ul> \n</div>',NULL,'2020-02-02 18:50:33',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921657601675264',NULL,NULL,' Spring Cloud Alibaba基础教程：Nacos配置的多文件加载与共享配置  ','<div class=\"content\" id=\"articleContent\"> \n <p>前情回顾：</p> \n <ul> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-1/\">《Spring Cloud Alibaba基础教程：使用Nacos实现服务注册与发现》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-2/\">《Spring Cloud Alibaba基础教程：支持的几种服务消费方式》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-3/\">《Spring Cloud Alibaba基础教程：使用Nacos作为配置中心》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/\">《Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-2/\">《Spring Cloud Alibaba基础教程：Nacos配置的多环境管理》</a></li> \n </ul> \n <p>对于Nacos作为配置中心的使用，通过之前的几篇博文，我们已经介绍了如何在Nacos中创建配置内容、Nacos配置内容与Spring应用配置之间的对应关系以及实战中多环境下的配置管理方案。</p> \n <p>但是，我们实际应用过程中还会经常碰到这样的问题：有时候我们会对应用的配置根据具体作用做一些拆分，存储在不同的配置文件中，除了归类不同的配置之外，也可以便于共享配置给不同的应用。对于这样的需求，Nacos也可以很好的支持，下面就来具体介绍一下，当使用Nacos时，我们如何加载多个配置，以及如何共享配置。</p> \n <h2>加载多个配置</h2> \n <p>通过之前的学习，我们已经知道Spring应用对Nacos中配置内容的对应关系是通过下面三个参数控制的：</p> \n <ul> \n  <li>spring.cloud.nacos.config.prefix</li> \n  <li>spring.cloud.nacos.config.file-extension</li> \n  <li>spring.cloud.nacos.config.group</li> \n </ul> \n <p>默认情况下，会加载<code>Data ID=${spring.application.name}.properties</code>，<code>Group=DEFAULT_GROUP</code>的配置。</p> \n <p>假设现在有这样的一个需求：我们想要对所有应用的Actuator模块以及日志输出做统一的配置管理。所以，我们希望可以将Actuator模块的配置放在独立的配置文件<code>actuator.properties</code>文件中，而对于日志输出的配置放在独立的配置文件<code>log.properties</code>文件中。通过拆分这两类配置内容，希望可以做到配置的共享加载与统一管理。</p> \n <p>这时候，我们只需要做以下两步，就可以实现这个需求：</p> \n <p><strong>第一步</strong>：在Nacos中创建<code>Data ID=actuator.properties</code>，<code>Group=DEFAULT_GROUP</code>和<code>Data ID=log.properties</code>，<code>Group=DEFAULT_GROUP</code>的配置内容。</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/34414bdadb345a10f598ab956aedd3d39db.jpg\" alt=\"\"></p> \n <p><strong>第二步</strong>：在Spring Cloud应用中通过使用<code>spring.cloud.nacos.config.ext-config</code>参数来配置要加载的这两个配置内容，比如：</p> \n <pre><code class=\"language-properties\">spring.cloud.nacos.config.ext-config[0].data-id=actuator.properties\nspring.cloud.nacos.config.ext-config[0].group=DEFAULT_GROUP\nspring.cloud.nacos.config.ext-config[0].refresh=true\nspring.cloud.nacos.config.ext-config[1].data-id=log.properties\nspring.cloud.nacos.config.ext-config[1].group=DEFAULT_GROUP\nspring.cloud.nacos.config.ext-config[1].refresh=true\n</code></pre> \n <p>可以看到，<code>spring.cloud.nacos.config.ext-config</code>配置是一个数组List类型。每个配置中包含三个参数：<code>data-id</code>、<code>group</code>，<code>refresh</code>；前两个不做赘述，与Nacos中创建的配置相互对应，<code>refresh</code>参数控制这个配置文件中的内容时候支持自动刷新，默认情况下，只有默认加载的配置才会自动刷新，对于这些扩展的配置加载内容需要配置该设置时候才会实现自动刷新。</p> \n <h2>共享配置</h2> \n <p>通过上面加载多个配置的实现，实际上我们已经可以实现不同应用共享配置了。但是Nacos中还提供了另外一个便捷的配置方式，比如下面的设置与上面使用的配置内容是等价的：</p> \n <pre><code class=\"language-properties\">spring.cloud.nacos.config.shared-dataids=actuator.properties,log.properties\nspring.cloud.nacos.config.refreshable-dataids=actuator.properties,log.properties\n</code></pre> \n <ul> \n  <li><code>spring.cloud.nacos.config.shared-dataids</code>参数用来配置多个共享配置的<code>Data Id</code>，多个的时候用用逗号分隔</li> \n  <li><code>spring.cloud.nacos.config.refreshable-dataids</code>参数用来定义哪些共享配置的<code>Data Id</code>在配置变化时，应用中可以动态刷新，多个<code>Data Id</code>之间用逗号隔开。如果没有明确配置，默认情况下所有共享配置都不支持动态刷新</li> \n </ul> \n <h2>配置加载的优先级</h2> \n <p>当我们加载多个配置的时候，如果存在相同的key时，我们需要深入了解配置加载的优先级关系。</p> \n <p>在使用Nacos配置的时候，主要有以下三类配置：</p> \n <ul> \n  <li>A: 通过<code>spring.cloud.nacos.config.shared-dataids</code>定义的共享配置</li> \n  <li>B: 通过<code>spring.cloud.nacos.config.ext-config[n]</code>定义的加载配置</li> \n  <li>C: 通过内部规则（<code>spring.cloud.nacos.config.prefix</code>、<code>spring.cloud.nacos.config.file-extension</code>、<code>spring.cloud.nacos.config.group</code>这几个参数）拼接出来的配置</li> \n </ul> \n <p>要弄清楚这几个配置加载的顺序，我们从日志中也可以很清晰的看到，我们可以做一个简单的实验：</p> \n <pre><code class=\"language-properties\">spring.cloud.nacos.config.ext-config[0].data-id=actuator.properties\nspring.cloud.nacos.config.ext-config[0].group=DEFAULT_GROUP\nspring.cloud.nacos.config.ext-config[0].refresh=true\n\nspring.cloud.nacos.config.shared-dataids=log.properties\nspring.cloud.nacos.config.refreshable-dataids=log.properties\n</code></pre> \n <p>根据上面的配置，应用分别会去加载三类不同的配置文件，启动应用的时候，将会在日志中看到如下输出：</p> \n <pre><code>2019-02-08 21:23:02.665  INFO 63804 --- [main] o.s.c.a.n.c.NacosPropertySourceBuilder   : Loading nacos data, dataId: \'log.properties\', group: \'DEFAULT_GROUP\'\n2019-02-08 21:23:02.671  INFO 63804 --- [main] o.s.c.a.n.c.NacosPropertySourceBuilder   : Loading nacos data, dataId: \'actuator.properties\', group: \'DEFAULT_GROUP\'\n2019-02-08 21:23:02.677  INFO 63804 --- [main] o.s.c.a.n.c.NacosPropertySourceBuilder   : Loading nacos data, dataId: \'alibaba-nacos-config-client.properties\', group: \'DEFAULT_GROUP\'\n</code></pre> \n <p>后面加载的配置会覆盖之前加载的配置，所以优先级关系是：<code>A &lt; B &lt; C</code></p> \n <h2>参考资料</h2> \n <ul> \n  <li><a href=\"https://nacos.io/zh-cn/docs/what-is-nacos.html\">Nacos官方文档</a></li> \n </ul> \n <h2>代码示例</h2> \n <p>本文示例读者可以通过查看下面仓库的中的<code>alibaba-nacos-config-client</code>项目：</p> \n <ul> \n  <li><em>Github：</em><a href=\"https://github.com/dyc87112/SpringCloud-Learning/tree/master/4-Finchley\">https://github.com/dyc87112/SpringCloud-Learning/</a></li> \n  <li><em>Gitee：</em><a href=\"https://gitee.com/didispace/SpringCloud-Learning/tree/master/4-Finchley\">https://gitee.com/didispace/SpringCloud-Learning/</a></li> \n </ul> \n <p><strong>如果您对这些感兴趣，欢迎star、follow、收藏、转发给予支持！</strong></p> \n <h2>以下专题教程也许您会有兴趣</h2> \n <ul> \n  <li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">Spring Boot基础教程</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-learning/\">Spring Cloud基础教程</a></li> \n </ul> \n</div>',NULL,'2020-02-02 18:50:37',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921679646937088',NULL,NULL,' Spring Cloud Alibaba基础教程：Nacos配置的多环境管理   ','<div class=\"content\" id=\"articleContent\"> \n <p>前情回顾：</p> \n <ul> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-1/\">《Spring Cloud Alibaba基础教程：使用Nacos实现服务注册与发现》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-2/\">《Spring Cloud Alibaba基础教程：支持的几种服务消费方式》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-3/\">《Spring Cloud Alibaba基础教程：使用Nacos作为配置中心》</a></li> \n  <li><a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/\">《Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解》</a></li> \n </ul> \n <p>通过之前两篇对Nacos配置管理功能的介绍，已经学会了在Nacos中如何加入配置以及Spring Cloud应用如何通过配置来加载到对应的内容。接下来，我们讨论一个在使用配置中心时，都需要关注的一个问题：多环境的配置如何实现与管理？</p> \n <h2>多环境管理</h2> \n <p>在Nacos中，本身有多个不同管理级别的概念，包括：<code>Data ID</code>、<code>Group</code>、<code>Namespace</code>。只要利用好这些层级概念的关系，就可以根据自己的需要来实现多环境的管理。</p> \n <p>下面，我就来介绍一下，可以使用的几种实现方式：</p> \n <h3>使用<code>Data ID</code>与<code>profiles</code>实现</h3> \n <p><code>Data ID</code>在Nacos中，我们可以理解为就是一个Spring Cloud应用的配置文件名。通过上一篇<a href=\"http://blog.didispace.com/spring-cloud-alibaba-nacos-config-1/\">《Spring Cloud Alibaba基础教程：Nacos配置的加载规则详解》</a>，我们知道默认情况下<code>Data ID</code>的名称格式是这样的：<code>${spring.application.name}.properties</code>，即：以Spring Cloud应用命名的properties文件。</p> \n <p>实际上，<code>Data ID</code>的规则中，还包含了环境逻辑，这一点与Spring Cloud Config的设计类似。我们在应用启动时，可以通过<code>spring.profiles.active</code>来指定具体的环境名称，此时客户端就会把要获取配置的<code>Data ID</code>组织为：<code>${spring.application.name}-${spring.profiles.active}.properties</code>。</p> \n <blockquote> \n  <p>实际上，更原始且最通用的匹配规则，是这样的：<code>${spring.cloud.nacos.config.prefix}</code>-<code>${spring.profile.active}</code>.<code>${spring.cloud.nacos.config.file-extension}</code>。而上面的结果是因为<code>${spring.cloud.nacos.config.prefix}</code>和<code>${spring.cloud.nacos.config.file-extension}</code>都使用了默认值。</p> \n </blockquote> \n <p><strong>动手试一试</strong></p> \n <p>我们可以用<a href=\"http://blog.didispace.com/spring-cloud-alibaba-3/\">《Spring Cloud Alibaba基础教程：使用Nacos作为配置中心》</a>一文中的列子（可在文末仓库中获取）为基础，体验一下这种区分环境的配置方式。</p> \n <p><strong>第一步</strong>：先在Nacos中，根据这个规则，创建两个不同环境的配置内容。比如：</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/7c5ba9029de2893ea6eb81cb3586423b924.jpg\" alt=\"\"></p> \n <p>如上图，我们为<code>alibaba-nacos-config-client</code>应用，定义了DEV和TEST的两个独立的环境配置。我们可以在里面定义不同的内容值，以便后续验证是否真实加载到了正确的配置。</p> \n <p><strong>第二步</strong>：在<code>alibaba-nacos-config-client</code>应用的配置文件中，增加环境配置：<code>spring.profiles.active=DEV</code></p> \n <p><strong>第三步</strong>：启动应用，我们可以看到日志中打印了，加载的配置文件：</p> \n <pre><code class=\"language-bash\">2019-01-30 15:25:18.216  INFO 96958 --- [           main] o.s.c.a.n.c.NacosPropertySourceBuilder   : Loading nacos data, dataId: \'alibaba-nacos-config-client-DEV.properties\', group: \'DEFAULT_GROUP\'\n</code></pre> \n <h3>使用<code>Group</code>实现</h3> \n <p><code>Group</code>在Nacos中是用来对<code>Data ID</code>做集合管理的重要概念。所以，如果我们把一个环境的配置视为一个集合，那么也就可以实现不同环境的配置管理。对于<code>Group</code>的用法并没有固定的规定，所以我们在实际使用的时候，需要根据我们的具体需求，可以是架构运维上对多环境的管理，也可以是业务上对不同模块的参数管理。为了避免冲突，我们需要在架构设计之初，做好一定的规划。这里，我们先来说说如何用<code>Group</code>来实现多环境配置管理的具体实现方式。</p> \n <p><strong>动手试一试</strong></p> \n <p><strong>第一步</strong>：先在Nacos中，通过区分<code>Group</code>来创建两个不同环境的配置内容。比如：</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/db2177f06658512d82c8abb805828f18f38.jpg\" alt=\"\"></p> \n <p>如上图，我们为<code>alibaba-nacos-config-client</code>应用，定义了DEV环境和TEST环境的两个独立的配置，这两个匹配与上一种方法不同，它们的<code>Data ID</code>是完全相同的，只是<code>GROUP</code>不同。</p> \n <p><strong>第二步</strong>：在<code>alibaba-nacos-config-client</code>应用的配置文件中，增加<code>Group</code>的指定配置：<code>spring.cloud.nacos.config.group=DEV_GROUP</code></p> \n <p><strong>第三步</strong>：启动应用，我们可以看到日志中打印了，加载的配置文件：</p> \n <pre><code class=\"language-bash\">2019-01-30 15:55:23.718  INFO 3216 --- [main] o.s.c.a.n.c.NacosPropertySourceBuilder   : Loading nacos data, dataId: \'alibaba-nacos-config-client.properties\', group: \'DEV_GROUP\'\n</code></pre> \n <h3>使用<code>Namespace</code>实现</h3> \n <p><code>Namespace</code>在本系列教程中，应该还是第一次出现。先来看看官方的概念说明：用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的<code>Group</code>或<code>Data ID</code>的配置。<code>Namespace</code>的常用场景之一是不同环境的配置的区分隔离，例如：开发测试环境和生产环境的资源（如配置、服务）隔离等。</p> \n <p>在官方的介绍中，就介绍了利用其可以作为环境的隔离使用，下面我们就来试一下吧！</p> \n <p><strong>动手试一试</strong></p> \n <p><strong>第一步</strong>：先在Nacos中，根据环境名称来创建多个<code>Namespace</code>。比如：</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/20fb87142eae2d2e0e9b786f3eb3ae55ac7.jpg\" alt=\"\"></p> \n <p><strong>第二步</strong>：在配置列表的最上方，可以看到除了<code>Public</code>之外，多了几个刚才创建的<code>Namepsace</code>。分别在<code>DEV</code>和<code>TEST</code>空间下为<code>alibaba-nacos-config-client</code>应用创建配置内容：</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/85e2dd49fa8141b41c39f0cf6465451270c.jpg\" alt=\"\"></p> \n <p><strong>第三步</strong>：在<code>alibaba-nacos-config-client</code>应用的配置文件中，增加<code>Namespace</code>的指定配置，比如：<code>spring.cloud.nacos.config.namespace=83eed625-d166-4619-b923-93df2088883a</code>。</p> \n <blockquote> \n  <p>这里需要注意namespace的配置不是使用名称，而是使用Namespace的ID。</p> \n </blockquote> \n <p><strong>第四步</strong>：启动应用，通过访问<code>localhost:8001/test</code>接口，验证一下返回内容是否正确。这种方式下，目前版本的日志并不会输出与<code>Namespace</code>相关的信息，所以还无法以此作为加载内容的判断依据。</p> \n <h2>深入思考</h2> \n <p>上面我们分别利用Nacos配置管理功能中的几个不同纬度来实现多环境的配置管理。从结果上而言，不论用哪一种方式，都能够胜任需求，但是哪一种最好呢？</p> \n <p><strong>第一种</strong>：通过<code>Data ID</code>与<code>profile</code>实现。</p> \n <ul> \n  <li><em>优点</em>：这种方式与Spring Cloud Config的实现非常像，用过Spring Cloud Config的用户，可以毫无违和感的过渡过来，由于命名规则类似，所以要从Spring Cloud Config中做迁移也非常简单。</li> \n  <li><em>缺点</em>：这种方式在项目与环境多的时候，配置内容就会显得非常混乱。配置列表中会看到各种不同应用，不同环境的配置交织在一起，非常不利于管理。</li> \n  <li><em>建议</em>：项目不多时使用，或者可以结合<code>Group</code>对项目根据业务或者组织架构做一些拆分规划。</li> \n </ul> \n <p><strong>第二种</strong>：通过<code>Group</code>实现。</p> \n <ul> \n  <li><em>优点</em>：通过<code>Group</code>按环境讲各个应用的配置隔离开。可以非常方便的利用<code>Data ID</code>和<code>Group</code>的搜索功能，分别从应用纬度和环境纬度来查看配置。</li> \n  <li><em>缺点</em>：由于会占用<code>Group</code>纬度，所以需要对<code>Group</code>的使用做好规划，毕竟与业务上的一些配置分组起冲突等问题。</li> \n  <li><em>建议</em>：这种方式虽然结构上比上一种更好一些，但是依然可能会有一些混乱，主要是在<code>Group</code>的管理上要做好规划和控制。</li> \n </ul> \n <p><strong>第三种</strong>：通过<code>Namespace</code>实现。</p> \n <ul> \n  <li><em>优点</em>：官方建议的方式，通过<code>Namespace</code>来区分不同的环境，释放了<code>Group</code>的自由度，这样可以让<code>Group</code>的使用专注于做业务层面的分组管理。同时，Nacos控制页面上对于<code>Namespace</code>也做了分组展示，不需要搜索，就可以隔离开不同的环境配置，非常易用。</li> \n  <li><em>缺点</em>：没有啥缺点，可能就是多引入一个概念，需要用户去理解吧。</li> \n  <li><em>建议</em>：直接用这种方式长远上来说会比较省心。虽然可能对小团队而言，项目不多，第一第二方式也够了，但是万一后面做大了呢？</li> \n </ul> \n <blockquote> \n  <p>注意：不论用哪一种方式实现。对于指定环境的配置（<code>spring.profiles.active=DEV</code>、<code>spring.cloud.nacos.config.group=DEV_GROUP</code>、<code>spring.cloud.nacos.config.namespace=83eed625-d166-4619-b923-93df2088883a</code>），都不要配置在应用的<code>bootstrap.properties</code>中。而是在发布脚本的启动命令中，用<code>-Dspring.profiles.active=DEV</code>的方式来动态指定，会更加灵活！。</p> \n </blockquote> \n <h2>参考资料</h2> \n <ul> \n  <li><a href=\"https://nacos.io/zh-cn/docs/what-is-nacos.html\">Nacos官方文档</a></li> \n </ul> \n <h2>代码示例</h2> \n <p>本文示例读者可以通过查看下面仓库的中的<code>alibaba-nacos-config-client</code>项目：</p> \n <ul> \n  <li><em>Github：</em><a href=\"https://github.com/dyc87112/SpringCloud-Learning/tree/master/4-Finchley\">https://github.com/dyc87112/SpringCloud-Learning/</a></li> \n  <li><em>Gitee：</em><a href=\"https://gitee.com/didispace/SpringCloud-Learning/tree/master/4-Finchley\">https://gitee.com/didispace/SpringCloud-Learning/</a></li> \n </ul> \n <p><strong>如果您对这些感兴趣，欢迎star、follow、收藏、转发给予支持！</strong></p> \n <h2>以下专题教程也许您会有兴趣</h2> \n <ul> \n  <li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">Spring Boot基础教程</a></li> \n  <li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">Spring Cloud基础教程</a></li> \n </ul> \n</div>',NULL,'2020-02-02 18:50:42',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921696298323968',NULL,NULL,' Spring MVC体系结构和处理请求控制器   ','<div class=\"content\" id=\"articleContent\"> \n <h1>Spring MVC体系结构和处理请求控制器</h1> \n <h2>一：MVC设计模式：</h2> \n <p>（1.）数据访问接口：DAO层 （2.）处理业务逻辑层：Service层 （3.）数据实体：POJO （4.）负责前段请求接受并处理：Service （5.）负责前端页面展示：JSP</p> \n <p>这种构架模式就是MVC设计模式，它是软件工程的一种软件架构模式。它强制性的是软件系统的输入，处理和输出的分开，把软件系统分三个基本部分：模型（Model）,视图（View）控制器（Controller） 解析： 视图（View）：负责格式化数据并把它们呈现给客户 控制器（Controller）：负责接收并转发请求，做出响应返回给客户 模型（Model）:模型对象拥有最多的处理任务，是应用程序的主体部分，负责处理和实现数据</p> \n <h2>二：MVC两种模式：</h2> \n <p>JSP MODEL1：当业务流程较为简单的时候，可以把控制器的功能交给视图来实现，这种模式统称为 JSP MODEL1 JSP MODEL2:相当于JSP MODEL1 当业务流程复杂的时候，即需要把业务流程交给控制器来实现，JSP专注视图的展现即可 。 MVC处理过程 （1.）首先视图是提供系统与用户交互界面，并发送用户给控制器。 （2.）控制器接收用户请求，并决定改调用哪个模型来处理 （3.）模型根据用户请求进行相应的业务逻辑处理，并返回处理结果 （4.）控制器根据返回处理结果，调用相应的视图格式化模型返回的数据，并通过视图呈现给客户。</p> \n <p>MVC优缺点： 优点： （1.）多视图共享一个模型，大大提高代码的可用性 （2.）MVC三个模块相互独立，松耦合构架 （3.）控制器提高应用程序和灵活性和可配性 （4.）有利益软件工程化管理 缺点： （1.）原理复杂 （2.）增加了系统结构和实现的复杂性 （3）.视图对模型数据的低效访问</p> \n <h2>三：Spring MVC框架介绍流程图</h2> \n <p>1：Spring MVC 环境搭建 （1.）引入jar文件</p> \n <p>（2.）在web.xml中配置Servlet</p> \n <p>（3.）创建SpringMVC配置文件（springmvc-servlet.xml）（处理请求的控制器）</p> \n <p>（4）.创建Controller</p> \n <p>（5.）创建view</p> \n <p>（6.）部署运行 （7.）更改HandlerMapping（处理器映射）</p> \n <p>&lt;property name=”suffix”value=”.jsp”/&gt; &lt;/bean&gt; &lt;/beans&gt;</p> \n <h2>四：</h2> \n <ol> \n  <li>Spring Mvc框架体系结构请求处理流程</li> \n  <li></li> \n </ol> \n <p>（1.）首先用户发送请求到前端控制器（dispatcherServlet）前端控制器根据请求信息，来决定选择哪个控制页面（Controller）进行处理，并把请求委托给他，即service控制器的控制逻辑部分D （2.）页面控制器接收到请求后，进行业务处理，处理完成返回一个Modelandview（模型数据名和逻辑视图名） （3.）前端控制器收回控制器，然后根据逻辑视图名，选择相应的正在视图名，并把模型数据传入以便将视图渲染展示 （4.）前端控制器再次收回控制器，将相应结果返回给客户，至此整个流程结束</p> \n <ol start=\"3\"> \n  <li>Spring MVC框架的体系结构</li> \n </ol> \n <p>（1.）客户端发出HTTP请求，web应用服务器接收此请求，若匹配DispatcherService的请求映射路径（在web.xml中指定）则web容器将根据请求交给DispatherService处理（dkz） （2.）DispatherService接收到该请求后将根据请求的信息（包括URL，请求参数，http方法等及HandlerMapping配置（在&lt;serviceName&gt;-servlet.xml中配置），找到处理请求的方法K （3.）当DispatherService根据HandlerMapping找到相应当前请求的Handler之后，通过HandlerAdater对handler进行封装，在以统一的适配器接口调用Handler.HandlerAdapter,可以理解为具体使用Handler来干活的人。三个方法</p> \n <pre><code>Supports(Object handler)方法，判断是否可以使用某个Handler\nHandle方法：具体使用Handler干活\ngetLastModified方法，获取资源的Last-Modified\n</code></pre> \n <p>（4.）在请求信息达到真正调用Handler处理方法之前的这段时间内，SpringMvc还完成了很多工作，他会将请求信息以一定的方式转换并绑定到请求方法的入参中，对于入参的对象会进行数据转换，格式化及数据校检等，这些都做完后，最后才真正的调用Handler处理方法进行相应的数据逻辑处理。 （5.）处理器完成业务处理之后将返回一个ModelAndView对象给DispatcherServlet,ModelAndView对象包含了逻辑视图名和模型数据信息。 （6.）ModelAndView对象中包含的是“逻辑视图名”，而非真正的视图对象，DispatherService会通过ViewResolver将逻辑视图名解析为真正的视图对象，View当然负责数据展示的视图可以为jsp,xml,pdf,json等多种数据格式， （7.）当得到最后的视图对象后View后，DispatherService会使用ModelAndView对象中的模型数据对View进行视图渲染。 （8.）最终客户端获得响应消息，根据配置，可以是普通的HTML页面，也可以是一个xml，或者是json格式数据等。Z</p> \n <ol start=\"4\"> \n  <li>Spring MVC框架的特点 （1.）清晰的角色划分。 （2.）灵活的功能配置 （3.）提供了大量的控制器接口和实现类 （4.）真正做到与View层实现无关（JSP，Velocity，xslt等） （5.）国际化支持 （6.）面向接口编程 （7.）提供了web应用开发的一整套流程</li> \n </ol> \n <h2>五：</h2> \n <p>1.参数传递：最简单的方法就是将Controller方法中参数直接入参 @RequestMapping映射： （1.）通过请求URL进行映射D （2.）通过请求参数，请求方法进行映射 2.参数传递（Controller to View） （1.）ModelAndView常用方法 处理器处理的方法返回值若为ModelAndView,则即包括视图信息，又包括模型数据信息，有了该对象之后，Spring mvc 就可以对视图模型就行数据渲染。 *.添加模型数据</p> \n <pre><code>*.设置视图\n</code></pre> \n <p>2.Model 除了可以使用ModelAndView对象来返回模型数据外，我们还可以使用Spring mvc 提供的Model对象来完成模型数据的传递。K 3.Map 通过前面对于Model和ModelAndView对象的学习，我们还能使用Spring MVC 的Model其实就是一个map的数据结构，可以用map作为入参处理</p> \n <p>4.@ModelAttribute 若希望将入参的数据对象放入数据模型中去，就需要在相应入参前使用此注解，再此我们只做简单了解。 5.@SessionAttributes 此注解可以模型中属性存入httpSession中，以便在多个请求之间共享该属性，只做简单了解。Z</p> \n <h2>六：视图解析器</h2> \n <ol> \n  <li>所有视图解析器都实现了ViewResolver接口如下：</li> \n </ol> \n <p>2.Spring mvc通过视图解析器来完成视图解析的工作，把控制器的处理方法返回的逻辑视图名，解析成一个真正的视图对象</p> \n</div>',NULL,'2020-02-02 18:50:46',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921712693858304',NULL,NULL,' 初始MyBatis   ','<div class=\"content\" id=\"articleContent\"> \n <h1>初始MyBatis</h1> \n <h3>1. 框架的概念：</h3> \n <p>框架是一个提供可重复的功用结构的半成品。它为我们构建新的应用程序提供了极大的便利，一方面提供了可以拿来就用的工具，更重要的是提供了可重用的设计。D</p> \n <h3>2. 框架技术的优势：</h3> \n <p>1.不在考虑公众问题框架已经帮我们做好了 <a href=\"http://\">输入链接说明</a> 2.可以专心用于业务逻辑，保证核心业务的开发和质量<br> 3.结构统一便于学习和维护<br> 4.框架集中了前人的经验，可以帮助新手写出稳定新能优良且结构优美的高质量程序K</p> \n <h3>3.主框架的介绍：</h3> \n <pre><code>1.Strus 2框架\n2.Hibernate框架\n3.Spring 框架\n4.Spring MVC框架\n5.MyBatis 框架Z\n</code></pre> \n <h3>4.数据持久化概念：</h3> \n <pre><code>数据持久化是将内存中的数据模型转换为储存类型，以及将储存类型转换为\n内存中的数据模型的统称，：（半自动化是实体类和SQL语句建立的映射关系）\n</code></pre> \n <h3>5.MyBatis框架简介：</h3> \n <p>MyBatis是一个开源的数据持久层框架。它内部封装了JDBC访问数据的操作，支持普通的SQL查询，储存过程和高级映射，几乎消除的JDBC代码和参数的手工设置以及结果集的搜索</p> \n <h3>6.什么是ORM:</h3> \n <pre><code>ORM(Object/Relational Mapping)即对象/映射关系，是一种数据持久化技术。\n</code></pre> \n <h3>7.MyBatis环境搭建步骤：</h3> \n <pre><code>1.下载需要的jar文件\n2.部署jar文件\n3.创建MyBatis核心配置文件configuration.xml(全局配置)\n4.创建持久化类(POJO)和SQL映射文件\n5.\n</code></pre> \n <h3>8.MyBatis的优缺点</h3> \n <pre><code>1.优点：\n（1）与JDBC相比减少了百分之50代码量\n（2）是最简单的持久化框架，小巧并且简单易学。\n</code></pre> \n <p>（3）相当灵活不会对应用程序或者数据库的现有设计加强任何影响，SQL写在xml里从程序代码中彻底分离，降低耦合度，便于统一管理和优化，并可重用 （4）提供xml标签，支持写动态SQL语句 （5）提供映射标签，支持对象与数据库的ORM字段关系映射</p> \n <ol start=\"3\"> \n  <li>缺点： （1） SQL语句编写工作量大，对开发人员编写SQL语句有一定能力要求。 （2） SQL语句依赖于数据库导致数据库移植性差，不能随意更换数据库。</li> \n </ol> \n <h3>9.MyBatis 基本要素---核心对象</h3> \n <p>1.SqlSessionFactoryBuilder作用：负责构建SqlSessionFactory，并且提供多个build()方法的重载 .SqlSessionFactoryBuilder的生命周期和作用域： 最大特点就是用过即丢，一旦创建了SqlSessionFactory对象之后这个类就不在需要了，因此SqlSessionFactoryBuilder的最佳作用范围就是存在于方法体内，也就是局部变量而已。</p> \n <p>2.SqlSessionFactory的作用： 就是创建SqlSession实例工厂 SqlSessionFactoryBuilder 的生命周期和作用域： 一旦创建了就在整个应用运行过程中始终存在，没有理由去销毁或者再次创建它，并且运行中不建议多次创建，因此最佳作用域是Application跟着应用的生命周期一同存在。</p> \n <p>3.SqlSession 作用： 用于执行持久化的操作对象，类似于JDBC中的Connection。它提供了面向数据库执行SQL语句的所有方法，可以通过SqlSession实例直接运行已映射的SQL语句 SqlSession 的生命周期和作用域： 对应着一次数据库会话。由于数据库会话不是永久，因此生命周期也不应该是持久的，相反在每次访问数据库时都要创建它，（可以执行多次，但是一旦关闭就需要重新创建，）创建SqlSession的地方只有一个，就是SqlSessionFactory对象的openSession()方法。 SqlSession的两种使用方式： （1） 通过SqlSession实例来直接执行已映射的SQL语句。通过调用selectList（）方法执行 （2） 基于mapper接口方式操作数据。（提供接口方法getUserList()）</p> \n <h3>10.MyBatis 基本要素—核心配置文件：</h3> \n <pre><code>（1）properties元素：\n		描述的外部化，可替代性属性，（具体方法见（P28））。\n</code></pre> \n <p>（2）settings元素： 设置一些重要的设置选项，用于设置和改变MyBatis运行中的行为 （1） cacheEnabled：对在此配置文件下所有cache进行全局性开/关设置 （2） lazyLoadingEnabled:全局性设置赖加载，如果设置为false则所有相关联的都会被初始化加载 （3） autoMappingBehavior:MaBatis对于resultMap自动映射的匹配级别（NONE/PARTIAL/FULL） （3） typeAliases元素： 作用是配置类型别名，通过与MyBatis的SQL映射文件相关联减少输入多余完整类名，以简化操作 （4） environments元素： 可以配置多套运行环境，如开发环境，测试环境，生产环境可以灵活的配置，从而将SQL语句映射应用到不同的数据库环境上，可以通过这个元素来配置。必须是唯一的运行环境每个数据库对于这一个SqlSessionFactory实例的。见（P30下方） （5） mappers元素: mappers映射器，用来定义SQL的映射语句，我们只需要高MyBatis去哪里找到这些SQL语句，即去哪里找相应SQL映射文件，可以使用类资源路径或URL等见</p> \n</div>',NULL,'2020-02-02 18:50:50',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223921732159623168',NULL,NULL,' SSM框架——详细整合教程（Spring+SpringMVC+MyBatis）  ','<div class=\"content\" id=\"articleContent\"> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">使用<span style=\"font-family: \'Times New Roman\';\">SSM</span><span style=\"font-family: 宋体;\">（</span>Spring<span style=\"font-family: 宋体;\">、</span><span style=\"font-family: \'Times New Roman\';\">SpringMVC</span><span style=\"font-family: 宋体;\">和</span><span style=\"font-family: \'Times New Roman\';\">Mybatis</span>）已经有三个多月了，项目在技术上已经没有什么难点了，基于现有的技术就可以实现想要的功能，当然肯定有很多可以改进的地方。之前没有记录<span style=\"font-family: \'Times New Roman\';\">SSM</span><span style=\"font-family: 宋体;\">整合的过程，</span>这次刚刚好基于自己的一个小项目重新搭建了一次，而且比项目搭建的要更好一些。以前解决问题的过程和方法并没有及时记录，以后在自己的小项目中遇到我再整理分享一下。<span style=\"color: rgb(0, 0, 255);\">这次</span><span style=\"color: rgb(0, 0, 255);\">，</span><span style=\"color: rgb(0, 0, 255);\">先说说</span><span style=\"color: rgb(0, 0, 255);\">三大框架整合过程</span>。个人认为使用框架并不是很难，关键要理解其思想，这对于我们提高编程水平很有帮助。不过，如果用都不会，谈思想就变成纸上谈兵了！！！<span style=\"background-color: rgb(255, 255, 0);\">先技术，再思想。实践出真知。</span>（可通过图片水印查看博客地址）</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <span id=\"OSC_h1_1\"></span> \n <h1><a name=\"t0\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t0\" rel=\"nofollow\"></a>1、基本概念</h1> \n <span id=\"OSC_h2_2\"></span> \n <h2><a name=\"t1\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t1\" rel=\"nofollow\"></a>1.1、Spring</h2> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"font-size: 12px;\">Spring<span style=\"font-family: 宋体;\">是一个开源框架，</span><span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">是于</span><span style=\"font-family: \'Times New Roman\';\">2003&nbsp;</span><span style=\"font-family: 宋体;\">年兴起的一个轻量级的</span><span style=\"font-family: \'Times New Roman\';\">Java&nbsp;</span><span style=\"font-family: 宋体;\">开发框架，由</span><span style=\"font-family: \'Times New Roman\';\">Rod&nbsp;Johnson&nbsp;</span><span style=\"font-family: 宋体;\">在其著作</span><span style=\"font-family: \'Times New Roman\';\">Expert&nbsp;One-On-One&nbsp;J2EE&nbsp;Development&nbsp;and&nbsp;Design</span><span style=\"font-family: 宋体;\">中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。</span><span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">使用基本的</span><span style=\"font-family: \'Times New Roman\';\">JavaBean</span><span style=\"font-family: 宋体;\">来完成以前只可能由</span><span style=\"font-family: \'Times New Roman\';\">EJB</span><span style=\"font-family: 宋体;\">完成的事情。然而，</span><span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何</span><span style=\"font-family: \'Times New Roman\';\">Java</span><span style=\"font-family: 宋体;\">应用都可以从</span><span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">中受益。</span>&nbsp;简单来说，<span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">是一个轻量级的控制反转（</span><span style=\"font-family: \'Times New Roman\';\">IoC</span><span style=\"font-family: 宋体;\">）和面向切面（</span><span style=\"font-family: \'Times New Roman\';\">AOP</span><span style=\"font-family: 宋体;\">）的容器框架。</span></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><span style=\"font-family: 宋体;\"><br></span></span></p> \n <span id=\"OSC_h2_3\"></span> \n <h2><a name=\"t2\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t2\" rel=\"nofollow\"></a>1.2、SpringMVC</h2> \n <p style=\"margin-top: 0pt; margin-bottom: 0pt; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 10.5pt;\">&nbsp; &nbsp; &nbsp;</span></p> \n <p style=\"margin-top: 0pt; margin-bottom: 0pt; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; &nbsp; Spring&nbsp;MVC<span style=\"font-family: 宋体;\">属于</span>SpringFrameWork<span style=\"font-family: 宋体;\">的后续产品，已经融合在</span>Spring&nbsp;Web&nbsp;Flow<span style=\"font-family: 宋体;\">里面。</span>Spring&nbsp;MVC&nbsp;<span style=\"font-family: 宋体;\">分离了</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/122229.htm\" rel=\"nofollow\">控制器</a>、模型<a target=\"_blank\" href=\"http://baike.baidu.com/view/2387.htm\" rel=\"nofollow\">对象</a>、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。</span></p> \n <p style=\"margin-top: 0pt; margin-bottom: 0pt; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><br></span></p> \n <span id=\"OSC_h2_4\"></span> \n <h2><a name=\"t3\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t3\" rel=\"nofollow\"></a>1.3、MyBatis</h2> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0pt; margin-bottom: 0pt; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 10.5pt;\">&nbsp; &nbsp; &nbsp; &nbsp;</span><span style=\"font-size: 12px;\">MyBatis&nbsp;<span style=\"font-family: 宋体;\">本是</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/28283.htm\" rel=\"nofollow\">apache</a>的一个开源项目<a target=\"_blank\" href=\"http://baike.baidu.com/view/628102.htm\" rel=\"nofollow\">iBatis</a>,&nbsp;2010<span style=\"font-family: 宋体;\">年这个项目由</span>apache&nbsp;software&nbsp;foundation&nbsp;<span style=\"font-family: 宋体;\">迁移到了</span>google&nbsp;code<span style=\"font-family: 宋体;\">，并且改名为</span>MyBatis&nbsp;<span style=\"font-family: 宋体;\">。</span><span style=\"font-family: 宋体;\">MyBatis</span>是一个基于Java<span style=\"font-family: 宋体;\">的</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/198047.htm\" rel=\"nofollow\">持久层</a>框架。iBATIS<span style=\"font-family: 宋体;\">提供的</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/198047.htm\" rel=\"nofollow\">持久层</a>框架包括SQL&nbsp;Maps<span style=\"font-family: 宋体;\">和</span>Data&nbsp;Access&nbsp;Objects<span style=\"font-family: 宋体;\">（</span>DAO<span style=\"font-family: 宋体;\">）</span>MyBatis&nbsp;<span style=\"font-family: 宋体;\">消除了几乎所有的</span>JDBC<span style=\"font-family: 宋体;\">代码和参数的手工设置以及结果集的检索。</span>MyBatis&nbsp;<span style=\"font-family: 宋体;\">使用简单的&nbsp;</span>XML<span style=\"font-family: 宋体;\">或注解用于配置和原始映射，将接口和&nbsp;</span>Java&nbsp;<span style=\"font-family: 宋体;\">的</span>POJOs<span style=\"font-family: 宋体;\">（</span>Plain&nbsp;Old&nbsp;Java&nbsp;Objects<span style=\"font-family: 宋体;\">，普通的&nbsp;</span>Java<span style=\"font-family: 宋体;\">对象）映射成数据库中的记录。</span></span></p> \n <p style=\"margin-top: 0pt; margin-bottom: 0pt; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><span style=\"font-family: 宋体;\"><br></span></span></p> \n <p style=\"margin-top: 0pt; margin-bottom: 0pt; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><span style=\"font-family: 宋体;\"><br></span></span></p> \n <span id=\"OSC_h1_5\"></span> \n <h1><a name=\"t4\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t4\" rel=\"nofollow\"></a>2、开发环境搭建</h1> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">如果需要，参看之前的博文：<span style=\"color: rgb(0, 0, 255);\"><a target=\"_blank\" href=\"http://blog.csdn.net/zhshulin/article/details/30779873\" rel=\"nofollow\">http://blog.csdn.net/zhshulin/article/details/30779873</a></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <span id=\"OSC_h1_6\"></span> \n <h1><a name=\"t5\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t5\" rel=\"nofollow\"></a>3、Maven Web项目创建</h1> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">如果需要，参看之前的博文：<span style=\"color: rgb(0, 0, 255);\"><a target=\"_blank\" href=\"http://blog.csdn.net/zhshulin/article/details/37921705\" rel=\"nofollow\">http://blog.csdn.net/zhshulin/article/details/37921705</a></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <span id=\"OSC_h1_7\"></span> \n <h1><a name=\"t6\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t6\" rel=\"nofollow\"></a>4、SSM整合</h1> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp;&nbsp;</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; &nbsp; 下面主要介绍三大框架的整合，至于环境的搭建以及项目的创建，参看上面的博文。这次整合我分了<span style=\"background-color: rgb(255, 255, 0);\">2<span style=\"font-family: 宋体;\">个配置文件</span></span>，分别是<span style=\"font-family: \'Times New Roman\';\">spring-mybatis.xml</span><span style=\"font-family: 宋体;\">，包含</span><span style=\"font-family: \'Times New Roman\';\">spring</span><span style=\"font-family: 宋体;\">和</span><span style=\"font-family: \'Times New Roman\';\">mybatis</span><span style=\"font-family: 宋体;\">的配置文件，还有个是</span><span style=\"font-family: \'Times New Roman\';\">spring-mvc</span><span style=\"font-family: 宋体;\">的配置文件，此外有</span><span style=\"background-color: rgb(255, 255, 0);\">2<span style=\"font-family: 宋体;\">个资源文件</span></span>：<span style=\"font-family: \'Times New Roman\';\">jdbc.propertis</span><span style=\"font-family: 宋体;\">和</span><span style=\"font-family: \'Times New Roman\';\">log4j.properties</span><span style=\"font-family: 宋体;\">。完整目录结构如下（最后附上源码下载地址，不建议直接使用源码，因为此教程已经有了全部代码）：</span></span></p> \n <p><img src=\"http://static.oschina.net/uploads/img/201507/17163308_zzVS.jpg\" alt=\"\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(0, 0, 255);\">使用框架都是较新的版本</span>：</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp;Spring&nbsp;4.0.2&nbsp;RELEASE</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp;Spring&nbsp;MVC&nbsp;4.0.2&nbsp;RELEASE</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp;MyBatis&nbsp;3.2.6</p> \n <p><br></p> \n <span id=\"OSC_h2_8\"></span> \n <h2><a name=\"t7\" rel=\"nofollow\"></a><a target=\"_blank\" name=\"t7\" rel=\"nofollow\"></a>4.1、Maven引入需要的JAR包</h2> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"font-size: 12px;\">为了方便后面说的时候不需要引入JAR包，我这里<span style=\"background-color: rgb(255, 255, 153);\">直接给出所有需要的JAR包，这都是基本的JAR包</span>，每个包的是干什么的都有注释，就不再多说了。</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(255, 102, 102);\">pom.xml</span></p> \n <pre class=\"brush:xml;toolbar: true; auto-links: false;\"><code>&lt;properties&gt;\n		&lt;!--&nbsp;spring版本号&nbsp;--&gt;\n		&lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt;\n		&lt;!--&nbsp;mybatis版本号&nbsp;--&gt;\n		&lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt;\n		&lt;!--&nbsp;log4j日志文件管理包版本&nbsp;--&gt;\n		&lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;\n		&lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;\n	&lt;/properties&gt;\n\n	&lt;dependencies&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;junit&lt;/groupId&gt;\n			&lt;artifactId&gt;junit&lt;/artifactId&gt;\n			&lt;version&gt;4.11&lt;/version&gt;\n			&lt;!--&nbsp;表示开发的时候引入，发布的时候不会加载此包&nbsp;--&gt;\n			&lt;scope&gt;test&lt;/scope&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;spring核心包&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n			&lt;version&gt;${spring.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;mybatis核心包&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n			&lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n			&lt;version&gt;${mybatis.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;mybatis/spring包&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n			&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n			&lt;version&gt;1.2.2&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;导入java&nbsp;ee&nbsp;jar&nbsp;包&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;javax&lt;/groupId&gt;\n			&lt;artifactId&gt;javaee-api&lt;/artifactId&gt;\n			&lt;version&gt;7.0&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;导入Mysql数据库链接jar包&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;mysql&lt;/groupId&gt;\n			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n			&lt;version&gt;5.1.30&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;导入dbcp的jar包，用来在applicationContext.xml中配置数据库&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;\n			&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;\n			&lt;version&gt;1.2.2&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;JSTL标签类&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;jstl&lt;/groupId&gt;\n			&lt;artifactId&gt;jstl&lt;/artifactId&gt;\n			&lt;version&gt;1.2&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;日志文件管理包&nbsp;--&gt;\n		&lt;!--&nbsp;log&nbsp;start&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;log4j&lt;/groupId&gt;\n			&lt;artifactId&gt;log4j&lt;/artifactId&gt;\n			&lt;version&gt;${log4j.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		\n		\n		&lt;!--&nbsp;格式化对象，方便输出日志&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n			&lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n			&lt;version&gt;1.1.41&lt;/version&gt;\n		&lt;/dependency&gt;\n\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n			&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n			&lt;version&gt;${slf4j.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n			&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n			&lt;version&gt;${slf4j.version}&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;log&nbsp;end&nbsp;--&gt;\n		&lt;!--&nbsp;映入JSON&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt;\n			&lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt;\n			&lt;version&gt;1.9.13&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;!--&nbsp;上传组件包&nbsp;--&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;\n			&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;\n			&lt;version&gt;1.3.1&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;commons-io&lt;/groupId&gt;\n			&lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n			&lt;version&gt;2.4&lt;/version&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;commons-codec&lt;/groupId&gt;\n			&lt;artifactId&gt;commons-codec&lt;/artifactId&gt;\n			&lt;version&gt;1.9&lt;/version&gt;\n		&lt;/dependency&gt;\n		\n		\n	&lt;/dependencies&gt;</code></pre> \n <p></p> \n <span id=\"OSC_h2_9\"></span> \n <h2>4.2、Spring与MyBatis的整合</h2> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">所有需要的<span style=\"font-family: \'Times New Roman\';\">JAR</span><span style=\"font-family: 宋体;\">包都引入以后，首先进行</span><span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">与</span><span style=\"font-family: \'Times New Roman\';\">MyBatis</span><span style=\"font-family: 宋体;\">的整合，然后再进行</span><span style=\"font-family: \'Times New Roman\';\">JUnit</span><span style=\"font-family: 宋体;\">测试，先看一个项目结构图：</span></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;\"><span style=\"font-size: 12px;\"><span style=\"font-family: 宋体;\"><img src=\"http://static.oschina.net/uploads/img/201507/17163308_aYll.jpg\" alt=\"\"><br></span></span></p> \n <span id=\"OSC_h3_10\"></span> \n <h3><a name=\"t9\" rel=\"nofollow\"></a>4.2.1、建立JDBC属性文件</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: rgb(255, 255, 153);\">jdbc.properties</span>（文件编码修改为<span style=\"font-family: \'Times New Roman\';\">utf-8</span><span style=\"font-family: 宋体;\">）</span></p> \n <pre class=\"brush:xml;toolbar: true; auto-links: false;\"><code>driver=com.mysql.jdbc.Driver\nurl=jdbc:mysql://10.221.10.111:8080/db_zsl\nusername=demao\npassword=demao\n#定义初始连接数\ninitialSize=0\n#定义最大连接数\nmaxActive=20\n#定义最大空闲\nmaxIdle=20\n#定义最小空闲\nminIdle=1\n#定义最长等待时间\nmaxWait=60000</code></pre> \n <p></p> \n <span id=\"OSC_h3_11\"></span> \n <h3><a name=\"t10\" rel=\"nofollow\"></a>4.2.2、建立spring-mybatis.xml配置文件</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style=\"font-size: 12px;\">这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是<span style=\"background-color: rgb(255, 255, 153);\">自动扫描，自动注入，配置数据库</span>。注释也很详细，大家看看就明白了。</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: rgb(255, 255, 153);\">spring-mybatis.xml</span></p> \n <pre class=\"brush:xml;toolbar: true; auto-links: false;\"><code>&lt;?xml&nbsp;version=\"1.0\"&nbsp;encoding=\"UTF-8\"?&gt;\n&lt;beans&nbsp;xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&nbsp;xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/context&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/context/spring-context-3.1.xsd&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/mvc&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt;\n	&lt;!--&nbsp;自动扫描&nbsp;--&gt;\n	&lt;context:component-scan&nbsp;base-package=\"com.cn.hnust\"&nbsp;/&gt;\n	&lt;!--&nbsp;引入配置文件&nbsp;--&gt;\n	&lt;bean&nbsp;id=\"propertyConfigurer\"\n		class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt;\n		&lt;property&nbsp;name=\"location\"&nbsp;value=\"classpath:jdbc.properties\"&nbsp;/&gt;\n	&lt;/bean&gt;\n\n	&lt;bean&nbsp;id=\"dataSource\"&nbsp;class=\"org.apache.commons.dbcp.BasicDataSource\"\n		destroy-method=\"close\"&gt;\n		&lt;property&nbsp;name=\"driverClassName\"&nbsp;value=\"${driver}\"&nbsp;/&gt;\n		&lt;property&nbsp;name=\"url\"&nbsp;value=\"${url}\"&nbsp;/&gt;\n		&lt;property&nbsp;name=\"username\"&nbsp;value=\"${username}\"&nbsp;/&gt;\n		&lt;property&nbsp;name=\"password\"&nbsp;value=\"${password}\"&nbsp;/&gt;\n		&lt;!--&nbsp;初始化连接大小&nbsp;--&gt;\n		&lt;property&nbsp;name=\"initialSize\"&nbsp;value=\"${initialSize}\"&gt;&lt;/property&gt;\n		&lt;!--&nbsp;连接池最大数量&nbsp;--&gt;\n		&lt;property&nbsp;name=\"maxActive\"&nbsp;value=\"${maxActive}\"&gt;&lt;/property&gt;\n		&lt;!--&nbsp;连接池最大空闲&nbsp;--&gt;\n		&lt;property&nbsp;name=\"maxIdle\"&nbsp;value=\"${maxIdle}\"&gt;&lt;/property&gt;\n		&lt;!--&nbsp;连接池最小空闲&nbsp;--&gt;\n		&lt;property&nbsp;name=\"minIdle\"&nbsp;value=\"${minIdle}\"&gt;&lt;/property&gt;\n		&lt;!--&nbsp;获取连接最大等待时间&nbsp;--&gt;\n		&lt;property&nbsp;name=\"maxWait\"&nbsp;value=\"${maxWait}\"&gt;&lt;/property&gt;\n	&lt;/bean&gt;\n\n	&lt;!--&nbsp;spring和MyBatis完美整合，不需要mybatis的配置映射文件&nbsp;--&gt;\n	&lt;bean&nbsp;id=\"sqlSessionFactory\"&nbsp;class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n		&lt;property&nbsp;name=\"dataSource\"&nbsp;ref=\"dataSource\"&nbsp;/&gt;\n		&lt;!--&nbsp;自动扫描mapping.xml文件&nbsp;--&gt;\n		&lt;property&nbsp;name=\"mapperLocations\"&nbsp;value=\"classpath:com/cn/hnust/mapping/*.xml\"&gt;&lt;/property&gt;\n	&lt;/bean&gt;\n\n	&lt;!--&nbsp;DAO接口所在包名，Spring会自动查找其下的类&nbsp;--&gt;\n	&lt;bean&nbsp;class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n		&lt;property&nbsp;name=\"basePackage\"&nbsp;value=\"com.cn.hnust.dao\"&nbsp;/&gt;\n		&lt;property&nbsp;name=\"sqlSessionFactoryBeanName\"&nbsp;value=\"sqlSessionFactory\"&gt;&lt;/property&gt;\n	&lt;/bean&gt;\n\n	&lt;!--&nbsp;(事务管理)transaction&nbsp;manager,&nbsp;use&nbsp;JtaTransactionManager&nbsp;for&nbsp;global&nbsp;tx&nbsp;--&gt;\n	&lt;bean&nbsp;id=\"transactionManager\"\n		class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n		&lt;property&nbsp;name=\"dataSource\"&nbsp;ref=\"dataSource\"&nbsp;/&gt;\n	&lt;/bean&gt;\n\n&lt;/beans&gt;</code></pre> \n <p></p> \n <span id=\"OSC_h3_12\"></span> \n <h3><a name=\"t11\" rel=\"nofollow\"></a>4.2.3、Log4j的配置</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; 为了方便调试，一般都会使用日志来输出信息，<span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">Log4j是</span><a target=\"_blank\" href=\"http://baike.baidu.com/subview/28283/5418753.htm\" rel=\"nofollow\">Apache</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">的一个开放源代码项目，通过使用Log4j，我们可以控制</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/269351.htm\" rel=\"nofollow\">日志</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">信息输送的目的地是</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/135167.htm\" rel=\"nofollow\">控制台</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">、文件、</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/25309.htm\" rel=\"nofollow\">GUI</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">组件，甚至是套接口服务器、</span><a target=\"_blank\" href=\"http://baike.baidu.com/subview/378/5113303.htm\" rel=\"nofollow\">NT</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">的事件记录器、</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/8095.htm\" rel=\"nofollow\">UNIX</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">&nbsp;</span><a target=\"_blank\" href=\"http://baike.baidu.com/view/1614723.htm\" rel=\"nofollow\">Syslog</a><a target=\"_blank\" href=\"http://baike.baidu.com/view/53123.htm\" rel=\"nofollow\">守护进程</a><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; line-height: 24px; text-indent: 28px;\">等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</span></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; Log4j<span style=\"font-family: 宋体;\">的配置很简单，而且也是<span style=\"background-color: rgb(255, 255, 153);\">通用的</span>，下面<span style=\"background-color: rgb(153, 255, 153);\">给出一个基本的配置</span>，换到其他项目中也无需做多大的调整，<span style=\"background-color: rgb(153, 255, 153);\">如果想做调整</span>或者想了解</span><span style=\"font-family: \'Times New Roman\';\">Log4j</span><span style=\"font-family: 宋体;\">的各种配置，参看我<span style=\"background-color: rgb(255, 255, 204);\">转载的一篇博文</span>，很详细：</span></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><a target=\"_blank\" href=\"http://blog.csdn.net/zhshulin/article/details/37937365\" rel=\"nofollow\"><span style=\"color: rgb(0, 0, 255);\"><span style=\"font-size: 12px;\">http://blog.csdn.net/zhshulin/article/details/37937365</span></span></a></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">下面给出配置文件目录：</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;\"><img src=\"http://static.oschina.net/uploads/img/201507/17163308_vAFb.jpg\" alt=\"\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: rgb(255, 255, 51);\">log4j.properties</span><span style=\"background-color: inherit; color: rgb(255, 255, 255); line-height: 23px; font-family: 微软雅黑, Verdana, sans-serif, 宋体; font-size: 12.5px;\">p]&nbsp;[%d{yyyy-MM-dd&nbsp;HH\\:mm\\:ss}][%c]%m%n &nbsp;</span></p> \n <pre class=\"brush:xml;toolbar: true; auto-links: false;\"><code>#定义LOG输出级别\nlog4j.rootLogger=INFO,Console,File\n#定义日志输出目的地为控制台\nlog4j.appender.Console=org.apache.log4j.ConsoleAppender\nlog4j.appender.Console.Target=System.out\n#可以灵活地指定日志输出格式，下面一行是指定具体的格式\nlog4j.appender.Console.layout&nbsp;=&nbsp;org.apache.log4j.PatternLayout\nlog4j.appender.Console.layout.ConversionPattern=[%c]&nbsp;-&nbsp;%m%n\n\n#文件大小到达指定尺寸的时候产生一个新的文件\nlog4j.appender.File&nbsp;=&nbsp;org.apache.log4j.RollingFileAppender\n#指定输出目录\nlog4j.appender.File.File&nbsp;=&nbsp;logs/ssm.log\n#定义文件最大大小\nlog4j.appender.File.MaxFileSize&nbsp;=&nbsp;10MB\n#&nbsp;输出所以日志，如果换成DEBUG表示输出DEBUG以上级别日志\nlog4j.appender.File.Threshold&nbsp;=&nbsp;ALL\nlog4j.appender.File.layout&nbsp;=&nbsp;org.apache.log4j.PatternLayout\nlog4j.appender.File.layout.ConversionPattern&nbsp;=[%p]&nbsp;[%d{yyyy-MM-dd&nbsp;HH\\:mm\\:ss}][%c]%m%n</code></pre> \n <p></p> \n <span id=\"OSC_h3_13\"></span> \n <h3><a name=\"t12\" rel=\"nofollow\"></a>4.2.4、JUnit测试</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; 经过以上步骤（到4.2.2，log4j不配也没影响），我们<span style=\"background-color: rgb(255, 255, 0);\">已经完成了Spring和mybatis的整合</span>，这样我们就可以编写一段测试代码来试试是否成功了。</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><br></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><br></span></p> \n <span id=\"OSC_h4_14\"></span> \n <h4><a name=\"t13\" rel=\"nofollow\"></a>4.2.4.1、创建测试用表</h4> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，<span style=\"font-family: \'Times New Roman\';\">SQL</span><span style=\"font-family: 宋体;\">语句为：</span></span></p> \n <pre class=\"brush:sql;toolbar: true; auto-links: false;\"><code>DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;`user_t`;\n\nCREATE&nbsp;TABLE&nbsp;`user_t`&nbsp;(\n&nbsp;&nbsp;`id`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT,\n&nbsp;&nbsp;`user_name`&nbsp;varchar(40)&nbsp;NOT&nbsp;NULL,\n&nbsp;&nbsp;`password`&nbsp;varchar(255)&nbsp;NOT&nbsp;NULL,\n&nbsp;&nbsp;`age`&nbsp;int(4)&nbsp;NOT&nbsp;NULL,\n&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`)\n)&nbsp;ENGINE=InnoDB&nbsp;AUTO_INCREMENT=2&nbsp;DEFAULT&nbsp;CHARSET=utf8;\n\n/*Data&nbsp;for&nbsp;the&nbsp;table&nbsp;`user_t`&nbsp;*/\n\ninsert&nbsp;&nbsp;into&nbsp;`user_t`(`id`,`user_name`,`password`,`age`)&nbsp;values&nbsp;(1,\'测试\',\'sfasgfaf\',24);</code></pre> \n <p></p> \n <span id=\"OSC_h4_15\"></span> \n <h4><a name=\"t14\" rel=\"nofollow\"></a>4.2.4.2、利用MyBatis Generator自动创建代码</h4> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">参考博文：<a target=\"_blank\" href=\"http://blog.csdn.net/zhshulin/article/details/23912615\" rel=\"nofollow\"><span style=\"color: rgb(0, 0, 255);\">http://blog.csdn.net/zhshulin/article/details/23912615</span></a></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><br></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; &nbsp;这个可根据表自动创建实体类、<span style=\"font-family: \'Times New Roman\';\">MyBatis</span><span style=\"font-family: 宋体;\">映射文件以及</span><span style=\"font-family: \'Times New Roman\';\">DAO</span><span style=\"font-family: 宋体;\">接口，当然，我</span><span style=\"color: rgb(51, 102, 255);\">习惯将生成的接口名改为</span><span style=\"color: rgb(255, 0, 0);\">IUserDao</span><span style=\"color: rgb(51, 102, 255);\">，而不是直接用它生成的</span><span style=\"color: rgb(255, 0, 0);\">UserMapper</span>。如果不想麻烦就<span style=\"background-color: rgb(255, 255, 0);\">可以不改</span>。完成后将文件复制到工程中。如图：</span></p> \n <p><img src=\"http://static.oschina.net/uploads/img/201507/17163308_9kgQ.jpg\" alt=\"\"></p> \n <span id=\"OSC_h4_16\"></span> \n <h4><a name=\"t15\" rel=\"nofollow\"></a>4.2.4.3、建立Service接口和实现类</h4> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">目录结构：</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;\"><img src=\"http://static.oschina.net/uploads/img/201507/17163308_2SpV.jpg\" alt=\"\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">下面给出具体的内容：</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px; background-color: rgb(255, 255, 0);\">IUserService.jave</span></p> \n <pre class=\"brush:java;toolbar: true; auto-links: false;\"><code>package&nbsp;com.cn.hnust.service;\n\nimport&nbsp;com.cn.hnust.pojo.User;\n\npublic&nbsp;interface&nbsp;IUserService&nbsp;{\n	public&nbsp;User&nbsp;getUserById(int&nbsp;userId);\n}</code></pre> \n <p></p> \n <p><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; background-color: rgb(255, 255, 0);\">UserServiceImpl.java</span><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; background-color: rgb(255, 255, 255);\"></span></p> \n <pre class=\"brush:java;toolbar: true; auto-links: false;\"><code>package&nbsp;com.cn.hnust.service.impl;\n\nimport&nbsp;javax.annotation.Resource;\n\nimport&nbsp;org.springframework.stereotype.Service;\n\nimport&nbsp;com.cn.hnust.dao.IUserDao;\nimport&nbsp;com.cn.hnust.pojo.User;\nimport&nbsp;com.cn.hnust.service.IUserService;\n\n@Service(\"userService\")\npublic&nbsp;class&nbsp;UserServiceImpl&nbsp;implements&nbsp;IUserService&nbsp;{\n	@Resource\n	private&nbsp;IUserDao&nbsp;userDao;\n	@Override\n	public&nbsp;User&nbsp;getUserById(int&nbsp;userId)&nbsp;{\n		//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub\n		return&nbsp;this.userDao.selectByPrimaryKey(userId);\n	}\n\n}</code></pre> \n <p></p> \n <span id=\"OSC_h4_17\"></span> \n <h4><a name=\"t16\" rel=\"nofollow\"></a>4.2.4.4、建立测试类</h4> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\">&nbsp; &nbsp; &nbsp; &nbsp;测试类<span style=\"background-color: rgb(51, 255, 51);\">在src/test/java中建立</span>，下面测试类中<span style=\"color: rgb(0, 0, 255);\">注释掉的部分是不使用<span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">时，一般情况下的一种测试方法</span></span>；如果使用了<span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">那么就可以使用注解的方式来引入配置文件和类，然后再将</span><span style=\"font-family: \'Times New Roman\';\">service</span><span style=\"font-family: 宋体;\">接口对象注入，就可以进行测试了。</span></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px;\"><span style=\"color: rgb(255, 0, 0);\">&nbsp; &nbsp; &nbsp; &nbsp;如果测试成功，表示<span style=\"font-family: \'Times New Roman\';\">Spring</span><span style=\"font-family: 宋体;\">和</span><span style=\"font-family: \'Times New Roman\';\">Mybatis</span><span style=\"font-family: 宋体;\">已经整合成功了</span></span>。输出信息使用的是<span style=\"font-family: \'Times New Roman\';\">Log4j</span><span style=\"font-family: 宋体;\">打印到控制台。</span></span></p> \n <pre class=\"brush:java;toolbar: true; auto-links: false;\"><code>package&nbsp;org.zsl.testmybatis;\n\nimport&nbsp;javax.annotation.Resource;\n\nimport&nbsp;org.apache.log4j.Logger;\nimport&nbsp;org.junit.Before;\nimport&nbsp;org.junit.Test;\nimport&nbsp;org.junit.runner.RunWith;\nimport&nbsp;org.springframework.context.ApplicationContext;\nimport&nbsp;org.springframework.context.support.ClassPathXmlApplicationContext;\nimport&nbsp;org.springframework.test.context.ContextConfiguration;\nimport&nbsp;org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport&nbsp;com.alibaba.fastjson.JSON;\nimport&nbsp;com.cn.hnust.pojo.User;\nimport&nbsp;com.cn.hnust.service.IUserService;\n\n@RunWith(SpringJUnit4ClassRunner.class)		//表示继承了SpringJUnit4ClassRunner类\n@ContextConfiguration(locations&nbsp;=&nbsp;{\"classpath:spring-mybatis.xml\"})\n\npublic&nbsp;class&nbsp;TestMyBatis&nbsp;{\n	private&nbsp;static&nbsp;Logger&nbsp;logger&nbsp;=&nbsp;Logger.getLogger(TestMyBatis.class);\n//	private&nbsp;ApplicationContext&nbsp;ac&nbsp;=&nbsp;null;\n	@Resource\n	private&nbsp;IUserService&nbsp;userService&nbsp;=&nbsp;null;\n\n//	@Before\n//	public&nbsp;void&nbsp;before()&nbsp;{\n//		ac&nbsp;=&nbsp;new&nbsp;ClassPathXmlApplicationContext(\"applicationContext.xml\");\n//		userService&nbsp;=&nbsp;(IUserService)&nbsp;ac.getBean(\"userService\");\n//	}\n\n	@Test\n	public&nbsp;void&nbsp;test1()&nbsp;{\n		User&nbsp;user&nbsp;=&nbsp;userService.getUserById(1);\n		//&nbsp;System.out.println(user.getUserName());\n		//&nbsp;logger.info(\"值：\"+user.getUserName());\n		logger.info(JSON.toJSONString(user));\n	}\n}</code></pre> \n <p></p> \n <p><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; background-color: rgb(255, 153, 0);\">测试结果：</span><span style=\"color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; background-color: rgb(255, 255, 255);\"></span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;\"><img src=\"http://static.oschina.net/uploads/img/201507/17163308_M50p.jpg\" alt=\"\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 18px; color: rgb(255, 102, 102);\">至此，<span style=\"background-color: rgb(255, 255, 153);\">完成Spring和mybatis这两大框架的整合</span>，下面在继续进行SpringMVC的整合。</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <span id=\"OSC_h2_18\"></span> \n <h2><a name=\"t17\" rel=\"nofollow\"></a>4.3、整合SpringMVC</h2> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style=\"font-size: 12px;\">上面已经完成了2大框架的整合，SpringMVC的配置文件单独放，然后在web.xml中配置整合。</span></p> \n <span id=\"OSC_h3_19\"></span> \n <h3><a name=\"t18\" rel=\"nofollow\"></a>4.3.1、配置spring-mvc.xml</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">配置里面的注释也很详细，在此就不说了，主要是<span style=\"background-color: rgb(51, 255, 51);\">自动扫描控制器，视图模式，注解的启动</span>这三个。</p> \n <pre class=\"brush:xml;toolbar: true; auto-links: false;\"><code>&lt;?xml&nbsp;version=\"1.0\"&nbsp;encoding=\"UTF-8\"?&gt;\n&lt;beans&nbsp;xmlns=\"http://www.springframework.org/schema/beans\"\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&nbsp;xmlns:p=\"http://www.springframework.org/schema/p\"\n	xmlns:context=\"http://www.springframework.org/schema/context\"\n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/beans/spring-beans-3.1.xsd&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/context&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/context/spring-context-3.1.xsd&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/mvc&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt;\n	&lt;!--&nbsp;自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器&nbsp;--&gt;\n	&lt;context:component-scan&nbsp;base-package=\"com.cn.hnust.controller\"&nbsp;/&gt;\n	&lt;!--避免IE执行AJAX时，返回JSON出现下载文件&nbsp;--&gt;\n	&lt;bean&nbsp;id=\"mappingJacksonHttpMessageConverter\"\n		class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"&gt;\n		&lt;property&nbsp;name=\"supportedMediaTypes\"&gt;\n			&lt;list&gt;\n				&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;\n			&lt;/list&gt;\n		&lt;/property&gt;\n	&lt;/bean&gt;\n	&lt;!--&nbsp;启动SpringMVC的注解功能，完成请求和注解POJO的映射&nbsp;--&gt;\n	&lt;bean\n		class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt;\n		&lt;property&nbsp;name=\"messageConverters\"&gt;\n			&lt;list&gt;\n				&lt;ref&nbsp;bean=\"mappingJacksonHttpMessageConverter\"&nbsp;/&gt;	&lt;!--&nbsp;JSON转换器&nbsp;--&gt;\n			&lt;/list&gt;\n		&lt;/property&gt;\n	&lt;/bean&gt;\n	&lt;!--&nbsp;定义跳转的文件的前后缀&nbsp;，视图模式配置--&gt;\n	&lt;bean&nbsp;class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n		&lt;!--&nbsp;这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个&nbsp;可用的url地址&nbsp;--&gt;\n		&lt;property&nbsp;name=\"prefix\"&nbsp;value=\"/WEB-INF/jsp/\"&nbsp;/&gt;\n		&lt;property&nbsp;name=\"suffix\"&nbsp;value=\".jsp\"&nbsp;/&gt;\n	&lt;/bean&gt;\n	\n	&lt;!--&nbsp;配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包&nbsp;--&gt;\n	&lt;bean&nbsp;id=\"multipartResolver\"&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;默认编码&nbsp;--&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=\"defaultEncoding\"&nbsp;value=\"utf-8\"&nbsp;/&gt;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;文件大小最大值&nbsp;--&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=\"maxUploadSize\"&nbsp;value=\"10485760000\"&nbsp;/&gt;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;内存中的最大值&nbsp;--&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=\"maxInMemorySize\"&nbsp;value=\"40960\"&nbsp;/&gt;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;\n\n&lt;/beans&gt;</code></pre> \n <p></p> \n <span id=\"OSC_h3_20\"></span> \n <h3><a name=\"t19\" rel=\"nofollow\"></a>4.3.2、配置web.xml文件</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这里面对spring-mybatis.xml的引入以及配置的spring-mvc的Servlet就是为了完成SSM整合，之前2框架整合不需要在此处进行任何配置。配置一样有详细注释，不多解释了。</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: rgb(255, 255, 204);\">web.xml</span></p> \n <pre class=\"brush:xml;toolbar: true; auto-links: false;\"><code>&lt;?xml&nbsp;version=\"1.0\"&nbsp;encoding=\"UTF-8\"?&gt;\n&lt;web-app&nbsp;xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xmlns=\"http://java.sun.com/xml/ns/javaee\"\n	xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee&nbsp;http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n	version=\"3.0\"&gt;\n	&lt;display-name&gt;Archetype&nbsp;Created&nbsp;Web&nbsp;Application&lt;/display-name&gt;\n	&lt;!--&nbsp;Spring和mybatis的配置文件&nbsp;--&gt;\n	&lt;context-param&gt;\n		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n		&lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt;\n	&lt;/context-param&gt;\n	&lt;!--&nbsp;编码过滤器&nbsp;--&gt;\n	&lt;filter&gt;\n		&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n		&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n		&lt;async-supported&gt;true&lt;/async-supported&gt;\n		&lt;init-param&gt;\n			&lt;param-name&gt;encoding&lt;/param-name&gt;\n			&lt;param-value&gt;UTF-8&lt;/param-value&gt;\n		&lt;/init-param&gt;\n	&lt;/filter&gt;\n	&lt;filter-mapping&gt;\n		&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n	&lt;/filter-mapping&gt;\n	&lt;!--&nbsp;Spring监听器&nbsp;--&gt;\n	&lt;listener&gt;\n		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n	&lt;/listener&gt;\n	&lt;!--&nbsp;防止Spring内存溢出监听器&nbsp;--&gt;\n	&lt;listener&gt;\n		&lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;\n	&lt;/listener&gt;\n\n	&lt;!--&nbsp;Spring&nbsp;MVC&nbsp;servlet&nbsp;--&gt;\n	&lt;servlet&gt;\n		&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;\n		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n		&lt;init-param&gt;\n			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n			&lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;\n		&lt;/init-param&gt;\n		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n		&lt;async-supported&gt;true&lt;/async-supported&gt;\n	&lt;/servlet&gt;\n	&lt;servlet-mapping&gt;\n		&lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;\n		&lt;!--&nbsp;此处可以可以配置成*.do，对应struts的后缀习惯&nbsp;--&gt;\n		&lt;url-pattern&gt;/&lt;/url-pattern&gt;\n	&lt;/servlet-mapping&gt;\n	&lt;welcome-file-list&gt;\n		&lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt;\n	&lt;/welcome-file-list&gt;\n\n&lt;/web-app&gt;</code></pre> \n <p></p> \n <span id=\"OSC_h3_21\"></span> \n <h3><a name=\"t20\" rel=\"nofollow\"></a>4.3.3、测试</h3> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; 至此已经完成了SSM三大框架的整合了，接下来测试一下，如果成功了，那么恭喜你，如果失败了，继续调试吧，<span style=\"background-color: rgb(51, 255, 51);\">作为程序员就是不停的与BUG做斗争</span>！</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <span id=\"OSC_h4_22\"></span> \n <h4><a name=\"t21\" rel=\"nofollow\"></a>4.3.3.1、新建jsp页面</h4> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255); text-align: center;\"><img src=\"http://static.oschina.net/uploads/img/201507/17163308_VD0s.jpg\" alt=\"\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: rgb(51, 255, 51);\">showUser.jsp</span>&nbsp;&nbsp; 此页面仅输出一下用户名，完成一个<span style=\"color: rgb(255, 102, 102);\">完整的简单流程</span>。</p> \n <pre class=\"brush:html;toolbar: true; auto-links: false;\"><code>&lt;%@&nbsp;page&nbsp;language=\"java\"&nbsp;import=\"java.util.*\"&nbsp;pageEncoding=\"utf-8\"%&gt;\n&lt;!DOCTYPE&nbsp;HTML&nbsp;PUBLIC&nbsp;\"-//W3C//DTD&nbsp;HTML&nbsp;4.01&nbsp;Transitional//EN\"&gt;\n&lt;html&gt;\n&nbsp;&nbsp;&lt;head&gt;\n	&lt;title&gt;测试&lt;/title&gt;\n&nbsp;&nbsp;&lt;/head&gt;\n&nbsp;&nbsp;\n&nbsp;&nbsp;&lt;body&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;${user.userName}\n&nbsp;&nbsp;&lt;/body&gt;\n&lt;/html&gt;</code></pre> \n <p></p> \n <span id=\"OSC_h4_23\"></span> \n <h4><a name=\"t22\" rel=\"nofollow\"></a>4.3.3.2、建立UserController类</h4> \n <pre class=\"brush:java;toolbar: true; auto-links: false;\"><code>package&nbsp;com.cn.hnust.controller;\n\nimport&nbsp;javax.annotation.Resource;\nimport&nbsp;javax.servlet.http.HttpServletRequest;\n\nimport&nbsp;org.springframework.stereotype.Controller;\nimport&nbsp;org.springframework.ui.Model;\nimport&nbsp;org.springframework.web.bind.annotation.RequestMapping;\n\nimport&nbsp;com.cn.hnust.pojo.User;\nimport&nbsp;com.cn.hnust.service.IUserService;\n\n@Controller\n@RequestMapping(\"/user\")\npublic&nbsp;class&nbsp;UserController&nbsp;{\n	@Resource\n	private&nbsp;IUserService&nbsp;userService;\n	\n	@RequestMapping(\"/showUser\")\n	public&nbsp;String&nbsp;toIndex(HttpServletRequest&nbsp;request,Model&nbsp;model){\n		int&nbsp;userId&nbsp;=&nbsp;Integer.parseInt(request.getParameter(\"id\"));\n		User&nbsp;user&nbsp;=&nbsp;this.userService.getUserById(userId);\n		model.addAttribute(\"user\",&nbsp;user);\n		return&nbsp;\"showUser\";\n	}\n}</code></pre> \n <p></p> \n <span id=\"OSC_h4_24\"></span> \n <h4><a name=\"t23\" rel=\"nofollow\"></a>4.3.3.3、部署项目</h4> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">输入地址：<span style=\"font-family: \'Times New Roman\';\">localhost:8080/</span><span style=\"font-family: 宋体;\">项目名称</span><span style=\"color: rgb(0, 0, 255);\">/user/showUser?id=1</span></p> \n <p><img src=\"http://static.oschina.net/uploads/img/201507/17163308_rGRd.jpg\" alt=\"\"></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 18px; color: rgb(255, 0, 0);\">至此，SSM三大框架的整合就完成了，在此基础上可再添加其他功能。</span></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; color: rgb(85, 85, 85); font-family: \'microsoft yahei\'; font-size: 15px; line-height: 35px; white-space: normal; background-color: rgb(255, 255, 255);\">源码下载地址：<a target=\"_blank\" href=\"http://download.csdn.net/detail/u012909091/7658611\" rel=\"nofollow\">http://download.csdn.net/detail/u012909091/7658611</a></p> \n <p><br></p> \n</div>',NULL,'2020-02-02 18:50:55',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223922094895616000',NULL,NULL,' ADB server didn\'t ACK 解决方法  ','<div class=\"content\" id=\"articleContent\"> \n <p><a href=\"http://blog.csdn.net/johnnycode/article/details/7678083\" rel=\"nofollow\">http://blog.csdn.net/johnnycode/article/details/7678083</a> </p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">一直没搞明白这个问题咋出现的，但今天看到一个方法，搞定了！原来是豌豆荚占用了 5037 端口导致。</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">参见原文章：<a href=\"http://www.cnblogs.com/longqi293/archive/2012/06/19/2554801.html\" rel=\"nofollow\">一个豌豆荚引发的血案——关于ADB server didn\'t ACK的问题</a></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">简单来讲，首先将Windows任务进程中的豌豆荚干掉，如果还是不行，再继续按下列步骤排查。</p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\"><br></p> \n <p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Arial; font-size: 14px; line-height: 26px; white-space: normal; background-color: rgb(255, 255, 255);\">问题现象：</p> \n <p><strong>[plain]</strong>&nbsp;<a href=\"http://blog.csdn.net/johnnycode/article/details/7678083#\" rel=\"nofollow\">view plain</a><a href=\"http://blog.csdn.net/johnnycode/article/details/7678083#\" rel=\"nofollow\">copy</a></p> \n <ol> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\"><span style=\"margin: 0px; padding: 0px; border: none; background-color: inherit;\">C:\\Users\\John&gt;adb&nbsp;shell&nbsp;&nbsp;</span></span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">adb&nbsp;server&nbsp;is&nbsp;out&nbsp;of&nbsp;date.&nbsp;&nbsp;killing...&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">ADB&nbsp;server&nbsp;didn\'t&nbsp;ACK&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">*&nbsp;failed&nbsp;to&nbsp;start&nbsp;daemon&nbsp;*&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">error:&nbsp;unknown&nbsp;host&nbsp;service&nbsp;&nbsp;</span></p></li> \n </ol> \n <p><br><span style=\"font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);\">1、排查哪路英雄占用了 5037 端口，找出他的 PID 来算账。 netstat -ano 命令会出现好多行，仔细找找。</span></p> \n <p><strong>[html]</strong>&nbsp;<a href=\"http://blog.csdn.net/johnnycode/article/details/7678083#\" rel=\"nofollow\">view plain</a><a href=\"http://blog.csdn.net/johnnycode/article/details/7678083#\" rel=\"nofollow\">copy</a></p> \n <ol> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\"><span style=\"margin: 0px; padding: 0px; border: none; background-color: inherit;\">C:\\Users\\John</span><span style=\"margin: 0px; padding: 0px; border: none; color: rgb(153, 51, 0); font-weight: bold; background-color: inherit;\">&gt;</span><span style=\"margin: 0px; padding: 0px; border: none; background-color: inherit;\">netstat&nbsp;-ano&nbsp;&nbsp;</span></span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">活动连接&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">&nbsp;&nbsp;协议&nbsp;&nbsp;&nbsp;&nbsp;本地地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外部地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PID&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">&nbsp;TCP&nbsp;&nbsp;&nbsp;&nbsp;127.0.0.1:5037&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;John-PC:0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTENING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5084&nbsp;&nbsp;</span></p></li> \n </ol> \n <p><br><span style=\"font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);\">2、找到相关的 PID ，然后查看其名字，干掉即可。</span></p> \n <p><strong>[plain]</strong>&nbsp;<a href=\"http://blog.csdn.net/johnnycode/article/details/7678083#\" rel=\"nofollow\">view plain</a><a href=\"http://blog.csdn.net/johnnycode/article/details/7678083#\" rel=\"nofollow\">copy</a></p> \n <ol> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\"><span style=\"margin: 0px; padding: 0px; border: none; background-color: inherit;\">C:\\Users\\John&gt;tasklist&nbsp;/fi&nbsp;\"pid&nbsp;eq&nbsp;5084&nbsp;&nbsp;</span></span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">映像名称&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PID&nbsp;会话名&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;会话#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内存使用&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">=========================&nbsp;========&nbsp;================&nbsp;===========&nbsp;============&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">wandoujia2.exe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5048&nbsp;Console&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;108,240&nbsp;K&nbsp;&nbsp;</span></p></li> \n </ol> \n <p><br><span style=\"font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);\">OK，干掉这个进程一般能搞定这个问题，感谢原文作者。</span></p> \n <p><br></p> \n</div>',NULL,'2020-02-02 18:52:21',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223922453483442176',NULL,NULL,' Eclipse下ADB报错:Android ADB server didn\'t ACK,解决办法  ','<div class=\"content\" id=\"articleContent\"> \n <p><span style=\"font-size: 18px;\"><span style=\"color: rgb(51, 51, 51);\">转载请注明出处</span>：</span><a target=\"_blank\" href=\"http://blog.csdn.net/xiaanming/article/details/9401981\" rel=\"nofollow\">http://blog.csdn.net/xiaanming/article/details/9401981</a></p> \n <p>ADB server didn\'t ACK 这个问题会困恼很多的新手朋友，我以前刚开始做Android的时候也遇到过这个问题，不过自己百度，google啥的，也不知道怎么就给解决了，看到群里很多新手朋友都会问这个问题，说实话我也没有一个解决这个问题的终极方法（百试百灵的那种，哈哈），自己没遇到也没有认真的去对待他，今天，就是在今天，我打开Eclipse连上手机，准备调试程序，出现如下的信息</p> \n <ol> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\"><span style=\"margin: 0px; padding: 0px; border: none; background-color: inherit;\">The&nbsp;connection&nbsp;to&nbsp;adb&nbsp;is&nbsp;down,&nbsp;and&nbsp;a&nbsp;severe&nbsp;error&nbsp;has&nbsp;occured.&nbsp;&nbsp;&nbsp;</span></span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">You&nbsp;must&nbsp;restart&nbsp;adb&nbsp;and&nbsp;Eclipse.&nbsp;&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">Please&nbsp;ensure&nbsp;that&nbsp;adb&nbsp;is&nbsp;correctly&nbsp;located&nbsp;at&nbsp;\'D:\\android-2.2-windows\\platform-tools\\adb.exe\'&nbsp;and&nbsp;can&nbsp;be&nbsp;executed.&nbsp;&nbsp;</span></p></li> \n </ol> \n <p><span style=\"font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);\">然后我就按照他的要求来做，重启Eclipse和adb，然后确认adb的路径是否正确，然后当我再次运行程序的时候，依旧不行，之后我就开始百度了，有朋友说先在DOS下运行adb kill-server（你必须在环境变量中配好你adb的路径或者进入到adb.exe的目录下），然后在adb start-server,当我运行adb start-server的时候，DOS出现如下信息</span></p> \n <ol> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\"><span style=\"margin: 0px; padding: 0px; border: none; background-color: inherit;\">*&nbsp;daemon&nbsp;not&nbsp;running.&nbsp;starting&nbsp;it&nbsp;now&nbsp;*&nbsp;&nbsp;&nbsp;</span></span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">ADB&nbsp;server&nbsp;didn\'t&nbsp;ACK&nbsp;&nbsp;&nbsp;</span></p></li> \n  <li><p><span style=\"margin: 0px; padding: 0px; border: none; color: black; background-color: inherit;\">*&nbsp;failed&nbsp;to&nbsp;start&nbsp;daemon&nbsp;*&nbsp;&nbsp;&nbsp;</span></p></li> \n </ol> \n <p><span style=\"font-family: Arial; font-size: 14px; line-height: 26px; background-color: rgb(255, 255, 255);\">然后在运行程序还是不行，重复搞了很多次老不行，还有朋友说在任务管理器找到adb.exe，然后关闭，重启Eclipse，我打开任务管理器，发现根本没有找到adb.exe,这时候我流泪满面了，然后我冷静下来，知道有些朋友遇到这个错误是因为豌豆荚啥的软件占用了adb.exe的端口，我的电脑里面根本没有按照豌豆荚，然后我想看看是谁占用adb的端口，我从网上查到adb.exe使用的端口是5037，接下来我给大家介绍解决方法</span></p> \n <ul> \n  <li><p>查看5037端口被谁占用了，<span style=\"font-family: Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height: 25.1875px;\">开始--运行--CMD 到命令提示符，输入&nbsp;netstat -aon|findstr \"5037\"，如下图 &nbsp; &nbsp;</span><span style=\"line-height: 25.1875px;\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://static.oschina.net/uploads/img/201312/24204330_OnVJ.jpg\" alt=\"\"></span></span></p></li> \n  <li><p><span style=\"font-family: Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height: 25.1875px;\">我们从上面根本就看不出5037端口被谁占用，我们需要根据后面的PID（2748）来查找占用该端口的应用程序，输入 tasklist|findstr \"2748\" ,如下图 &nbsp; &nbsp; &nbsp;</span><span style=\"line-height: 25.1875px;\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://static.oschina.net/uploads/img/201312/24204331_fxsz.jpg\" alt=\"\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>注： 我这里5037端口是正确的被adb.exe占用，如果是你，就是其他的应用程序啦</strong></span></span></p></li> \n  <li><p><span style=\"font-family: Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height: 25.1875px;\">结束该进程，输入taskkill /f /t /im 你的进程名，例如adb.exe，如下图，在重新连接手机，这时候你会发现程序运行起来了 &nbsp;</span><span style=\"line-height: 25.1875px;\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://static.oschina.net/uploads/img/201312/24204331_13WZ.jpg\" alt=\"\"></span></span></p></li> \n </ul> \n <p><br></p> \n</div>',NULL,'2020-02-02 18:53:47',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223922812440367104',NULL,NULL,' Android ADB server didn\'t ACK * failed to start daemon * 简单有效的解决方案  ','<div class=\"content\" id=\"articleContent\"> \n <p> <span style=\"line-height:1.5;\">ADB server didn\'t ACK 这个问题会困恼很多的新手朋友，我以前刚开始做Android的时候也遇到过这个问题，不过自己百度，google啥的，也不知道怎么就给解决了，看到群里很多新手朋友都会问这个问题，说实话我也没有一个解决这个问题的终极方法（百试百灵的那种，哈哈），自己没遇到也没有认真的去对待他，今天，就是在今天，我打开Eclipse连上手机，准备调试程序，出现如下的信息</span> </p> \n <div> \n  <div> \n   <div> \n    <b>[plain]</b>&nbsp; \n    <a href=\"http://blog.csdn.net/xiaanming/article/details/9401981#\" rel=\"nofollow\">view plain</a> \n    <a href=\"http://blog.csdn.net/xiaanming/article/details/9401981#\" rel=\"nofollow\">copy</a> \n    <div> \n    </div> \n   </div> \n  </div> \n  <ol> \n   <li> <span style=\"color:black;background-color:inherit;\"><span style=\"background-color:inherit;\">The&nbsp;connection&nbsp;to&nbsp;adb&nbsp;is&nbsp;down,&nbsp;and&nbsp;a&nbsp;severe&nbsp;error&nbsp;has&nbsp;occured.&nbsp;&nbsp;&nbsp;</span></span> </li> \n   <li> <span style=\"color:black;background-color:inherit;\">You&nbsp;must&nbsp;restart&nbsp;adb&nbsp;and&nbsp;Eclipse.&nbsp;&nbsp;&nbsp;</span> </li> \n   <li> <span style=\"color:black;background-color:inherit;\">Please&nbsp;ensure&nbsp;that&nbsp;adb&nbsp;is&nbsp;correctly&nbsp;located&nbsp;at&nbsp;\'D:\\android-2.2-windows\\platform-tools\\adb.exe\'&nbsp;and&nbsp;can&nbsp;be&nbsp;executed.&nbsp;&nbsp;</span> </li> \n  </ol> \n </div> \n <span style=\"font-family:Arial;font-size:14px;line-height:26px;background-color:#FFFFFF;\">然后我就按照他的要求来做，重启Eclipse和adb，然后确认adb的路径是否正确，然后当我再次运行程序的时候，依旧不行，之后我就开始百度了，有朋友说先在DOS下运行adb kill-server（你必须在环境变量中配好你adb的路径或者进入到adb.exe的目录下），然后在adb start-server,当我运行adb start-server的时候，DOS出现如下信息</span> \n <span style=\"font-family:Arial;font-size:14px;line-height:26px;background-color:#FFFFFF;\"></span> \n <div> \n  <div> \n   <div> \n    <b>[plain]</b>&nbsp; \n    <a href=\"http://blog.csdn.net/xiaanming/article/details/9401981#\" rel=\"nofollow\">view plain</a> \n    <a href=\"http://blog.csdn.net/xiaanming/article/details/9401981#\" rel=\"nofollow\">copy</a> \n    <div> \n    </div> \n   </div> \n  </div> \n  <ol> \n   <li> <span style=\"color:black;background-color:inherit;\"><span style=\"background-color:inherit;\">*&nbsp;daemon&nbsp;not&nbsp;running.&nbsp;starting&nbsp;it&nbsp;now&nbsp;*&nbsp;&nbsp;&nbsp;</span></span> </li> \n   <li> <span style=\"color:black;background-color:inherit;\">ADB&nbsp;server&nbsp;didn\'t&nbsp;ACK&nbsp;&nbsp;&nbsp;</span> </li> \n   <li> <span style=\"color:black;background-color:inherit;\">*&nbsp;failed&nbsp;to&nbsp;start&nbsp;daemon&nbsp;*&nbsp;&nbsp;&nbsp;</span> </li> \n  </ol> \n </div> \n <span style=\"font-family:Arial;font-size:14px;line-height:26px;background-color:#FFFFFF;\">然后在运行程序还是不行，重复搞了很多次老不行，还有朋友说在任务管理器找到adb.exe，然后关闭，重启Eclipse，我打开任务管理器，发现根本没有找到adb.exe,这时候我流泪满面了，然后我冷静下来，知道有些朋友遇到这个错误是因为豌豆荚啥的软件占用了adb.exe的端口，我的电脑里面根本没有按照豌豆荚，然后我想看看是谁占用adb的端口，我从网上查到adb.exe使用的端口是5037，接下来我给大家介绍解决方法</span> \n <span style=\"font-family:Arial;font-size:14px;line-height:26px;background-color:#FFFFFF;\"></span> \n <ul> \n  <li> 查看5037端口被谁占用了，<span style=\"font-family:Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height:25.1875px;\">开始--运行--CMD 到命令提示符，输入&nbsp;netstat -aon|findstr \"5037\"，如下图 &nbsp; &nbsp;</span><span style=\"line-height:25.1875px;\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://static.oschina.net/uploads/img/201311/23092322_0nEL.jpg\" alt=\"\"></span></span> </li> \n  <li> <span style=\"font-family:Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height:25.1875px;\">我们从上面根本就看不出5037端口被谁占用，我们需要根据后面的PID（2748）来查找占用该端口的应用程序，输入 tasklist|findstr \"2748\" ,如下图 &nbsp; &nbsp; &nbsp;</span><span style=\"line-height:25.1875px;\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://static.oschina.net/uploads/img/201311/23092322_2FMY.jpg\" alt=\"\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>注： 我这里5037端口是正确的被adb.exe占用，如果是你，就是其他的应用程序啦</strong></span></span> </li> \n  <li> <span style=\"font-family:Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height:25.1875px;\">结束该进程，输入taskkill /f /t /im 你的进程名，例如adb.exe，如下图，在重新连接手机，这时候你会发现程序运行起来了 &nbsp;</span><span style=\"line-height:25.1875px;\">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src=\"http://static.oschina.net/uploads/img/201311/23092322_xzXU.jpg\" alt=\"\"></span></span> </li> \n </ul> \n <span style=\"font-size:14px;line-height:26px;background-color:#FFFFFF;font-family:Helvetica, Tahoma, Arial, sans-serif;\"><span style=\"line-height:25.1875px;\">这个问题虽然不是什么很大的问题，但是对于新手来说也是属于比较棘手的问题，所以我将自己解决此问题的方法在这里记录下，希望能给遇到此问题的人一点点帮助，如果我写得文章对你一点帮助请帮我顶一下文章，谢谢！</span></span> \n</div>',NULL,'2020-02-02 18:55:13',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223923169832816640',NULL,NULL,' Eclipse的DDMS找不到设备  ','<div class=\"content\" id=\"articleContent\"> \n <p> 前几天Eclipse中连接手机还是正常的，今天突然发现ddms中找不到设备了，reset adb总是提示： </p> \n <p> [2013-01-05 14:55:22 - adb] ADB server didn\'t ACK<br> [2013-01-05 14:55:22 - adb] * failed to start daemon * </p> \n <p> 尝试adb kill-server/ adb start-server没有作用，后来在网上看到http://stackoverflow.com/questions/5703550/my-eclipse-adb-server-didnt-ack-failed-to-start-daemon，网上有个做法：check if any application is using Port 5037 use this netstat -a -n -o |findstr \"5037\"，果然，发现wandoujia_daemon把端口占用了，果断kill豌豆荚，reset adb，搞定! </p> \n <p> 以后千万记得kill wandoujia </p> \n</div>',NULL,'2020-02-02 18:56:38',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223923527007162368',NULL,NULL,' Java NIO && Netty的epoll实现  ','<div class=\"content\" id=\"articleContent\"> \n <p>Java NIO &amp;&amp; Netty的epoll实现</p> \n <span id=\"OSC_h1_1\"></span> \n <h1>Java NIO</h1> \n <p>Java NIO根据操作系统不同， 针对nio中的Selector有不同的实现：</p> \n <ul> \n  <li> <p>macosx: KQueueSelectorProvider</p> </li> \n  <li> <p>solaris: DevPollSelectorProvider</p> </li> \n  <li> <p><span style=\"background-color:#ffc000\"><em><strong>Linux: EPollSelectorProvider (Linux kernels &gt;= 2.6)或 PollSelectorProvider</strong></em></span></p> </li> \n  <li> <p>windows: WindowsSelectorProvider</p> </li> \n </ul> \n <p>所以毋须特别指定， Oracle jdk会自动选择合适的Selector。 如果想设置特定的Selector，可以属性：</p> \n <pre><code>-Djava.nio.channels.spi.SelectorProvider=sun.nio.ch.EPollSelectorProvider</code></pre> \n <p>&nbsp;</p> \n <span id=\"OSC_h1_2\"></span> \n <h1>Netty</h1> \n <p>自4.0.16起, Netty为Linux通过JNI的方式提供了native socket transport.</p> \n <p>使用native socket transport很简单，只需将相应的类替换即可。</p> \n <blockquote> \n  <p>NioEventLoopGroup → EpollEventLoopGroup</p> \n  <p>NioEventLoop → EpollEventLoop</p> \n  <p>NioServerSocketChannel → EpollServerSocketChannel</p> \n  <p>NioSocketChannel → EpollSocketChannel</p> \n </blockquote> \n <p>如果使用maven， 加入相应的依赖：</p> \n <pre><code>&lt;dependency&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;io.netty&lt;/groupId&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;${project.version}&lt;/version&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;classifier&gt;${os.detected.classifier}&lt;/classifer&gt;\r\n&lt;/dependency&gt;</code></pre> \n <p>既然如上面所说， Oracle JDK在Linux已经默认使用epoll方式， 为什么netty还要提供一个基于epoll的实现呢？这是stackoverflow(https://stackoverflow.com/questions/23465401/why-native-epoll-support-is-introduced-in-netty)上的一个问题。 Netty的核心开发者 Norman Maurer这么说的：</p> \n <blockquote> \n  <p>Netty的 epoll transport 使用 epoll edge-triggered 而 java 的 nio 使用 level-triggered。</p> \n  <p>另外netty epoll transport 暴露了更多的nio没有的配置参数， 如 TCP_CORK, SO_REUSEADDR等等</p> \n </blockquote> \n <p>=========END=========</p> \n</div>',NULL,'2020-02-02 18:58:03',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223923884621910016',NULL,NULL,' Java 200+ 面试题补充② Netty 模块  ','<div class=\"content\" id=\"articleContent\"> \n <blockquote> \n  <p>让我们每天都能看到自己的进步。老王带你打造最全的 Java 面试清单，认真把一件事做到最好。</p> \n </blockquote> \n <p>本文是前文<a href=\"https://blog.csdn.net/sufu1065/article/details/88051083\">《Java 最常见的 200+ 面试题》</a>的第二个补充模块，第一模块为：<a href=\"https://juejin.im/post/5c805cb9f265da2d9e177f6d\">《Java 200+ 面试题补充 ThreadLocal 模块》</a>。</p> \n <h4>1.Netty 是什么？</h4> \n <p>Netty 是一款基于 NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。难能可贵的是，在保证快速和易用性的同时，并没有丧失可维护性和性能等优势。</p> \n <h4>2.Netty 的特点是什么？</h4> \n <ul> \n  <li>高并发：Netty 是一款基于 NIO（Nonblocking IO，非阻塞IO）开发的网络通信框架，对比于 BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。</li> \n  <li>传输快：Netty 的传输依赖于零拷贝特性，尽量减少不必要的内存拷贝，实现了更高效率的传输。</li> \n  <li>封装好：Netty 封装了 NIO 操作的很多细节，提供了易于使用调用接口。</li> \n </ul> \n <h4>3.什么是 Netty 的零拷贝？</h4> \n <p>Netty 的零拷贝主要包含三个方面：</p> \n <ul> \n  <li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li> \n  <li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</li> \n  <li>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li> \n </ul> \n <h4>4.Netty 的优势有哪些？</h4> \n <ul> \n  <li>使用简单：封装了 NIO 的很多细节，使用更简单。</li> \n  <li>功能强大：预置了多种编解码功能，支持多种主流协议。</li> \n  <li>定制能力强：可以通过 ChannelHandler 对通信框架进行灵活地扩展。</li> \n  <li>性能高：通过与其他业界主流的 NIO 框架对比，Netty 的综合性能最优。</li> \n  <li>稳定：Netty 修复了已经发现的所有 NIO 的 bug，让开发人员可以专注于业务本身。</li> \n  <li>社区活跃：Netty 是活跃的开源项目，版本迭代周期短，bug 修复速度快。</li> \n </ul> \n <h4>5.Netty 的应用场景有哪些？</h4> \n <p>典型的应用有：阿里分布式服务框架 Dubbo，默认使用 Netty 作为基础通信组件，还有 RocketMQ 也是使用 Netty 作为通讯的基础。</p> \n <h4>6.Netty 高性能表现在哪些方面？</h4> \n <ul> \n  <li>IO 线程模型：同步非阻塞，用最少的资源做更多的事。</li> \n  <li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输。</li> \n  <li>内存池设计：申请的内存可以重用，主要指直接内存。内部实现是用一颗二叉查找树管理内存分配情况。</li> \n  <li>串形化处理读写：避免使用锁带来的性能开销。</li> \n  <li>高性能序列化协议：支持 protobuf 等高性能序列化协议。</li> \n </ul> \n <h4>7.Netty 和 Tomcat 的区别？</h4> \n <p>Netty 和 Tomcat 最大的区别就在于通信协议，Tomcat 是基于 http 协议的，他的实质是一个基于 http 协议的web容器，但是 Netty 不一样，他能通过编程自定义各种协议，因为 Netty 能够自己编码/解码字节流，完成类似Redis 访问的功能，这就是 Netty 和 Tomcat 最大的区别。</p> \n <h4>8.Netty 中有那种重要组件？</h4> \n <ul> \n  <li>Channel：Netty 网络操作抽象类，它除了包括基本的 I/O 操作，如 bind、connect、read、write 等。</li> \n  <li>EventLoop：主要是配合 Channel 处理 I/O 操作，用来处理连接的生命周期中所发生的事情。</li> \n  <li>ChannelFuture：Netty 框架中所有的 I/O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</li> \n  <li>ChannelHandler：充当了所有处理入站和出站数据的逻辑容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。</li> \n  <li>ChannelPipeline：为 ChannelHandler 链提供了容器，当 channel 创建时，就会被自动分配到它专属的 ChannelPipeline，这个关联是永久性的。</li> \n </ul> \n <h4>9.Netty 发送消息有几种方式？</h4> \n <p>Netty 有两种发送消息的方式：</p> \n <ul> \n  <li>直接写入 Channel 中，消息从 ChannelPipeline 当中尾部开始移动；</li> \n  <li>写入和 ChannelHandler 绑定的 ChannelHandlerContext 中，消息从 ChannelPipeline 中的下一个 ChannelHandler 中移动。</li> \n </ul> \n <h4>10.默认情况 Netty 起多少线程？何时启动？</h4> \n <p>Netty 默认是 CPU 处理器数的两倍，bind 完之后启动。</p> \n <h4>11.Netty 支持哪些心跳类型设置？</h4> \n <ul> \n  <li>readerIdleTime：为读超时时间（即测试端一定时间内未接受到被测试端消息）。</li> \n  <li>writerIdleTime：为写超时时间（即测试端一定时间内向被测试端发送消息）。</li> \n  <li>allIdleTime：所有类型的超时时间。</li> \n </ul> \n <h4>最后</h4> \n <ul> \n  <li>如果大家想更深入的了解 Netty，推荐一本很不错的掘金小册给大家（扫描二维码八折优惠）。</li> \n </ul> \n <p><img src=\"http://icdn.apigo.cn/expand/smallbook-netty-small.png\" alt=\"netty小册\"></p> \n <ul> \n  <li>查看全部面试题目：<a href=\"https://blog.csdn.net/sufu1065/article/details/88051083\">《Java 最常见的 200+ 面试题》</a></li> \n </ul> \n <h4>参考文档</h4> \n <p><a href=\"https://blog.csdn.net/chenssy/article/details/78703551\">https://blog.csdn.net/chenssy/article/details/78703551</a></p> \n <p><a href=\"https://blog.csdn.net/summerZBH123/article/details/79344226\">https://blog.csdn.net/summerZBH123/article/details/79344226</a></p> \n <p><a href=\"https://blog.csdn.net/thinking_fioa/article/details/80588138\">https://blog.csdn.net/thinking_fioa/article/details/80588138</a></p> \n <p><a href=\"https://www.jianshu.com/p/a199ca28e80d\">https://www.jianshu.com/p/a199ca28e80d</a></p> \n <p><a href=\"https://blog.csdn.net/linuu/article/details/51385682\">https://blog.csdn.net/linuu/article/details/51385682</a></p> \n <h4>往期文章推荐</h4> \n <p><a href=\"https://blog.csdn.net/sufu1065/article/details/88051083\">Java 最常见的 200+ 面试题</a></p> \n <p><a href=\"https://juejin.im/post/5c805cb9f265da2d9e177f6d\">Java 200+ 面试题补充 ThreadLocal 模块</a></p> \n <p><a href=\"https://juejin.im/post/5c7ddcd06fb9a04a06059bea\">你真的懂 == 和 equals 的区别吗？</a></p> \n <p><a href=\"https://juejin.im/post/5c650ac7e51d45783211fd5f\">程序员精美简历Top榜—面试必备</a></p> \n <p><a href=\"https://juejin.im/post/5c7f227f51882562851b72df\">程序员专属精美简历合集——第二弹</a></p> \n</div>',NULL,'2020-02-02 18:59:28',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223924241381019648',NULL,NULL,' 英特尔SR-IOV实现PCI硬件资源共享  ','<div class=\"content\" id=\"articleContent\"> \n <p> <span>为了解决这些挑战，出现了两个解决方案：VMDq和SR-IOV。</span> </p> \n <p> <span>Intel开发了VMDq技术来将数据分类功能从hypervisor转移到网卡中。这提高了I/O性能以交付近线速的吞吐量和更低的CPU占用率。</span> </p> \n <p> <span>除此之外，行业标准组织PCI-SIG制定了PCI-SIG Single Root I/O Virtualization (SR-IOV)规范以进一步加强虚拟化机系统的I/O性能。在PCI-SIG工作组中，Intel</span><span>积极地与其他行业领导者共同</span><span>合作。</span> </p> \n <p> <span>SR-IOV是一种不需要软件模拟就可以共享I/O设备I/O端口的物理功能的方法。这个过程创造了一系列I/O设备物理端口的虚拟功能。每个虚拟功能都被直接分配到一个虚拟机，因此实现了接近本机的性能。</span> </p> \n <p> <span>总的来说，SR-IOV实现了将PCI功能分配到多个虚拟接口以在虚拟化环境中共享一个PCI设备的资源。SR-IOV能够让网络传输绕过软件模拟层，直接分配到虚拟机。这样就降低了软加模拟层中的I/O开销。</span> </p> \n <p> <span>PCI-SIG SR-IOV的优势</span> </p> \n <p> <span>PCI-SIG SR-IOV提供了一个设备宣传其在多个虚拟机之间同时共享的能力的标准机制。SR-IOV规范允许一个独立硬件厂商（Independent Hardware Vendor，IHV）修改其PCI卡来定义成对于一个VMM（hypervisor）同一个类型的多个设备。SR-IOV的好处是创建了一个精简的界面来允许IHV有效地执行能够直接分配到虚拟机的界面。</span> </p> \n <p> <span>SR-IOV概览</span> </p> \n <p> <span>SR-IOV规范的目标是在绕过虚拟机参与数据迁移过程中实施标准化，为每个虚拟机提供独立内存空间、中断和Direct Memory Access (DMA)流。SR-IOV架构的设计允许一个I/O设备支持多个虚拟功能，同时将每个功能的硬件成本降至最低。SRIOV引入了两个新的功能类型：</span> </p> \n <p> </p> \n <ul> \n  <li> <span style=\"line-height:1.5;font-size:10pt;\">物理功能（Physical Functions，PFs）：这是一些支持SR-IOV扩展功能的PCIe功能，被用于配置和管理SR-IOV功能特性</span> </li> \n  <li> <span style=\"line-height:1.5;font-size:10pt;\">虚拟功能（Virtual Functions，VFs）：这是一些“精简”的PCIe功能，包括数据迁移必需的资源，以及经过谨慎精简的配置资源集</span> </li> \n </ul> \n <p></p> \n <p> <span>虚拟化直接分配的方法允许虚拟机直接连接到一个I/O设备。因此，直接设备分配特性提供了一种本地体验和非常快速的I/0（因此它重新利用现有驱动程序或者其他软件来与设备进行直接通信）。然而，这限制了I/O设备的共享。SR-IOV提供了一项功能以多个独立物理设备呈现的机制。</span> </p> \n <p> <span>支持SR-IOV的设备可以配置成以多个虚拟功能形式呈现在PCI配置空间中，每个都有它们自己的PCI配置空间。然后VMM可以通过模拟配置空间来分配一个或者多个虚拟功能给虚拟机。</span> </p> \n <p> <span>每个虚拟功能可以支持针对PCIe层中I/O相关功能的一个特有且单独的数据路径。在网络设备中使用SR-IOV可使一个端口（功能）的带宽分成更小的块，然后通过一个标准接口分配到特定虚拟机或者客户端中。为了进一步加强PCIe层中不同设备的可操作性，还创建了一个配置和管理的通用方法体系。这种资源的共享提高了在一个支持SR-IOV的PCIe设备上任何特定资源的总利用率，从而降低了虚拟系统的成本。</span> </p> \n <p> <span>英特尔的PCI-SIG SR-IOV功能实施要求VMM软件利用Intel Virtualization Technology for Directed I/O (Intel VT-d)直接将虚拟功能分配到虚拟机中。Intel VT-d中的内存转译技术提供了硬件辅助功能，允许直接的DMA传输。Intel VT-d可确保传输的安全，SRIOV为虚拟机提供了独立的数据空间。</span> </p> \n <p> <span>支持PCI-SIG SR-IOV的Intel Server Adapters兼容任何厂商的具备直接从网卡向虚拟机分配虚拟功能的平台解决方案。</span> </p> \n <p> <span>总结</span> </p> \n <p> <span>总的来说，PCI-SIG SR-IOV在虚拟化平台上的关键优点包括：</span> </p> \n <p> <br> </p> \n <ul> \n  <li> <span style=\"line-height:1.5;font-size:10pt;\">提供了一个共享任何特定I/O设备容量、实现虚拟系统中资源最有效利用的标准方法</span> </li> \n  <li> <span style=\"line-height:1.5;font-size:10pt;\">在一个物理服务器上每个虚拟机接近本地的性能</span> </li> \n  <li> <span style=\"line-height:1.5;font-size:10pt;\">在同一个物理服务器上虚拟之间的数据保护</span> </li> \n  <li> <span style=\"font-size:10pt;line-height:1.5;\">物理服务器之间更平滑的虚拟机迁移，因此实现了I/O环境的动态配置</span> </li> \n </ul> \n <p> <br> </p> \n <p> <span>Intel最新的和即将推出的PCIe千兆以太网适配器将支持PCI-SIG SR-IOV功能。不同VMM厂商还将把这项支持集成到操作系统中，以发挥这项技术的优势。</span> </p> \n <span></span> \n</div>',NULL,'2020-02-02 19:00:53',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223924598479867904',NULL,NULL,' java.security.InvalidKeyException:illegal Key Size  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1> 现象 </h1> 使用了weixin-java-tools包对接微信企业号，在激活回调URL时就发生异常，AES加密失败，报java.security.InvalidKeyException:illegal Key Size，当密钥大于128位时报此错误。 \n <br> \n <br> \n <span id=\"OSC_h1_2\"></span> \n <h1> 解决方案 </h1> 到Oracle官网下载JCE无限制权限策略文件（注意对应版本），下载后解压，可以看到local_policy.jar和US_export_policy.jar以及readme.txt。如果安装了JRE， 将两个jar文件放到%JRE_HOME% \\lib\\security目录下覆盖原来的文件，如果安装了JDK，将两个jar文件放到%JDK_HOME%\\jre\\lib\\security目录 下覆盖原来文件。 \n <span></span> \n <br> \n <br> 下载地址： \n <br> \n <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html\" target=\"_blank\" rel=\"nofollow\">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a> \n <br> \n <span></span> \n</div>',NULL,'2020-02-02 19:02:18',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223924956073644032',NULL,NULL,' Hibernate中cascade作用  ','<div class=\"content\" id=\"articleContent\"> \n <p><span style=\"FONT-SIZE: 14px\"><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">&nbsp;&nbsp;&nbsp;&nbsp;只有“关系标记”才有cascade属性；</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">一个操作因级联cascade可能触发多个关联操作。前一个操作叫“主控操作”，后一个操作叫“关联操作”。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascade属性的可能值有</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　all: 所有情况下均进行关联操作，即save-update和delete。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　none: 所有情况下均不进行关联操作。这是默认值。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　save-update: 在执行save/update/saveOrUpdate时进行关联操作。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　delete: 在执行delete 时进行关联操作。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　all-delete-orphan: 当一个节点在对象图中成为孤儿节点时，删除该节点。比如在一个一对多的关系中，Student包含多个book，当在对象关系中删除一个book时，此book即成为孤儿节点。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　级联（cascade）属性的作用：</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　级联指的是当主控方执行操作时，关联对象（被动方）是否同步执行同一操作。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　pojo和它的关系属性的关系就是“主控方 -- 被动方”的关系，如果关系属性是一个set，那么被动方就是set中的一个一个元素。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　比如：学校（School）有三个属性：地区(Address),校长（TheMaster）和学生(Set，元素为Student)</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　执行session.delete(school)时，级联决定是否执行session.delete(Address),session.delete(theMaster)，</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　是否对每个aStudent执行session.delete(aStudent)。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　具体执行什么“关联操作”是根据“主控操作”来的：</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　“主控操作”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“关联操作”</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.saveOrUpdate --&gt; session.saveOrUpdate (执行saveOrUpdate实际上会执行save或者update)</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.save ----&gt; session.saveOrUpdate</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.udpate --&gt; session.saveOrUpdate</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.delete --&gt; session.delete</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　主控操作和关联操作的先后顺序是“先保存one，再保存many；先删除many，再删除one；先update主控方，再update被动方”</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　对于one-to-one，当其属性constrained=\"false\"（默认值）时，它可看作one-to-many关系；</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　当其属性constrained=\"true\"时，它可看作many-to-one关系；</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　对many-to-many，它可看作one-to-many。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　比如：学校（School）有三个属性：地区(Address),校长（TheMaster，其constrained=\"false\"）和学生(Set， 元素为Student)</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　当执行session.save(school)时，</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　实际的执行顺序为：session.save(Address);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.save(school);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.save(theMaster);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　for( 对每一个student ){</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.save(aStudent);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　}</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　当执行session.delete(school)时，</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　实际的执行顺序为：session.delete(theMaster);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　for( 对每一个student ){</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.delete(aStudent);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　}</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.delete(school);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.delete(Address);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　当执行session.update(school)时，</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　实际的执行顺序为：session.update(school);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.saveOrUpdate(Address);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.saveOrUpdate(theMaster);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　for( 对每一个student ){</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　session.saveOrUpdate(aStudent);</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　}</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　注意：update操作因级联引发的关联操作为saveOrUpdate操作，而不是update操作。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　saveOrUpdate与update的区别是：前者根据操作对象是保存了还是没有保存，而决定执行update还是save</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　extends: 实际中，删除学校不会删除地区，即地区的cascade一般设为false；另外，many-to-many关系很少设置cascade=true，而是设置inverse=false。这个反映了cascade和inverse的区别。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascade的默认值为false，所以inverse属性默认会进行“关联更新”。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　总结：级联（cascade）就是操作一个对象时，对它的属性（其cascade=true）也进行这个操作。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse和cascade的比较</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　这两个属性本身互不影响，但起的作用有些类似，都能引发对关系表的更新。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse只对set+one-to-many(或many-to-many)有效，对many-to-one, one-to-one无效。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascade对关系标记都有效。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse对集合对象整体起作用，cascade对集合对象中的一个一个元素起作用，如果集合为空，那么cascade不会引发关联操作。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　比如将集合对象置为null， school.setStudentSet(null)</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse导致hibernate执行:udpate STUDENT set SCHOOL_ID=null where SCHOOL_ID=?</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascade则不会执行对STUDENT表的关联更新， 因为集合中没有元素。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　再比新增一个school, session.save(school)</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse导致hibernate执行：</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　for( 对(school的每一个student ){</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;udpate STUDENT set SCHOOL_ID=? where STUDENT_ID=? //将学生的school_id改为新的school的id</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　}</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">cascade导致hibernate执行：</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　for( 对school的每一个student ){</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.save(aStudent); //对学生执行save操作</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　}</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　extends:如果改变集合中的部分元素（比如新增一个元素），</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse: hibernate先判断哪些元素改变了，对改变的元素执行相应的sql</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascade: 它总是对集合中的每个元素执行关联操作。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　（在关联操作中，hibernate会判断操作的对象是否改变）</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　两个起作用的时机不同：</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascade：在对主控方操作时，级联发生。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse: 在flush时（commit会自动执行flush)，对session中的所有set，hibernate判断每个set是否有变化，对有变化的set执行相应的sql，执行之前，会有个判断：if( inverse == true ) return;可以看出cascade在先，inverse在后。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　inverse 对set + one-to-many 和 set + many-to-many 起的作用不同。hibernate生成的sql不同。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　对one-to-many，hibernate对many方的数据库表执行update语句。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　对many-to-many, hibernate对关系表执行insert/update/delte语句，注意不是对many方的数据库表而是关系表。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　cascase 对set都是一致的，不管one-to-many还是many-to-many。都简单地把操作传递到set中的每个元素。所以它总是更新many方的数据库表。</span><br><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">　　建议：只对set + many-to-many设置inverse=false，其他的标记不考虑inverse属性，都设为inverse=true。</span><br><span style=\"TEXT-TRANSFORM: none; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; DISPLAY: inline !important; FONT: 13px/21px Arial; WHITE-SPACE: normal; FLOAT: none; LETTER-SPACING: normal; COLOR: rgb(51,51,51); WORD-SPACING: 0px; -webkit-text-stroke-width: 0px\">对cascade，一般对many-to-one，many-to-many，constrained=true的one-to-one 不设置级联删除。</span></span></p> \n</div>',NULL,'2020-02-02 19:03:44',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223925313243795456',NULL,NULL,' Hibernate core 3.3.2.GA 与 3.6.0.Final引发的一个血案  ','<div class=\"content\" id=\"articleContent\"> \n <p>一、背景</p> \n <p>&nbsp; Web项目M 引用Sub工程，Sub工程打包成Jar形式被M引用。</p> \n <p>Sub里有这样一段获取服务器时间的代码；</p> \n <p>Date date = null;</p> \n <p><span style=\"white-space:pre\"> </span>Session session = &nbsp;this.getSessionFactory().openSession();</p> \n <p><span style=\"white-space:pre\"> </span>&nbsp;</p> \n <p><span style=\"white-space:pre\"> </span>String sql = \"select sysdate as mydate from dual\";</p> \n <p><span style=\"white-space:pre\"> </span>SQLQuery query = session.createSQLQuery(sql);</p> \n <p><span style=\"white-space:pre\"> </span>&nbsp;</p> \n <p><span style=\"white-space:pre\"> </span>try {</p> \n <p><span style=\"white-space:pre\"> </span>query.addScalar(\"mydate\",Hibernate.TIMESTAMP);</p> \n <p><span style=\"white-space:pre\"> </span></p> \n <p><span style=\"white-space:pre\"> </span>date = (Date) query.uniqueResult();</p> \n <p><span style=\"white-space:pre\"> </span>System.out.println(\"XXXX:\"+org.hibernate.Hibernate.TIMESTAMP.getClass());</p> \n <p><span style=\"white-space:pre\"> </span>} catch (HibernateException e) {</p> \n <p><span style=\"white-space:pre\"> </span>// TODO Auto-generated catch block</p> \n <p><span style=\"white-space:pre\"> </span>e.printStackTrace();</p> \n <p><span style=\"white-space:pre\"> </span>date = new Date();</p> \n <p><span style=\"white-space:pre\"> </span>} finally {</p> \n <p><span style=\"white-space:pre\"> </span>session.close();</p> \n <p><span style=\"white-space:pre\"> </span>}</p> \n <p>Sub中用的是Hibernate 3.6.0 Final版本,IVY依赖如下<br></p> \n <p>&lt;dependency org=\"org.hibernate\" name=\"hibernate-core\" rev=\"<span style=\"line-height: 22.5px;\">&nbsp;3.6.0 Final</span>\" conf=\"<span style=\"color: rgb(255, 0, 0);\"><strong>compile-&gt;default</strong></span>\"/&gt;</p> \n <p>只是参与编译，不会编译到Sub jar中。</p> \n <p>M依赖的是Hibernate 3.3.2.GA版本，</p> \n <p>&lt;dependency org=\"org.hibernate\" name=\"hibernate-core\" rev=\"<span style=\"line-height: 22.5px;\">&nbsp;3.3.2.GA</span>\" conf=\"<span style=\"color: rgb(255, 0, 0);\"><strong>zip-&gt;default</strong></span>\"/&gt;</p> \n <p>二，现象。</p> \n <p>那么，问题来了，目前依赖情况会导致M 项目起不来，报错为：</p> \n <p>信息: Illegal access: this web application instance has been stopped already. &nbsp;Could not load org.apache.commons.pool2.impl.DefaultPooledObject. &nbsp;The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to terminate the thread which caused the illegal access, and has no functional impact.</p> \n <p>java.lang.IllegalStateException</p> \n <p><span style=\"white-space:pre\"> </span>at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1750)</p> \n <p><span style=\"white-space:pre\"> </span>at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1709)</p> \n <p><span style=\"white-space:pre\"> </span>at redis.clients.jedis.JedisFactory.makeObject(JedisFactory.java:80)</p> \n <p><span style=\"white-space:pre\"> </span>at org.apache.commons.pool2.impl.GenericObjectPool.create(GenericObjectPool.java:836)</p> \n <p><span style=\"white-space:pre\"> </span>at org.apache.commons.pool2.impl.GenericObjectPool.ensureIdle(GenericObjectPool.java:895)</p> \n <p><span style=\"white-space:pre\"> </span>at org.apache.commons.pool2.impl.GenericObjectPool.ensureMinIdle(GenericObjectPool.java:874)</p> \n <p><span style=\"white-space:pre\"> </span>at org.apache.commons.pool2.impl.BaseGenericObjectPool$Evictor.run(BaseGenericObjectPool.java:1055)</p> \n <p><span style=\"white-space:pre\"> </span>at java.util.TimerThread.mainLoop(Unknown Source)</p> \n <p><span style=\"white-space:pre\"> </span>at java.util.TimerThread.run(Unknown Source)</p> \n <p>如果把M中对Hibernate的依赖也换成 3.6.0.Final则在运行到上边代码段时会出现&nbsp;&nbsp;java.lang.NoSuchFieldError: TIMESTAMP。</p> \n <p>三、应对策略</p> \n <p>之前有同事提醒我说，Sub中Hibernate Core只参与编译，所以一直没往sub中考虑，无奈怎么试都有问题，最后想到把Sub中HibernateCore换成3.3.2.GA版本，问题消失，然后，为啥会这样？留个尾巴，继续找吧，找到了再来更新。</p> \n</div>',NULL,'2020-02-02 19:05:09',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223925670875320320',NULL,NULL,' hibernate flush 机制与调用 save 后不立即打印 sql 的问题  ','<div class=\"content\" id=\"articleContent\">\n  针对昨天同事遇到的hibernate的问题。算是hibernate最基本的东西。具了解，这个问题很多人遇到过，也很常见，却遇到了还经常会懵了。 \n <div>\n   &nbsp; \n </div> \n <div>\n   为了加深印象，知其然，知其所以然。 \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   之后单纯用原始的Hibernate框架做了一些验证，并且打开执行SQL打印输出台的，得出的结论： \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   前提是在同一事务中间： \n </div> \n <div>\n   &nbsp; \n </div> \n <div> \n  <span style=\"color:#008080;\">1、利用sql语句， session.createSQLQuery(sql).executeUpdate();进行插入，输出台打印出sql插入语句； 再利用sql语句，进行session.createSQLQuery(sql).uniqueResult(); 也会打印SQL查询语句，没有问题，可以查询到数据。</span> \n </div> \n <div> \n  <span style=\"color:#008080;\">&nbsp;</span> \n </div> \n <div> \n  <span style=\"color:#008080;\">2、利用hibernate封装操作， session.save(entity); 进行插入，输出台并没有打印出插入的SQL语句， 再利用 session.get(entity,id);方法做查询 ；也没有打印出SQL查询语句，但是是可以查询到数据的。到执行事务提交语句时，插入的SQL语句被打印出来</span> \n </div> \n <div> \n  <span style=\"color:#008080;\">&nbsp;</span> \n </div> \n <div> \n  <span style=\"color:#008080;\">3、利用hibernate的session.save(entity); 进行插入，再利用《HQL》语句进行查询，效果同上面第二点。</span> \n </div> \n <div> \n  <span style=\"color:#008080;\">&nbsp;</span> \n </div> \n <div> \n  <span style=\"color:#008080;\">4、利用hibernate的session.save(entity); 进行插入，输出台并没有打印出插入的SQL语句。 再利用sql语句，进行session.createSQLQuery(sql).uniqueResult(); 会打印SQL查询语句。问题出现了，查询不到任何数据。这种情况下利用session.flush()方法，在查询之前执行到flush()方法，输出台 会打印出插入的SQL语句。 再进行查询就有数据。</span> \n </div> \n <div> \n  <span style=\"color:#339966;\">&nbsp;</span> \n </div> \n <div>\n   验证完成之后，查了下往上资料，对于第四点，在开发过程中出现频繁， \n  <span><span style=\"color:#008080;\">非常的常见，相信很多人都曾遇到，但又有很多人继续摸不到头脑</span>。</span>正好以此加深了印象。 \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   从打印控制台SQL可以看出：一个基本的hibernate save方法的操作流程： \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   1． 判断所要保存的实例是否已处于持久化状态，如果不是，则将其置入缓存； \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   2． 根据所要保存的实例计划一条insert sql语句，注意只是计划，并不执行； \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   3． 事务提交时执行之前所计划的insert语句； \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   将tx.commit()换成session.flush，此时控制太打印出了insert语句，但是数据库中并没有添加新的记录； \n </div> \n <div>\n   &nbsp; \n </div> \n <div> \n  <span style=\"color:#008080;\">flush方法的主要作用就是清理缓存，强制数据库与Hibernate缓存同步，以保证数据的一致性。</span>它 的主要动作就是向数据库发送一系列的sql语句，并执行这些sql语句，但是不会向数据库提交。而commit方法则会首先调用flush方法，然后提交 事务。这就是为什么我们仅仅调用flush的时候记录并未插入到数据库中的原因，因为只有提交了事务，对数据库所做的更新才会被保存下来。因为 commit方法隐式的调用了flush，所以一般我们都不会显示的调用flush方法。 \n </div> \n <p> 这是hibernate的flush机制。在一些复杂的对象更新和保存的过程中就要考虑数据库操作顺序的改变以及延时flush是否对程序的结果有 影响。如果确实存在着影响，那就可以在需要保持这种操作顺序的位置加入flush强制Hibernate将缓存中记录的操作flush入数据库，这样看起 来也许不太美观，但很有效。 </p> \n <br> \n</div>',NULL,'2020-02-02 19:06:34',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223926032457879552',NULL,NULL,' CentOS配置Tomcat监听80端口,虚拟主机  ','<div class=\"content\" id=\"articleContent\"> \n <h3>Tomcat更改默认端口为80</h3> \n <p>更改的配置文件是: /usr/local/tomcat/conf/server.xml</p> \n <pre><code>[root@test-a ~]# vim /usr/local/tomcat/conf/server.xml  # 找到 Connector port=\"8080\" protocol=\"HTTP/1.1\"修改为Connector port=\"80\" \n[root@test-a ~]#\n[root@test-a ~]# netstat -ntlp | grep 80\ntcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN                                                1711/nginx: master\n[root@test-a ~]# /etc/init.d/nginx stop\nStopping nginx (via systemctl):                            [  OK  ]\n[root@test-a ~]#\n[root@test-a ~]# netstat -ntlp | grep 80\n\n[root@test-a ~]# /usr/local/tomcat/bin/startup.sh\nUsing CATALINA_BASE:   /usr/local/tomcat\nUsing CATALINA_HOME:   /usr/local/tomcat\nUsing CATALINA_TMPDIR: /usr/local/tomcat/temp\nUsing JRE_HOME:        /usr/local/jdk1.8\nUsing CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar\nTomcat started.\n[root@test-a ~]#\n[root@test-a ~]# netstat -ntlp | grep 80\ntcp6       0      0 :::8009                 :::*                    LISTEN      2668/java\ntcp6       0      0 :::80                   :::*                    LISTEN      2668/java\n[root@test-a ~]#\n\n</code></pre> \n <h3>CentOS通过Tomcat安装zrlog博客系统</h3> \n <ul> \n  <li>vim /usr/local/tomcat/conf/server.xml<br> 其中&lt;Host&gt;和&lt;/Host&gt;之间的配置为虚拟主机配置部分，name定义域名， appBase定义应用的目录，Java的应用通常是一个war的压缩包，只需要将war的压缩包放到appBase目录下面即可</li> \n </ul> \n <pre><code>[root@test-a src]# wget http://dl.zrlog.com/release/zrlog-1.7.1-baaecb9-release.war\n--2018-12-14 08:54:46--  http://dl.zrlog.com/release/zrlog-1.7.1-baaecb9-release.war\nResolving dl.zrlog.com (dl.zrlog.com)... 124.193.230.187, 124.202.188.152, 124.202.188.151, ...\nConnecting to dl.zrlog.com (dl.zrlog.com)|124.193.230.187|:80... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 7122027 (6.8M) [application/zip]\nSaving to: ‘zrlog-1.7.1-baaecb9-release.war’\n\n100%[================================================================================&gt;] 7,122,027   2.52MB/s   in 2.7s\n\n2018-12-14 08:54:54 (2.52 MB/s) - ‘zrlog-1.7.1-baaecb9-release.war’ saved [7122027/7122027]\n\n[root@test-a src]# cp zrlog-1.7.1-baaecb9-release.war /usr/local/tomcat/webapps/\n\n[root@test-a src]# ls /usr/local/tomcat/webapps/ # 可以看到war包被自动解压了\ndocs  examples  host-manager  manager  ROOT  zrlog-1.7.1-baaecb9-release  zrlog-1.7.1-baaecb9-release.war\n[root@test-a src]#\n[root@test-a src]# mv /usr/local/tomcat/webapps/zrlog-1.7.1-baaecb9-release /usr/local/tomcat/webapps/zrlog  # 重命名\n[root@test-a src]# ls /usr/local/tomcat/webapps/\ndocs  examples  host-manager  manager  ROOT  zrlog  zrlog-1.7.1-baaecb9-release.war\n[root@test-a src]#\n[root@test-a src]# ls /usr/local/tomcat/webapps/  # 重命名后，又会自动解压war包\ndocs  examples  host-manager  manager  ROOT  zrlog  zrlog-1.7.1-baaecb9-release  zrlog-1.7.1-baaecb9-release.war\n[root@test-a src]# rm /usr/local/tomcat/webapps/zrlog-1.7.1-baaecb9-release.war\nrm: remove regular file ‘/usr/local/tomcat/webapps/zrlog-1.7.1-baaecb9-release.war’? y\n\n[root@test-a src]# ls /usr/local/tomcat/webapps/ # 删除war包也会自动删除对应解压的目录\ndocs  examples  host-manager  manager  ROOT  zrlog\n\n[root@test-a src]#\n[root@test-a src]# systemctl stop firewalld.service # 关闭防火墙进行访问测试\n</code></pre> \n <p>访问测试,进入安装页面<br> <img src=\"https://oscimg.oschina.net/oscnet/97b6d8471097741225da20585a18fe5cb2c.jpg\" alt=\"\"></p> \n <p>需要创建对应的数据库及用户</p> \n <pre><code>[root@test-a src]# mysql -uroot -p\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 2\nServer version: 5.7.23 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\n\nmysql&gt; create database zrlog;\nQuery OK, 1 row affected (0.04 sec)\n\nmysql&gt; grant all on zrlog.* to zrlog identified by \'test111\';\nQuery OK, 0 rows affected, 1 warning (0.10 sec)\n\nmysql&gt; quit\nBye\n[root@test-a src]# mysql -uzrlog -p # 测试用新用户登录\nEnter password:\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 3\nServer version: 5.7.23 MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType \'help;\' or \'\\h\' for help. Type \'\\c\' to clear the current input statement.\n\nmysql&gt; quit\nBye\n\n</code></pre> \n <p>填入mysql用户名和密码后下一步<br> <img src=\"https://oscimg.oschina.net/oscnet/555c53db331ae574ce027571672b3c06ec9.jpg\" alt=\"\"></p> \n <p>填入管理员的用户名密码后完成安装<br> <img src=\"https://oscimg.oschina.net/oscnet/1177cba05169d49a2de1855ee09d6c7739f.jpg\" alt=\"\"></p> \n <p>进入主页，说明安装成功<br> <img src=\"https://oscimg.oschina.net/oscnet/d3a4515c7e5ca78c0490ea48f99e6e2a3a4.jpg\" alt=\"\"></p> \n <h3>Tomcat配置虚拟主机</h3> \n <ul> \n  <li> <p>vim /usr/local/tomcat/conf/server.xml<br> 其中&lt;Host&gt;和&lt;/Host&gt;之间的配置为虚拟主机配置部分，name定义域名， appBase定义应用的目录，Java的应用通常是一个war的压缩包，只需要将war的压缩包放到appBase目录下面即可</p> </li> \n  <li> <p>增加虚拟主机，编辑server.xml,在&lt;/Host&gt;下面增加如下内容<br> &lt;Host name=\"www.666.cn\" appBase=\"\" unpackWARs= \"true\" autoDeploy=\"true\" xmlValidation=\"false\" xmlNamespaceAware=\"false\"&gt;<br> &lt;Context path=\"\" docBase=\"/data/wwwroot/666.cn/\" debug=\"0\" reloadable=\"true\" crossContext=\"true\"/&gt;</p> </li> \n </ul> \n <p>&lt;/Host&gt; </p> \n <ul> \n  <li>docBase，这个参数用来定义网站的文件存放路径，如果不定义，默认是在appBase/ROOT下面，定义了docBase就以该目录为主了，其中appBase和docBase可以一样。<br> appBase为应用存放目录，通常是需要把war包直接放到该目录下面，它会自动解压成一个程序目录</li> \n </ul> \n <pre><code>[root@test-a src]# vim /usr/local/tomcat/conf/server.xml # 添加虚拟主机配置\n[root@test-a ~]# mkdir /data/wwwroot/666.cn # 创建新站目录\n[root@test-a ~]# mv /usr/local/tomcat/webapps/zrlog/* /data/wwwroot/666.cn/ # 把之前安装的zrlog所有文件移到虚拟站点\n# 重新启动\n[root@test-a src]# /usr/local/tomcat/bin/shutdown.sh\nUsing CATALINA_BASE:   /usr/local/tomcat\nUsing CATALINA_HOME:   /usr/local/tomcat\nUsing CATALINA_TMPDIR: /usr/local/tomcat/temp\nUsing JRE_HOME:        /usr/local/jdk1.8\nUsing CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar\n[root@test-a src]# /usr/local/tomcat/bin/startup.sh\nUsing CATALINA_BASE:   /usr/local/tomcat\nUsing CATALINA_HOME:   /usr/local/tomcat\nUsing CATALINA_TMPDIR: /usr/local/tomcat/temp\nUsing JRE_HOME:        /usr/local/jdk1.8\nUsing CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar\nTomcat started.\n\n</code></pre> \n <p>修改hosts指定www.666.cn的ip为192.168.77.134后访问:</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/eed6d4b9735bfdf171267471e5bd4d72c44.jpg\" alt=\"\"></p> \n <h3>Tomcat 日志</h3> \n <ul> \n  <li>路径 /usr/local/tomcat/logs</li> \n  <li>其中catalina开头的日志为Tomcat的综合日志，它记录Tomcat服务相关信息，也会记录错误日志。</li> \n  <li>catalina.2017-xx-xx.log和catalina.out内容相同，前者会每天生成一个新的日志。</li> \n  <li>host-manager和manager为管理相关的日志，其中host-manager为虚拟主机的管理日志。</li> \n  <li>localhost和localhost_access为虚拟主机相关日志，其中带access字样的日志为访问日志，不带access字样的为默认虚拟主机的错误日志。</li> \n  <li>访问日志默认不会生成，需要在server.xml中配置一下。</li> \n  <li>具体方法是在对应虚拟主机的&lt;Host&gt;&lt;/Host&gt;里面加入下面的配置（假如域名为666.cn）：</li> \n  <li> <p>&lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"logs\" prefix=\"666.cn_access\" suffix=\".log\" pattern=\"%h %l %u %t %r %s %b\" /&gt; </p> </li> \n  <li>prefix定义访问日志的前缀，suffix定义日志的后缀，pattern定义日志格式。新增加的虚拟主机默认并不会生成类似默认虚拟主机的那个localhost.日期.log日志，错误日志会统一记录到catalina.out中。关于Tomcat日志你最需要关注catalina.out，当出现问题时，应该第一想到去查看它。</li> \n </ul> \n</div>',NULL,'2020-02-02 19:08:00',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223926389988741120',NULL,NULL,' Xshell利用Xftp传输文件,使用pure-ftpd搭建ftp服务  ','<div class=\"content\" id=\"articleContent\"> \n <h3>Xftp传输文件</h3> \n <p>如果已经通过Xshell登录到服务器，此时可以使用快捷键ctrl+alt+f 打开Xftp并展示Xshell当前的目录，之后直接拖拽传输文件即可。<br> <img src=\"https://oscimg.oschina.net/oscnet/37d15e62c7ac71aef8b35fe430a093e06f1.jpg\" alt=\"\"></p> \n <h3>pure-ftpd搭建ftp服务</h3> \n <p><strong>pure-ftpd要比vsftp简单，轻量</strong></p> \n <p>安装pure-ftpd，安装报错了，从网上知道了是python的urlgrabber脚本有bug</p> \n <pre><code>[root@test-a vsftpd_user_conf]# yum install -y pure-ftpd\nLoaded plugins: fastestmirror\nbase                                                                 | 3.6 kB  00:00:00\nepel/x86_64/metalink                                                 | 7.0 kB  00:00:00\nepel                                                                 | 3.2 kB  00:00:00\nextras                                                               | 3.4 kB  00:00:00\nupdates                                                              | 3.4 kB  00:00:00\nTraceback (most recent call last):\n  File \"/usr/libexec/urlgrabber-ext-down\", line 75, in &lt;module&gt;\n    main()\n  File \"/usr/libexec/urlgrabber-ext-down\", line 61, in main\n    fo = PyCurlFileObject(opts.url, opts.filename, opts)\n  File \"/usr/lib/python2.7/site-packages/urlgrabber/grabber.py\", line 1258, in __init__\n    self._do_open()primary      0% [                      ]  0.0 B/s |    0 B  --:--:-- ETA\n  File \"/usr/lib/python2.7/site-packages/urlgrabber/grabber.py\", line 1589, in _do_open\n    self._do_grab()\n  File \"/usr/lib/python2.7/site-packages/urlgrabber/grabber.py\", line 1723, in _do_grab\n    self._do_perform()\n  File \"/usr/lib/python2.7/site-packages/urlgrabber/grabber.py\", line 1517, in _do_perform\n    raise KeyboardInterrupt\nKeyboardInterrupt\n\n\nExiting on user cancel\n\n\n# 解决错误\n[root@test-a ~]# vim /usr/lib/python2.7/site-packages/urlgrabber/grabber.py  \n#elif errcode in (42, 55, 56): 找到这行换成下面的，再次安装即可\n#elif errcode in [42]:\n\n[root@test-a ~]# yum install -y pure-ftpd\n</code></pre> \n <p>配置及测试:</p> \n <pre><code># 先把之前的ftpd服务关了\n[root@test-a ~]# systemctl stop vsftpd.service\n\n[root@test-a ~]# vim /etc/pure-ftpd/pure-ftpd.conf # 搜索pureftpd.pdb，去掉这行前面的#\n\n# 启动服务\n[root@test-a ~]# systemctl start pure-ftpd\n# 查看服务\n[root@test-a ~]# netstat -ntlp | grep ftp\ntcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      19022/pure-ftpd (SE\ntcp6       0      0 :::21                   :::*                    LISTEN      19022/pure-ftpd (SE\n\n\n[root@test-a ~]# useradd ftpuser02\n[root@test-a ~]# mkdir /tmp/pureftp\n[root@test-a ~]# chown -R ftpuser02:ftpuser02 /tmp/pureftp/\n[root@test-a ~]# pure-pw useradd virftpuser02 -u ftpuser02 -d /tmp/pureftp/  # virftpuser02 虚拟用户，-u 指定对应的真实用户 -d分享目录\nPassword:\nEnter it again:\n[root@test-a ~]# pure-pw mkdb # 使密码生成系统需要的二进制形式\n[root@test-a ~]# touch /tmp/pureftp/1111.txt # 创建测试文件\n[root@test-a ~]# lftp virftpuser02@127.0.0.1 # 登录测试\nPassword:\nlftp virftpuser02@127.0.0.1:~&gt; ls\ndrwxr-xr-x    2 1010       ftpuser02          21 Dec 12 09:56 .\ndrwxr-xr-x    2 1010       ftpuser02          21 Dec 12 09:56 ..\n-rw-r--r--    1 0          0                   0 Dec 12 09:56 1111.txt\nlftp virftpuser02@127.0.0.1:/&gt;\n\n\n</code></pre> \n</div>',NULL,'2020-02-02 19:09:25',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223926751491608576',NULL,NULL,' 在阿里云上打造属于你自己的APEX完整开发环境 (安装CentOS, Tomcat, Nginx)  ','<div class=\"content\" id=\"articleContent\"> \n <p>Oracle APEX 系列文章3：在阿里云上打造属于你自己的APEX完整开发环境 (安装CentOS, Tomcat, Nginx)</p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqy4n04lv1j30s207oaeu.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqy4n04lv1j30s207oaeu.jpg\"></a></p> \n <p>本文是钢哥的Oracle APEX系列文章中的第三篇，完整 Oracle APEX 系列文章如下：</p> \n <ul> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-1/\" rel=\"nofollow\">Oracle APEX 系列文章1：Oracle APEX, 让你秒变全栈开发的黑科技</a></li> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-2/\" rel=\"nofollow\">Oracle APEX 系列文章2：在阿里云上打造属于你自己的APEX完整开发环境 (准备工作)</a></li> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-3/\" rel=\"nofollow\">Oracle APEX 系列文章3：在阿里云上打造属于你自己的APEX完整开发环境 (安装CentOS, Tomcat, Nginx)</a></li> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-4/\" rel=\"nofollow\">Oracle APEX 系列文章4：在阿里云上打造属于你自己的APEX完整开发环境 (安装XE, ORDS, APEX)</a></li> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-5/\" rel=\"nofollow\">Oracle APEX 系列文章5：在阿里云上打造属于你自己的APEX完整开发环境 (进一步优化)</a></li> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-6/\" rel=\"nofollow\">Oracle APEX 系列文章6：Oracle APEX 到底适不适合企业环境？</a></li> \n  <li><a href=\"https://wangfanggang.com/Oracle/Oracle-APEX/apex-series-7/\" rel=\"nofollow\">Oracle APEX 系列文章7：Oracle APEX 18.1 新特性</a></li> \n </ul> \n <span id=\"OSC_h2_1\"></span> \n <h2>引言</h2> \n <p>在这一章节里，我们将一起动手安装 Tomcat 以及 Nginx，并为后面的安装做一些初始化设置。</p> \n <span id=\"OSC_h2_2\"></span> \n <h2>安装配置CentOS 7</h2> \n <span id=\"OSC_h3_3\"></span> \n <h3>在阿里云控制台购买并启动CentOS</h3> \n <p>之前说过，我们选择阿里云作为云提供商。注册步骤就不展开了，大家可以到<a href=\"https://account.aliyun.com/\" target=\"_blank\" rel=\"nofollow\">阿里云官网</a>进行注册。注册完账号并成功登陆<strong>控制台</strong>，点击左侧导航菜单<code>云服务器 ECS</code>，再点击<code>创建实例</code>按钮，如下图所示：</p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyec6pcb4j32801e0av0.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyec6pcb4j32801e0av0.jpg\"></a></p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyeo45l4sj32761z6kcm.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyeo45l4sj32761z6kcm.jpg\"></a></p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyestr10wj32761gsgzl.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyestr10wj32761gsgzl.jpg\"></a></p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyewtmpe1j32761727f0.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyewtmpe1j32761727f0.jpg\"></a></p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyeyunjqmj32761es4b3.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyeyunjqmj32761es4b3.jpg\"></a></p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyezqv2tlj30ru0ki0vh.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyezqv2tlj30ru0ki0vh.jpg\"></a></p> \n <p>系统提示创建成功，返回<code>管理控制台</code>稍等片刻，等待系统状态变为<code>运行中</code>即表示系统已创建完毕。</p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyf5f0yumj31xa0hyah2.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyf5f0yumj31xa0hyah2.jpg\"></a></p> \n <p>用你习惯的ssh工具（如iTerm2、PuTTY等）登录测试一下，第一次会询问是否将该IP地址加到可信任站点名单，直接<code>yes</code>后输入刚才设置的<code>root</code>密码，如果看到下面的结果，就表示CentOS系统安装完毕。</p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyfaeujvoj30wo09wac0.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyfaeujvoj30wo09wac0.jpg\"></a></p> \n <span id=\"OSC_h3_4\"></span> \n <h3>升级CentOS系统包</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>yum upgrade -y</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyfg0qdqoj328016mdu8.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyfg0qdqoj328016mdu8.jpg\"></a></p> \n <span id=\"OSC_h3_5\"></span> \n <h3>安装必要的工具包</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>yum install java-1.8.0-openjdk.x86_64 java-1.8.0-openjdk-devel.x86_64 libaio flex bc mc net-tools.x86_64 htop iotop iftop unzip wget epel-release vim rlwrap -y</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p>安装完成后，执行<code>java -version</code>验证jdk是否安装成功。<br> <a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyfickthwj30mu05i3zg.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyfickthwj30mu05i3zg.jpg\"></a></p> \n <span id=\"OSC_h3_6\"></span> \n <h3>同步网络时间</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2</pre> </td> \n    <td> <pre>systemctl start chronyd\r\nsystemctl enable chronyd</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_7\"></span> \n <h3>配置 /etc/hosts 文件</h3> \n <p>修改<code>/etc/hosts</code>文件，增加对本机的解析<br> <a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1frpytz7xmyj30v4030t8z.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1frpytz7xmyj30v4030t8z.jpg\"></a></p> \n <span id=\"OSC_h3_8\"></span> \n <h3>关闭SELinux</h3> \n <p>修改<code>/etc/sysconfig/selinux</code>文件，将<code>SELINUX</code>的值从<code>enforcing</code>改成<code>disabled</code>。</p> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>SELINUX=disabled</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p>&nbsp;</p> \n <p>然后执行<code>setenforce 0</code>命令使之生效。</p> \n <blockquote> \n  <p>钢哥注：感谢QQ网友<code>万有引力-yrj</code>友情提醒。</p> \n </blockquote> \n <span id=\"OSC_h2_9\"></span> \n <h2>安装配置Tomcat服务器</h2> \n <blockquote> \n  <p>钢哥提示：Tomcat安装这部分是个大坑。由于最新的ORDS 18需要Tomcat 8.5以上版本，且jdk 1.8以上，而目前网上的教程都是用yum直接安装Tomcat（版本是7的），导致版本不兼容，后面配置ORDS会发生错误，所以这里不要采用yum安装Tomcat，而是手动安装。</p> \n </blockquote> \n <span id=\"OSC_h3_10\"></span> \n <h3>添加tomcat用户和用户组</h3> \n <blockquote> \n  <p>如果之前安装过tomcat，对应的用户和组已经存在的话，会提示个警告，忽略即可。<br> 可以用&nbsp;<code>yum -y remove tomcat*</code>来卸载之前yum安装的tomcat。</p> \n </blockquote> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2\r\n3\r\n4\r\n5</pre> </td> \n    <td> <pre>## 创建tomcat安装目录\r\nmkdir -p /u01/tomcat\r\n\r\ngroupadd tomcat\r\nuseradd -s /bin/false -g tomcat -d /u01/tomcat tomcat</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_11\"></span> \n <h3>下载 Tomcat 8.5 以上安装包</h3> \n <p>到&nbsp;<a href=\"http://tomcat.apache.org/\" target=\"_blank\" rel=\"nofollow\">Apache Tomcat 官网</a>下载Tomcat 8.5以上安装包，本次下载的Tomcat版本是8.5.31的，你可以自行选择，只要高于8.5版本即可。</p> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2\r\n3</pre> </td> \n    <td> <pre>cd /u01/media\r\n\r\nwget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.31/bin/apache-tomcat-8.5.31.zip</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p>&nbsp;</p> \n <span id=\"OSC_h3_12\"></span> \n <h3>安装 Tomcat 8.5</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9</pre> </td> \n    <td> <pre>## 先将下载的zip文件解压缩\r\nunzip apache-tomcat-8.5.31.zip\r\n\r\n## 将解压缩后的文件挪到安装目录中\r\nmv apache-tomcat-8.5.31/* /u01/tomcat\r\n\r\n## 授权\r\nchmod -Rf 755 /u01/tomcat/bin/\r\nchown -hR tomcat:tomcat /u01/tomcat</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_13\"></span> \n <h3>新增一个<code>tomcat.service</code>文件</h3> \n <p>你可以像我一样直接用<code>vim</code>命令新增文件，然后添加内容。不熟悉vim命令的请移步这里：<a href=\"https://mp.weixin.qq.com/s/zZAWpZbDtSFK6EROxaBRKw\" target=\"_blank\" rel=\"nofollow\">有关vi(vim)的常用命令</a>。<br> 或者在本地编辑好，再用ftp工具上传到服务器<code>/etc/systemd/system/</code>目录中。</p> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>vim /etc/systemd/system/tomcat.service</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p>&nbsp;</p> \n <p><code>tomcat.service</code>文件的内容如下：</p> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n13\r\n14\r\n15\r\n16\r\n17</pre> </td> \n    <td> <pre>[Unit]\r\nDescription=Apache Tomcat 8 Servlet Container\r\nAfter=syslog.target network.target\r\n\r\n[Service]\r\nUser=tomcat\r\nGroup=tomcat\r\nType=forking\r\nEnvironment=CATALINA_PID=/u01/tomcat/tomcat.pid\r\nEnvironment=CATALINA_HOME=/u01/tomcat\r\nEnvironment=CATALINA_BASE=/u01/tomcat\r\nExecStart=/u01/tomcat/bin/startup.sh\r\nExecStop=/u01/tomcat/bin/shutdown.sh\r\nRestart=on-failure\r\n\r\n[Install]\r\nWantedBy=multi-user.target</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p>&nbsp;</p> \n <span id=\"OSC_h3_14\"></span> \n <h3>设置 tomcat 启动目录权限</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>chmod 755 /u01/tomcat/bin</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_15\"></span> \n <h3>将 tomcat 服务设置成自启动。</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2\r\n3</pre> </td> \n    <td> <pre>systemctl daemon-reload\r\nsystemctl start tomcat\r\nsystemctl enable tomcat</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_16\"></span> \n <h3>检查 tomcat 服务是否正常启动</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>systemctl status tomcat</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p>如果如下图所示，证明已正常启动。<br> <a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fr0ax0cmu6j315y0c8tbx.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fr0ax0cmu6j315y0c8tbx.jpg\"></a></p> \n <blockquote> \n  <p>如果想重启Tomcat，可以执行<code>systemctl restart tomcat</code><br> 更多有关在CentOS 7上安装 tomcat 8.5 的信息可以参考这里：<a href=\"https://www.howtoforge.com/tutorial/how-to-install-tomcat-on-centos/\" target=\"_blank\" rel=\"nofollow\">How to Install Apache Tomcat 8.5 on CentOS 7.3</a></p> \n </blockquote> \n <span id=\"OSC_h3_17\"></span> \n <h3>开启8080端口</h3> \n <p>阿里云的服务器安全组类似CentOS的防火墙，可以配置到多台ECS服务器上，管理上更加灵活。</p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyg6vsoq8j31xa0hy0yz.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyg6vsoq8j31xa0hy0yz.jpg\"></a></p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyg8rmtwpj327o0hu44c.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyg8rmtwpj327o0hu44c.jpg\"></a></p> \n <p>目前我们的ECS启用了如下端口：</p> \n <ul> \n  <li>80：http端口；</li> \n  <li>443：https端口；</li> \n  <li>22：ssh端口；</li> \n  <li>3389：Windows远程桌面端口（我们用不上）；</li> \n </ul> \n <p>点击<code>快速创建规则</code>按钮新增一条安全组规则：<br> <a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqygakup0jj32720ueqed.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqygakup0jj32720ueqed.jpg\"></a></p> \n <blockquote> \n  <p>这里我们要新增一条安全组规则，把<code>8080</code>端口开放出来，方便我们测试Tomcat是否安装成功。后面设置好 Nginx 以后，所有http请求会通过Nginx转发到Tomcat的8080端口上，这时再把8080端口关闭掉，让系统更加安全。</p> \n </blockquote> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqygh0qhnwj30xa12k42c.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqygh0qhnwj30xa12k42c.jpg\"></a></p> \n <span id=\"OSC_h3_18\"></span> \n <h3>测试Tomcat</h3> \n <p>打开浏览器，访问<code>http://47.100.207.171:8080/</code>&nbsp;(把IP地址换成你自己的)，如果能看到下面的页面，证明Tomcat安装完毕。<br> <a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fr0ba38nq2j31km10eqj6.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fr0ba38nq2j31km10eqj6.jpg\"></a></p> \n <span id=\"OSC_h3_19\"></span> \n <h3>Tomcat重要目录及文件</h3> \n <ul> \n  <li><code>/u01/tomcat</code>&nbsp;Tomcat默认的安装目录；</li> \n  <li><code>/u01/tomcat/conf/server.xml</code>&nbsp;Tomcat的主配置文件，包含service, connectors, engine, realm, valve, hosts等组件；</li> \n  <li><code>/u01/tomcat/conf/web.xml</code>&nbsp;遵循Servlet规范标准的配置文件，用于配置servlet，并为所有的Web应用程序提供包括MIME映射等默认配置信息；</li> \n  <li><code>/u01/tomcat/conf/tomcat-user.xml</code>&nbsp;Realm认证时用到的相关角色、用户和密码等信息；Tomcat自带的manager默认情况下会用到此文件；在Tomcat中添加/删除用户，为用户指定角色等将通过编辑此文件实现；</li> \n  <li><code>/u01/tomcat/conf/catalina.policy</code>&nbsp;java相关的安全策略配置文件，在系统资源级别上提供访问控制的能力；</li> \n  <li><code>/u01/tomcat/conf/catalina.properties</code>&nbsp;Tomcat内部package的定义及访问相关的控制，也包括对通过类装载器装载的内容的控制；Tomcat在启动时会事先读取此文件的相关设置；</li> \n  <li><code>/u01/tomcat/conf/logging.properties</code>&nbsp;Tomcat通过自己内部实现的JAVA日志记录器来记录操作相关的日志，此文件即为日志记录器相关的配置信息，可以用来定义日志记录的组件级别以及日志文件的存在位置等；</li> \n  <li><code>/u01/tomcat/conf/context.xml</code>&nbsp;所有host的默认配置信息；</li> \n </ul> \n <span id=\"OSC_h2_20\"></span> \n <h2>安装配置Nginx</h2> \n <span id=\"OSC_h3_21\"></span> \n <h3>安装Nginx</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>yum install nginx -y</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_22\"></span> \n <h3>设置Nginx以便下次自启动</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1\r\n2</pre> </td> \n    <td> <pre>systemctl start nginx\r\nsystemctl enable nginx</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h3_23\"></span> \n <h3>检查Nginx是否已启动</h3> \n <table> \n  <tbody> \n   <tr> \n    <td> <pre>1</pre> </td> \n    <td> <pre>systemctl status nginx</pre> </td> \n   </tr> \n  </tbody> \n </table> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyiireudmj313w0ee0wm.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyiireudmj313w0ee0wm.jpg\"></a></p> \n <span id=\"OSC_h3_24\"></span> \n <h3>测试Nginx</h3> \n <p>打开浏览器，访问<code>http://106.14.172.85</code>&nbsp;(把IP地址换成你自己的)，如果能看到下面的页面，证明Nginx安装完毕。</p> \n <p><a href=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyikeh72nj31ey0ocq6y.jpg\" rel=\"nofollow\"><img alt=\"\" src=\"https://ws1.sinaimg.cn/large/006By2pOgy1fqyikeh72nj31ey0ocq6y.jpg\"></a></p> \n <span id=\"OSC_h3_25\"></span> \n <h3>Nginx重要目录及文件</h3> \n <ul> \n  <li><code>/etc/nginx</code>&nbsp;Nginx默认的安装目录；</li> \n  <li><code>/etc/nginx/nginx.conf</code>&nbsp;Nginx默认全局配置文件；</li> \n  <li><code>/etc/nginx/conf.d/</code>&nbsp;Nginx默认子配置文件目录；</li> \n  <li><code>/usr/share/nginx/html/</code>&nbsp;Nginx默认html根目录；</li> \n </ul> \n <span id=\"OSC_h2_26\"></span> \n <h2>总结</h2> \n <p>本文详细介绍了如何在阿里云上购买并启动一个CentOS 7的新实例，以及如何安装、配置和测试Tomcat和Nginx。下一篇文章将着重讲解如何安装配置Oracle数据库（XE）、Oracle APEX以及ORDS，如有遗漏或不准确的地方还请大家指正，谢谢！</p> \n</div>',NULL,'2020-02-02 19:10:52',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223927111593578496',NULL,NULL,' CentOS7源码安装配置Tomcat-8  ','<div class=\"content\" id=\"articleContent\"> \n <p>安装说明&nbsp;<br> 安装环境：CentOS-7<br> 安装方式：源码安装&nbsp;<br> 软件：apache-tomcat-8.0.39.tar.gz<br> 下载地址：<a href=\"http://tomcat.apache.org/download-80.cgi\" target=\"_blank\" rel=\"nofollow\">http://tomcat.apache.org/download-80.cgi</a></p> \n <p>安装前提&nbsp;<br> 系统必须已安装配置JDK6+，安装请参考：<a href=\"https://my.oschina.net/chenshuang/blog/804996\" target=\"_blank\" rel=\"nofollow\">CentOS7安装配置JDK8</a></p> \n <p>安装tomcat&nbsp;<br> 将apache-tomcat-8.0.39.tar.gz文件上传到/usr/local中执行以下操作：&nbsp;</p> \n <pre><code class=\"language-bash\">[root@localhost ~]# cd /usr/local  \n[root@localhost local]# tar -zxv -f apache-tomcat-8.0.39.tar.gz     #解压压缩包  \n[root@localhost local]# rm -rf apache-tomcat-8.0.39.tar.gz          #删除压缩包  </code></pre> \n <p>启动TOMCAT</p> \n <p>执行以下操作：</p> \n <pre><code class=\"language-bash\">[root@centos ~]# /usr/local/apache-tomcat-8.0.39/bin/startup.sh \nUsing CATALINA_BASE:   /usr/local/apache-tomcat-8.0.39\nUsing CATALINA_HOME:   /usr/local/apache-tomcat-8.0.39\nUsing CATALINA_TMPDIR: /usr/local/apache-tomcat-8.0.39/temp\nUsing JRE_HOME:        /usr\nUsing CLASSPATH:       /usr/local/apache-tomcat-8.0.39/bin/bootstrap.jar:/usr/local/apache-tomcat-8.0.39/bin/tomcat-juli.jar\nTomcat started.</code></pre> \n <p>防火墙开放8080端口增加8080端口到防火墙配置中，执行以下操作：</p> \n <pre><code class=\"language-bash\">[root@localhost ~]# vi + /etc/sysconfig/iptables</code></pre> \n <p>增加以下代码：</p> \n <pre><code class=\"language-bash\">-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</code></pre> \n <p>重启防火墙：</p> \n <pre><code class=\"language-bash\">[root@localhost ~]# service iptables restart</code></pre> \n <p>检验Tomcat安装运行：</p> \n <p>通过以下地址查看tomcat是否运行正常：<br> http://127.0.0.1:8080/<br> 看到tomcat系统界面，说明安装成功！</p> \n <p>停止Tomcat：</p> \n <pre><code class=\"language-bash\">[root@localhost ~]# /usr/local/tomcat/bin/shutdown.sh </code></pre> \n <p>将tomcat加入开机自启动：</p> \n <p>修改start.sh文件：</p> \n <pre><code class=\"language-bash\">vim /usr/local/apache-tomcat-8.0.39/bin/startup.sh</code></pre> \n <p>在文件头增加以下内容：</p> \n <pre><code class=\"language-bash\">#!/bin/sh          #以下为增加内容\n# chkconfig: 2345 97 00\n# description:tomcat auto start\n# processname: tomcat</code></pre> \n <p>修改catalina.sh文件</p> \n <pre><code class=\"language-bash\">vim /usr/local/apache-tomcat-8.0.39/bin/catalina.sh</code></pre> \n <p>增加以下内容：</p> \n <pre><code class=\"language-bash\">export CATALINA_BASE=/usr/local/apache-tomcat-8.0.39\nexport CATALINA_HOME=/usr/local/apache-tomcat-8.0.39\nexport CATALINA_TMPDIR=/usr/local/apache-tomcat-8.0.39/temp\nexport JRE_HOME=/usr</code></pre> \n <p>创建链接文件：</p> \n <pre><code class=\"language-bash\">ln -s /usr/local/apache-tomcat-8.0.39/bin/startup.sh /etc/init.d/tomcat</code></pre> \n <p>修改权限：</p> \n <pre><code class=\"language-bash\">chmod +x /etc/init.d/tomcat</code></pre> \n <p>添加启动：</p> \n <pre><code class=\"language-bash\">chkconfig  --add  tomcat \n  \nchkconfig tomcat on</code></pre> \n <p>检查：</p> \n <pre><code class=\"language-bash\">service tomcat start</code></pre> \n <p>或者reboot</p> \n</div>',NULL,'2020-02-02 19:12:18',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223927469917163520',NULL,NULL,' Nginx + Tomcat + Ngx_cache_purge 实现高效反向代理    ','<div class=\"content\" id=\"articleContent\"> \n <p>Nginx处理用户请求的静态页面，tomcat处理用户请求jsp页面，来实现动态分离，前端nginx反向代理后端nginx+tomcat集群，实现负载均衡，这样一来就能更好的提高并发，处理性能，并隐藏后端，提高安全</p> \n <p>环境：&nbsp; <br></p> \n <p>前端： Centos 192.168.0.211： nginx + Ngx_cache_purge <br></p> \n <p>后端1： Centos 192.168.0.222： nginx + Tomcat</p> \n <p>后端2： Centos 192.168.0.223：nginx + Tomcat</p> \n <p>使用软件：</p> \n <p>Nginx： <span style=\"font-size:16px;font-family:\'宋体\';\">http://nginx.org/en/download.html</span></p> \n <p>JDK： http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</p> \n <p>Tomcat： http://tomcat.apache.org/download-80.cgi</p> \n <p><strong>首先配置后端Tomcat：</strong><br></p> \n <p>1，JDK 配置：</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Tomcat&nbsp;~]#&nbsp;tar&nbsp;zxf&nbsp;jdk-8u40-linux-i586.tar.gz\n[root@Tomcat&nbsp;~]#&nbsp;mv&nbsp;jdk1.8.0_40/&nbsp;/usr/local/jdk\n[root@Tomcat&nbsp;~]#&nbsp;vi&nbsp;/etc/profile\nJAVA_HOME=/usr/local/jdk\nPATH=$PATH:$JAVA_HOME/bin\nCLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib\nexport&nbsp;JAVA_HOME&nbsp;PATHCLASSPATH\n[root@Tomcat&nbsp;~]#&nbsp;source&nbsp;/etc/profile\n[root@Tomcat&nbsp;~]#&nbsp;java&nbsp;-version&nbsp;&nbsp;#显示版本说明成功\njava&nbsp;version\"1.8.0_40\"</code></pre> \n <p>2，Tomcat 安装</p> \n <p>先创建普通用户，用来运行tomcat，如遇权限问题，可以先关闭selinux<br></p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Tomcat&nbsp;~]#&nbsp;useradd&nbsp;-s&nbsp;/sbin/nologin&nbsp;tomcat\n[root@Tomcat&nbsp;~]#&nbsp;passwd&nbsp;tomcat\n[root@Tomcat&nbsp;~]#&nbsp;tar&nbsp;zxf&nbsp;apache-tomcat-8.0.21.tar.gz\n[root@Tomcat&nbsp;~]#&nbsp;mv&nbsp;apache-tomcat-8.0.21&nbsp;/usr/local/tomcat\n[root@Tomcat&nbsp;~]#&nbsp;chown&nbsp;tomcat.tomcat&nbsp;-R&nbsp;/usr/local/tomcat\n[root@Tomcat&nbsp;~]#&nbsp;su&nbsp;-&nbsp;tomcat&nbsp;/usr/local/tomcat/bin/startup.sh\n[root@Tomcat&nbsp;~]#&nbsp;echo&nbsp;\"su&nbsp;-&nbsp;tomcat&nbsp;/usr/local/tomcat/bin/startup.sh\"&nbsp;&gt;&gt;&nbsp;/etc/rc.local&nbsp;&nbsp;#开机启动</code></pre> \n <p>3, 安装Nginx</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Tomcat&nbsp;~]#&nbsp;useradd&nbsp;-s&nbsp;/sbin/nologin&nbsp;www\n[root@Tomcat&nbsp;~]#&nbsp;yum&nbsp;install&nbsp;–y&nbsp;make&nbsp;zlib-devel&nbsp;openssl-devel&nbsp;pcre&nbsp;pcre-devel\n[root@Tomcat&nbsp;~]#&nbsp;tar&nbsp;zxvf&nbsp;nginx-1.4.4.tar.gz\n[root@Tomcat&nbsp;~]#&nbsp;cd&nbsp;nginx-1.4.4\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;ulimit&nbsp;-SHn&nbsp;51200\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;./configure&nbsp;--user=www&nbsp;--group=www&nbsp;--prefix=/usr/local/nginx&nbsp;--with-http_stub_status_module&nbsp;--with-http_ssl_module&nbsp;--with-http_realip_module\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;make&nbsp;&amp;&amp;&nbsp;make&nbsp;install\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;\\cp&nbsp;-pa&nbsp;/usr/local/nginx/sbin/nginx&nbsp;/etc/init.d/\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;chmod&nbsp;+x&nbsp;/etc/init.d/nginx\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;echo&nbsp;\"ulimit&nbsp;-SHn&nbsp;51200\"&nbsp;&gt;&gt;&nbsp;/etc/rc.d/rc.local\n[root@Tomcat&nbsp;nginx-1.4.4]#&nbsp;echo&nbsp;\"/etc/init.d/nginx\"&nbsp;&gt;&gt;&nbsp;/etc/rc.d/rc.local&nbsp;#开机启动</code></pre> \n <p>4，主配置文件 nginx.conf</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>user&nbsp;&nbsp;www&nbsp;www;\nworker_processes&nbsp;&nbsp;1;&nbsp;#跟服务器cpu一致就可以了，不要超过cpu的的内核个数，超过将会增加服务器负荷\n\nerror_log&nbsp;&nbsp;logs/error.log;\n#error_log&nbsp;&nbsp;logs/error.log&nbsp;&nbsp;notice;\n#error_log&nbsp;&nbsp;logs/error.log&nbsp;&nbsp;info;\n\npid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logs/nginx.pid;\n\nworker_rlimit_nofile&nbsp;51200;\n\nevents&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;epoll;\n&nbsp;&nbsp;&nbsp;&nbsp;worker_connections&nbsp;&nbsp;51200;\n}\n\nhttp&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mime.types;\n&nbsp;&nbsp;&nbsp;&nbsp;default_type&nbsp;&nbsp;application/octet-stream;\n\n&nbsp;&nbsp;&nbsp;&nbsp;#log_format&nbsp;&nbsp;main&nbsp;&nbsp;\'$remote_addr&nbsp;-&nbsp;$remote_user&nbsp;[$time_local]&nbsp;\"$request\"&nbsp;\'\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'$status&nbsp;$body_bytes_sent&nbsp;\"$http_referer\"&nbsp;\'\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'\"$http_user_agent\"&nbsp;\"$http_x_forwarded_for\"\';\n\n&nbsp;&nbsp;&nbsp;&nbsp;#access_log&nbsp;&nbsp;logs/access.log&nbsp;&nbsp;main;\n&nbsp;&nbsp;&nbsp;&nbsp;server_names_hash_bucket_size&nbsp;128;\n&nbsp;&nbsp;&nbsp;&nbsp;client_header_buffer_size&nbsp;32k;\n&nbsp;&nbsp;&nbsp;&nbsp;large_client_header_buffers&nbsp;4&nbsp;32k;\n&nbsp;&nbsp;&nbsp;&nbsp;server_name_in_redirect&nbsp;off;\n&nbsp;&nbsp;&nbsp;&nbsp;client_max_body_size&nbsp;10m;&nbsp;#允许客户端请求的最大单文件字节数\n&nbsp;&nbsp;&nbsp;&nbsp;client_body_buffer_size&nbsp;128k;&nbsp;&nbsp;#缓冲区代理缓冲用户端请求的最大字节数\n\n&nbsp;&nbsp;&nbsp;&nbsp;sendfile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;tcp_nopush&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;tcp_nodelay&nbsp;&nbsp;&nbsp;&nbsp;on;\n\n&nbsp;&nbsp;&nbsp;&nbsp;#keepalive_timeout&nbsp;&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;keepalive_timeout&nbsp;&nbsp;60;\n&nbsp;&nbsp;&nbsp;&nbsp;set_real_ip_from&nbsp;192.168.0.0/24;&nbsp;#允许被信任ip段\n&nbsp;&nbsp;&nbsp;&nbsp;real_ip_header&nbsp;&nbsp;&nbsp;&nbsp;X-Real-IP;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#获取前端访问真实ip\n\n&nbsp;&nbsp;&nbsp;&nbsp;gzip&nbsp;&nbsp;on;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#开启gzip压缩\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_min_length&nbsp;1k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_buffers&nbsp;4&nbsp;16k;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_http_version&nbsp;1.0;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_comp_level&nbsp;3;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_disable&nbsp;\"MSIE&nbsp;[1-6].\";\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_types&nbsp;text/plain&nbsp;application/x-javascript&nbsp;text/css&nbsp;application/xml&nbsp;image/jpeg&nbsp;image/gif&nbsp;image/png;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_vary&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_proxied&nbsp;any;\n\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_redirect&nbsp;off;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_connect_timeout&nbsp;300;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#nginx跟Tomcat连接超时时间(代理连接超时)\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_send_timeout&nbsp;300;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#连接成功后，后端服务响应时间(代理发送超时)\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_read_timeout&nbsp;300;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#连接成功后，后端服务响应时间(代理接收超时)\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_buffer_size&nbsp;4k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#设置代理服务器（nginx）保存用户头信息的缓冲区大小\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_buffers&nbsp;6&nbsp;64k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#proxy_buffers缓冲区，网页平均在64k以下的话，这样设置\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_busy_buffers_size&nbsp;128k;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#高负荷下缓冲大小（proxy_buffers*2）\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_temp_file_write_size&nbsp;64k;&nbsp;&nbsp;&nbsp;#设定缓存文件夹大小\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;&nbsp;Host&nbsp;&nbsp;$host;&nbsp;&nbsp;&nbsp;#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;&nbsp;X-Real-IP&nbsp;&nbsp;$remote_addr;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;&nbsp;X-Forwarded-For&nbsp;&nbsp;$proxy_add_x_forwarded_for;\n\n&nbsp;&nbsp;&nbsp;&nbsp;open_file_cache&nbsp;max=204800&nbsp;inactive=20s;\n&nbsp;&nbsp;&nbsp;&nbsp;open_file_cache_min_uses&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;open_file_cache_valid&nbsp;30s;\n\n&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;vhost/*.conf;\n}</code></pre> \n <p>5, 配置站点文件： tomcat.conf</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Tomcat&nbsp;conf]#&nbsp;mkdir&nbsp;vhost\n[root@Tomcat&nbsp;conf]#&nbsp;cd&nbsp;vhost/\n[root@Tomcat&nbsp;vhost]#&nbsp;vi&nbsp;tomcat.conf</code></pre> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>upstream&nbsp;tomcat_server&nbsp;{\n&nbsp;&nbsp;&nbsp;server&nbsp;&nbsp;&nbsp;192.168.0.222:8080;\n}\n\nserver&nbsp;{\n&nbsp;&nbsp;&nbsp;listen&nbsp;80;\n&nbsp;&nbsp;&nbsp;server_name&nbsp;192.168.0.222;\n&nbsp;&nbsp;&nbsp;root&nbsp;/usr/local/tomcat/webapps/ROOT/;&nbsp;&nbsp;#同tomcat一致\n&nbsp;&nbsp;&nbsp;index&nbsp;index.html&nbsp;index.jsp&nbsp;index.php;\n\nlocation&nbsp;~&nbsp;.*.jsp$&nbsp;{\nproxy_next_upstream&nbsp;http_503&nbsp;http_500&nbsp;http_502&nbsp;error&nbsp;timeout&nbsp;invalid_header;\nproxy_pass&nbsp;http://tomcat_server;\n}\n\n#这里使用的tomcat安装环境，下面是为了登入tomcat管理\nlocation&nbsp;~&nbsp;/manager/&nbsp;{\nproxy_pass&nbsp;http://tomcat_server;\n}\n\nlocation&nbsp;~&nbsp;/host-manager/&nbsp;{\nproxy_pass&nbsp;http://tomcat_server;\n}\n\nerror_page&nbsp;404&nbsp;&nbsp;&nbsp;/404.html;\nerror_page&nbsp;500&nbsp;502&nbsp;503&nbsp;504&nbsp;/50x.html;\n}</code></pre> \n <p>=======================<br></p> \n <p>上面的配置已经可以实现Nginx + Tomcat的动静分离，另一台Tomcat也是这样配置，上面我并没有对静态文件进行Cache，这是有道理的， 我打算把静态文件在前端进行cache<br></p> \n <p>1，如果后端也进行cache， 更新文件的时候，后端和前端都要进行清除cache，这样显得麻烦</p> \n <p>2，如果后端也进行cache，必要到静态文件的location中添加proxy_pass代理tomcat，这样却达不到动静分离，不添加proxy_pass, 却不能使用purge命中清除cache，当然也可以些shell运行，手动清除</p> \n <p>=======================</p> \n <p><strong>配置前端： Centos 192.168.0.211： nginx + Ngx_cache_purge</strong></p> \n <p>前端的nginx配置与后端差不多，主要是编译安装的时候添加cache模块，基础看后端安装，不多介绍了</p> \n <p>1，先解压nginx 和 Ngx_cache_purge，主要不同是安装的时候添加了ngx_cache_purge模块</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Nginx-C&nbsp;opt]#&nbsp;tar&nbsp;zxf&nbsp;ngx_cache_purge-2.0.tar.gz&nbsp;\n[root@Nginx-C&nbsp;opt]#&nbsp;tar&nbsp;zxf&nbsp;nginx-1.4.3.tar.gz&nbsp;\n[root@Nginx-C&nbsp;opt]#&nbsp;cd&nbsp;nginx-1.4.3\n[root@Nginx-C&nbsp;nginx-1.4.3]#&nbsp;./configure&nbsp;--user=www&nbsp;--group=www&nbsp;--add-module=../ngx_cache_purge-2.0&nbsp;--prefix=/usr/local/nginx&nbsp;--with-http_stub_status_module&nbsp;--with-http_ssl_module&nbsp;--with-http_realip_module\n[root@Nginx-C&nbsp;nginx-1.4.3]#&nbsp;make&nbsp;&amp;&amp;&nbsp;make&nbsp;install</code></pre> \n <p>2，配置主配置文件 nginx.conf</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>user&nbsp;&nbsp;www&nbsp;www;\nworker_processes&nbsp;&nbsp;1;\n\nerror_log&nbsp;&nbsp;logs/error.log;\n#error_log&nbsp;&nbsp;logs/error.log&nbsp;&nbsp;notice;\n#error_log&nbsp;&nbsp;logs/error.log&nbsp;&nbsp;info;\n\npid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logs/nginx.pid;\n\nworker_rlimit_nofile&nbsp;51200;\n\nevents&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;epoll;\n&nbsp;&nbsp;&nbsp;&nbsp;worker_connections&nbsp;&nbsp;51200;\n}\n\nhttp&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mime.types;\n&nbsp;&nbsp;&nbsp;&nbsp;default_type&nbsp;&nbsp;application/octet-stream;\n\n&nbsp;&nbsp;&nbsp;&nbsp;#log_format&nbsp;&nbsp;main&nbsp;&nbsp;\'$remote_addr&nbsp;-&nbsp;$remote_user&nbsp;[$time_local]&nbsp;\"$request\"&nbsp;\'\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'$status&nbsp;$body_bytes_sent&nbsp;\"$http_referer\"&nbsp;\'\n&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'\"$http_user_agent\"&nbsp;\"$http_x_forwarded_for\"\';\n\n&nbsp;&nbsp;&nbsp;&nbsp;#access_log&nbsp;&nbsp;logs/access.log&nbsp;&nbsp;main;\n&nbsp;&nbsp;&nbsp;&nbsp;server_names_hash_bucket_size&nbsp;128;\n&nbsp;&nbsp;&nbsp;&nbsp;client_header_buffer_size&nbsp;32k;\n&nbsp;&nbsp;&nbsp;&nbsp;large_client_header_buffers&nbsp;4&nbsp;32k;\n&nbsp;&nbsp;&nbsp;&nbsp;server_name_in_redirect&nbsp;off;\n&nbsp;&nbsp;&nbsp;&nbsp;client_max_body_size&nbsp;10m;\n&nbsp;&nbsp;&nbsp;&nbsp;client_body_buffer_size&nbsp;128k;\n\n&nbsp;&nbsp;&nbsp;&nbsp;sendfile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;tcp_nopush&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;tcp_nodelay&nbsp;&nbsp;&nbsp;&nbsp;on;\n\n&nbsp;&nbsp;&nbsp;&nbsp;#keepalive_timeout&nbsp;&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;keepalive_timeout&nbsp;&nbsp;60;\n\n&nbsp;&nbsp;&nbsp;&nbsp;gzip&nbsp;&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_min_length&nbsp;1k;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_buffers&nbsp;4&nbsp;16k;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_http_version&nbsp;1.0;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_comp_level&nbsp;3;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_disable&nbsp;\"MSIE&nbsp;[1-6].\";\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_types&nbsp;text/plain&nbsp;application/x-javascript&nbsp;text/css&nbsp;application/xml&nbsp;image/jpeg&nbsp;image/gif&nbsp;image/png;&nbsp;#添加图片压缩\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_vary&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;gzip_proxied&nbsp;any;\n\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_connect_timeout&nbsp;300;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_send_timeout&nbsp;300;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_read_timeout&nbsp;300;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_buffer_size&nbsp;64k;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_buffers&nbsp;4&nbsp;64k;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_busy_buffers_size&nbsp;128k;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_temp_file_write_size&nbsp;128k;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;&nbsp;Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$host;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;&nbsp;X-Real-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$remote_addr;&nbsp;#传递真实ip给后端\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;&nbsp;X-Forwarded-For&nbsp;&nbsp;$proxy_add_x_forwarded_for;\n\n&nbsp;&nbsp;&nbsp;&nbsp;open_file_cache&nbsp;max=204800&nbsp;inactive=20s;\n&nbsp;&nbsp;&nbsp;&nbsp;open_file_cache_min_uses&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;open_file_cache_valid&nbsp;30s;\n\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_cache_path&nbsp;/cache/proxy_cache&nbsp;levels=1:2&nbsp;keys_zone=cache_one:100m&nbsp;inactive=1d&nbsp;max_size=30g;&nbsp;#100m和30G，按照服务要求，适当增大\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_temp_path&nbsp;/cache/proxy_temp;\n\n&nbsp;&nbsp;&nbsp;&nbsp;include&nbsp;vhost/*.conf;\n}</code></pre> \n <p>3, 配置站点文件</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>upstream&nbsp;tomcat_server&nbsp;{\n&nbsp;&nbsp;&nbsp;server&nbsp;&nbsp;&nbsp;192.168.0.222&nbsp;weight=1&nbsp;max_fails=2&nbsp;fail_timeout=30s;&nbsp;#添加ip，不是tomcat的8080端口\n&nbsp;&nbsp;&nbsp;server&nbsp;&nbsp;&nbsp;192.168.0.223&nbsp;weight=1&nbsp;max_fails=2&nbsp;fail_timeout=30s;\n}\n\nserver&nbsp;{\n&nbsp;&nbsp;&nbsp;listen&nbsp;80;\n&nbsp;&nbsp;&nbsp;server_name&nbsp;192.168.0.211;\n&nbsp;&nbsp;&nbsp;index&nbsp;index.html&nbsp;index.jsp&nbsp;index.php;\n\n&nbsp;&nbsp;&nbsp;location&nbsp;/&nbsp;{\n&nbsp;&nbsp;&nbsp;proxy_next_upstream&nbsp;http_503&nbsp;http_500&nbsp;http_502&nbsp;error&nbsp;timeout&nbsp;invalid_header;\n&nbsp;&nbsp;&nbsp;proxy_cache&nbsp;cache_one;\n&nbsp;&nbsp;&nbsp;add_header&nbsp;&nbsp;Nginx-Cache&nbsp;\"$upstream_cache_status\";\n&nbsp;&nbsp;&nbsp;proxy_cache_key&nbsp;$host$uri$is_args$args;\n&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;Accept-Encoding&nbsp;\"\";\n&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://tomcat_server;\n&nbsp;&nbsp;&nbsp;proxy_cache_valid&nbsp;&nbsp;200&nbsp;304&nbsp;12h;\n&nbsp;&nbsp;&nbsp;proxy_cache_valid&nbsp;&nbsp;301&nbsp;302&nbsp;1m;\n&nbsp;&nbsp;&nbsp;proxy_cache_valid&nbsp;&nbsp;any&nbsp;1m;\n&nbsp;&nbsp;&nbsp;expires&nbsp;1d;\n&nbsp;}\n\n#jsp,do文件不进行cache\nlocation&nbsp;~&nbsp;.*\\.(jsp|do)$&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;Accept-Encoding&nbsp;\"\";&nbsp;#只添加了一个，&nbsp;其他的都添加到主配置文件了，以后添加站点不用在重复写\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;http://tomcat_server;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\nlocation&nbsp;~&nbsp;/purge(/.*)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;127.0.0.1;\n&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;192.168.0.0/24;\n&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;\n&nbsp;&nbsp;&nbsp;&nbsp;proxy_cache_purge&nbsp;cache_one&nbsp;$host$1$is_args$args;\n&nbsp;}\n\nlocation&nbsp;/ngx_status\n&nbsp;&nbsp;&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;stub_status&nbsp;on;\n&nbsp;&nbsp;&nbsp;&nbsp;access_log&nbsp;off;\n&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;127.0.0.1;\n&nbsp;&nbsp;&nbsp;&nbsp;allow&nbsp;192.168.0.0/24;&nbsp;#自己的ip地址\n&nbsp;&nbsp;&nbsp;&nbsp;deny&nbsp;all;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n}</code></pre> \n <p><strong>最后是性能测试</strong></p> \n <p>这里使用的是ab压力测试工具，后面会介绍如何单独安装ab测试工具</p> \n <p>1，前端<br></p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Tomcat&nbsp;~]#&nbsp;ab&nbsp;-c&nbsp;1000&nbsp;-n&nbsp;4000&nbsp;http://192.168.0.211/docs/security-howto.html\n====\nRequests&nbsp;per&nbsp;second:&nbsp;&nbsp;&nbsp;&nbsp;3304.24&nbsp;[#/sec]&nbsp;(mean)\nTime&nbsp;per&nbsp;request:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;302.642&nbsp;[ms]&nbsp;(mean)\nTime&nbsp;per&nbsp;request:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.303&nbsp;[ms]&nbsp;(mean,&nbsp;across&nbsp;all&nbsp;concurrent&nbsp;requests)\nTransfer&nbsp;rate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;110426.03&nbsp;[Kbytes/sec]&nbsp;received</code></pre> \n <p>2，直接测试后端</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Nginx-C&nbsp;vhost]#&nbsp;ab&nbsp;-c&nbsp;1000&nbsp;-n&nbsp;4000&nbsp;http://192.168.0.222/docs/security-howto.html\n====\nRequests&nbsp;per&nbsp;second:&nbsp;&nbsp;&nbsp;&nbsp;3416.84&nbsp;[#/sec]&nbsp;(mean)\nTime&nbsp;per&nbsp;request:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;292.668&nbsp;[ms]&nbsp;(mean)\nTime&nbsp;per&nbsp;request:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.293&nbsp;[ms]&nbsp;(mean,&nbsp;across&nbsp;all&nbsp;concurrent&nbsp;requests)\nTransfer&nbsp;rate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;114681.80&nbsp;[Kbytes/sec]&nbsp;received</code></pre> \n <p>3，直接测试tomcat</p> \n <pre class=\"brush:python;toolbar: true; auto-links: false;\"><code>[root@Nginx-C&nbsp;vhost]#&nbsp;ab&nbsp;-c&nbsp;1000&nbsp;-n&nbsp;4000&nbsp;http://192.168.0.222:8080/docs/security-howto.html\n====\nRequests&nbsp;per&nbsp;second:&nbsp;&nbsp;&nbsp;&nbsp;1995.18&nbsp;[#/sec]&nbsp;(mean)\nTime&nbsp;per&nbsp;request:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;501.209&nbsp;[ms]&nbsp;(mean)\nTime&nbsp;per&nbsp;request:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.501&nbsp;[ms]&nbsp;(mean,&nbsp;across&nbsp;all&nbsp;concurrent&nbsp;requests)\nTransfer&nbsp;rate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;66449.32&nbsp;[Kbytes/sec]&nbsp;received</code></pre> \n <p>前端的压力测试比nginx+tomcat动静分离要小点，但是实现了负载， 明显要比tomcat单独处理要强很多</p> \n</div>',NULL,'2020-02-02 19:13:43',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223927827351556096',NULL,NULL,' 一个1x1px大小Data/Base64数据的gif透明图片   ','<div class=\"content\" id=\"articleContent\"> \n <pre><code class=\"language-html\">&lt;img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" style=\"width:20px;border:solid 1px #999;\" /&gt;\n</code></pre> \n <p>=》 <img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1px\"> 《=</p> \n <pre><code>&lt;!---黑--&gt;\n&lt;img src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\"&gt;\n\n&lt;!---灰---&gt;\n&lt;img src=\"data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw==\"&gt;\n\n&lt;!---透明---&gt;\n&lt;img src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"&gt;\n\n</code></pre> \n <p><a href=\"http://clubmate.fi/base64-encoded-1px-gifs-black-gray-and-transparent/\">参考</a></p> \n</div>',NULL,'2020-02-02 19:15:08',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223928185809358848',NULL,NULL,' Sublime Text 3 （支持v3176）最新版破解及注册码 含V3207破解方法   ','<div class=\"content\" id=\"articleContent\"> \n <p>Sublime Text 是一个代码编辑器（Sublime Text 3是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text 3 在2013年1月29日进入测试版本。起初仅开放给已购买 Sublime Text 2 的用户。2013年6月28日起开放给所有用户使用。但最新的开发版本仍然需要注册码。最新的测试版本在2014年8月29日发布。</p> \n <h2>简介</h2> \n <p>Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。&nbsp;Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。</p> \n <p>链接：<a href=\"http://www.sublimetext.com/3\">http://www.sublimetext.com/3</a></p> \n <p>亲测该注册码适合X86、X64平台，Windows、Linux、OS X等系统同样适用。</p> \n <p>截图、、 <img src=\"https://oscimg.oschina.net/oscnet/9d06b491d910e377f88833b8ba75140167a.jpg\" alt=\"\"> <img src=\"http://static.oschina.net/uploads/space/2015/0913/224600_QbIQ_574928.png\" alt=\"\"> <img src=\"http://cdn.peakjs.top/editor.md/20180911/c919cee694b5747540b97f1749c0fb01.png\" alt=\"\"></p> \n <p>V3143：</p> \n <pre><code class=\"language-&nbsp;\">\n—– BEGIN LICENSE —–  \nTwitterInc  \n200 User License  \nEA7E-890007  \n1D77F72E 390CDD93 4DCBA022 FAF60790  \n61AA12C0 A37081C5 D0316412 4584D136  \n94D7F7D4 95BC8C1C 527DA828 560BB037  \nD1EDDD8C AE7B379F 50C9D69D B35179EF  \n2FE898C4 8E4277A8 555CE714 E1FB0E43  \nD5D52613 C3D12E98 BC49967F 7652EED2  \n9D2D2E61 67610860 6D338B72 5CF95C69  \nE36B85CC 84991F19 7575D828 470A92AB  \n—— END LICENSE ——\n\n</code></pre> \n <p><strong>参考：blog.csdn.net/kencaber/article/details/50651207</strong></p> \n <p><a href=\"http://peakjs.top\">js技术推荐</a></p> \n <pre><code>// 目的是防止Sublime Text更新和检测，不知道怎么修改hosts文件的可以百度一下，这里就不赘述。\n127.0.0.1 www.sublimetext.com\n127.0.0.1 license.sublimehq.com\n</code></pre> \n <p>最新版V3176：</p> \n <pre><code>—– BEGIN LICENSE —– \nsgbteam \nSingle User License \nEA7E-1153259 \n8891CBB9 F1513E4F 1A3405C1 A865D53F \n115F202E 7B91AB2D 0D2A40ED 352B269B \n76E84F0B CD69BFC7 59F2DFEF E267328F \n215652A3 E88F9D8F 4C38E3BA 5B2DAAE4 \n969624E7 DC9CD4D5 717FB40C 1B9738CF \n20B3C4F1 E917B5B3 87C38D9C ACCE7DD8 \n5F7EF854 86B9743C FADC04AA FB0DA5C0 \nF913BE58 42FEA319 F954EFDD AE881E0B \n—— END LICENSE ——\n</code></pre> \n <h2>最新破解</h2> \n <p><a href=\"https://my.oschina.net/u/574928/blog/3080993\">https://my.oschina.net/u/574928/blog/3080993</a></p> \n</div>',NULL,'2020-02-02 19:16:34',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223928543088562176',NULL,NULL,' react + webpack安装配置  ','<div class=\"content\" id=\"articleContent\"> \n <h2>使用CDN库方式</h2> \n <ul> \n  <li><code>&lt;script src=\"http://static.runoob.com/assets/react/react-0.14.7/build/react.min.js\"&gt;&lt;/script&gt;</code></li> \n  <li><code>&lt;script src=\"http://static.runoob.com/assets/react/react-0.14.7/build/react-dom.min.js\"&gt;&lt;/script&gt;</code></li> \n  <li><code>&lt;script src=\"http://static.runoob.com/assets/react/browser.min.js\"&gt;&lt;/script&gt;</code></li> \n </ul> \n <ol> \n  <li>react.min.js React核心库</li> \n  <li>react-dom.min.js 提供DOM相关的功能</li> \n  <li>browser.min.js 用于将JSX语法转为javascript语法</li> \n </ol> \n <pre><code>	&lt;!DOCTYPE html&gt;\n	&lt;html lang=\"en\"&gt;\n	&lt;head&gt;\n		&lt;meta charset=\"UTF-8\"&gt;\n		&lt;title&gt;Document&lt;/title&gt;\n		&lt;script src=\"http://static.runoob.com/assets/react/react-0.14.7/build/react.min.js\"&gt;&lt;/script&gt;\n	    &lt;script src=\"http://static.runoob.com/assets/react/react-0.14.7/build/react-dom.min.js\"&gt;&lt;/script&gt;\n	    &lt;script src=\"http://static.runoob.com/assets/react/browser.min.js\"&gt;&lt;/script&gt;\n	&lt;/head&gt;\n	&lt;body&gt;\n		&lt;div id=\"app\"&gt;&lt;/div&gt;\n		&lt;script type=\"text/babel\"&gt;\n			ReactDOM.render(\n				&lt;h1&gt;hello world&lt;/h1&gt;,\n				document.getElementById(\'app\')\n			);\n		&lt;/script&gt;\n	&lt;/body&gt;\n	&lt;/html&gt;\n</code></pre> \n <h2>使用脚手架方式</h2> \n <p>我们使用webpack作为脚手架</p> \n <p>首先新建目录test，进入test目录</p> \n <h3>安装webpack</h3> \n <ul> \n  <li>npm init</li> \n  <li>npm install</li> \n  <li>npm install webpack</li> \n  <li>npm install webpack-dev-server --save-dev</li> \n </ul> \n <h3>安装react</h3> \n <ul> \n  <li>npm install react --save</li> \n  <li>npm install react-dom --save</li> \n </ul> \n <h3>安装一些babel插件</h3> \n <ul> \n  <li>npm install babel</li> \n  <li>npm install babel-core</li> \n  <li>npm install babel-loader</li> \n  <li>npm install babel-preset-react</li> \n  <li>npm install babel-preset-es2015</li> \n </ul> \n <h3>创建一些必须的文件</h3> \n <ul> \n  <li>touch index.html</li> \n  <li>touch App.jsx</li> \n  <li>touch main.js</li> \n  <li>touch webpack.config.js</li> \n </ul> \n <h3>配置webpack设置编译器、服务器、载入器</h3> \n <pre><code>var path = require(\'path\')\nvar webpack = require(\'webpack\')\n\nmodule.exports = {\n   entry: \'./main.js\',\n\n   output: {\n      path:\'./\',\n      filename: \'index.js\',\n   },\n\n   devServer: {\n      inline: true,\n      port: 7777\n   },\n\n   module: {\n      loaders: [ {\n         test: /\\.jsx?$/,\n         exclude: /node_modules/,\n         loader: \'babel-loader\',           \n         query: {\n            presets: [\'es2015\', \'react\']\n         }\n      }]\n   },\n\n   plugins: [\n      new webpack.DefinePlugin({\n        \'process.env\': {\n          NODE_ENV: JSON.stringify(\'production\')\n        }\n      }),\n      new webpack.optimize.UglifyJsPlugin()\n  ]\n\n}\n</code></pre> \n <h3>根目录新建index.html</h3> \n <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n   &lt;head&gt;\n      &lt;meta charset=\"UTF-8\"&gt;\n      &lt;title&gt;hello&lt;/title&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n      &lt;div id=\"app\"&gt;&lt;/div&gt;\n      &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n <h3>根目录新建mian.js</h3> \n <pre><code>import React from \'react\';\nimport ReactDOM from \'react-dom\';\n\nimport App from \'./App.jsx\';\n\nReactDOM.render(&lt;App /&gt;, document.getElementById(\'app\'))\n</code></pre> \n <h3>根目录新建App.jsx</h3> \n <pre><code>import React from \'react\';\n\nclass App extends React.Component {\n   render() {\n      return (\n         &lt;div&gt;\n            Hello World!!!&lt;br /&gt;\n            你好世界！！！\n         &lt;/div&gt;\n      );\n   }\n}\n\nexport default App;\n</code></pre> \n <h3>配置服务</h3> \n <p>打开package.json 找到scripts节点，插入</p> \n <pre><code>\"scripts\": {\n    \"start\": \"webpack-dev-server --hot\",\n    \"build\": \"webpack --progress --hide-modules\"\n },\n</code></pre> \n <h3>启动服务</h3> \n <p><code>npm start</code></p> \n</div>',NULL,'2020-02-02 19:17:59',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223929256770359296',NULL,NULL,' 解Bug之路-记一次JVM堆外内存泄露Bug的查找（学习转载，经典文章）  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1>解Bug之路-记一次JVM堆外内存泄露Bug的查找</h1> \n <span id=\"OSC_h2_2\"></span> \n <h2>前言</h2> \n <p>JVM的堆外内存泄露的定位一直是个比较棘手的问题。此次的Bug查找从堆内内存的泄露反推出堆外内存，同时对物理内存的使用做了定量的分析，从而实锤了Bug的源头。笔者将此Bug分析的过程写成博客，以飨读者。<br> 由于物理内存定量分析部分用到了linux kernel虚拟内存管理的知识，读者如果有兴趣了解请看ulk3(《深入理解linux内核第三版》)</p> \n <span id=\"OSC_h2_3\"></span> \n <h2>内存泄露Bug现场</h2> \n <p>一个线上稳定运行了三年的系统，从物理机迁移到docker环境后，运行了一段时间，突然被监控系统发出了某些实例不可用的报警。所幸有负载均衡，可以自动下掉节点，如下图所示:&nbsp;<img alt=\"gc_local\" src=\"https://static.oschina.net/uploads/img/201801/08104437_3KUb.png\"><br> 登录到对应机器上后，发现由于内存占用太大，触发OOM，然后被linux系统本身给kill了。</p> \n <span id=\"OSC_h2_4\"></span> \n <h2>应急措施</h2> \n <p>紧急在出问题的实例上再次启动应用，启动后，内存占用正常，一切Okay。</p> \n <span id=\"OSC_h2_5\"></span> \n <h2>奇怪现象</h2> \n <p>当前设置的最大堆内存是1792M，如下所示:</p> \n <pre><code>-Xmx1792m -Xms1792m -Xmn900m -XX:PermSi\r\nze=256m -XX:MaxPermSize=256m -server -Xss512k \r\n</code></pre> \n <p>查看操作系统层面的监控，发现内存占用情况如下图所示:&nbsp;<img alt=\"gc_upper\" src=\"https://static.oschina.net/uploads/img/201801/08104501_x86B.png\"><br> 上图蓝色的线表示总的内存使用量，发现一直涨到了4G后，超出了系统限制。<br> 很明显，有堆外内存泄露了。</p> \n <span id=\"OSC_h2_6\"></span> \n <h2>查找线索</h2> \n <span id=\"OSC_h3_7\"></span> \n <h3>gc日志</h3> \n <p>一般出现内存泄露，笔者立马想到的就是查看当时的gc日志。<br> 本身应用所采用框架会定时打印出对应的gc日志，遂查看，发现gc日志一切正常。对应日志如下:&nbsp;<img alt=\"gc_log\" src=\"https://static.oschina.net/uploads/img/201801/08104524_biUf.png\"><br> 查看了当天的所有gc日志，发现内存始终会回落到170M左右，并无明显的增加。要知道JVM进程本身占用的内存可是接近4G(加上其它进程,例如日志进程就已经到4G了)，进一步确认是堆外内存导致。</p> \n <span id=\"OSC_h3_8\"></span> \n <h3>排查代码</h3> \n <p>打开线上服务对应对应代码，查了一圈，发现没有任何地方显式利用堆外内存，其没有依赖任何额外的native方法。关于网络IO的代码也是托管给Tomcat，很明显，作为一个全世界广泛流行的Web服务器，Tomcat不大可能有堆外内存泄露。</p> \n <span id=\"OSC_h2_9\"></span> \n <h2>进一步查找</h2> \n <p>由于在代码层面没有发现堆外内存的痕迹，那就继续找些其它的信息，希望能发现蛛丝马迹。</p> \n <span id=\"OSC_h3_10\"></span> \n <h3>Dump出JVM的Heap堆</h3> \n <p>由于线上出问题的Server已经被kill，还好有其它几台，登上去发现它们也 占用了很大的堆外内存，只是还没有到触发OOM的临界点而已。于是就赶紧用jmap dump了两台机器中应用JVM的堆情况，这两台留做现场保留不动，然后将其它机器迅速重启，以防同时被OOM导致服务不可用。<br> 使用如下命令dump:</p> \n <pre><code>jmap -dump:format=b，file=heap.bin [pid]\r\n</code></pre> \n <span id=\"OSC_h3_11\"></span> \n <h3>使用MAT分析Heap文件</h3> \n <p>挑了一个heap文件进行分析，堆的使用情况如下图所示:&nbsp;<img alt=\"gc_heap_dump\" src=\"https://static.oschina.net/uploads/img/201801/08104550_ukiC.png\"><br> 一共用了200多M，和之前gc文件打印出来的170M相差不大，远远没有到4G的程度。<br> 不得不说MAT是个非常好用的工具，它可以提示你可能内存泄露的点:&nbsp;<img alt=\"gc_cached_bns_client\" src=\"https://static.oschina.net/uploads/img/201801/08104610_EzHN.png\"><br> 这个cachedBnsClient类有12452个实例，占用了整个堆的61.92%。<br> 查看了另一个heap文件，发现也是同样的情况。这个地方肯定有内存泄露，但是也占用了130多M，和4G相差甚远。</p> \n <span id=\"OSC_h3_12\"></span> \n <h3>查看对应的代码</h3> \n <p>系统中大部分对于CachedBnsClient的调用，都是通过注解Autowired的，这部分实例数很少。<br> 唯一频繁产生此类实例的代码如下所示:</p> \n <pre><code>@Override\r\n    public void fun() {\r\n            BnsClient bnsClient = new CachedBnsClient();\r\n          // do something\r\n    		return  ;\r\n	}\r\n</code></pre> \n <p>此CachedBnsClient仅仅在方法体内使用，并没有逃逸到外面，再看此类本身</p> \n <pre><code>public class CachedBnsClient   {\r\n    private ConcurrentHashMap&lt;String， List&lt;String&gt;&gt; authCache = new ConcurrentHashMap&lt;String， List&lt;String&gt;&gt;();\r\n    private ConcurrentHashMap&lt;String， List&lt;URI&gt;&gt; validUriCache = new ConcurrentHashMap&lt;String， List&lt;URI&gt;&gt;();\r\n    private ConcurrentHashMap&lt;String， List&lt;URI&gt;&gt; uriCache = new ConcurrentHashMap&lt;String， List&lt;URI&gt;&gt;();\r\n	......\r\n}\r\n</code></pre> \n <p>没有任何static变量，同时也没有往任何全局变量注册自身。换言之，在类的成员(Member)中，是不可能出现内存泄露的。<br> 当时只粗略的过了一过成员变量，回过头来细想，还是漏了不少地方的。</p> \n <span id=\"OSC_h2_13\"></span> \n <h2>更多信息</h2> \n <p>由于代码排查下来，感觉这块不应该出现内存泄露(但是事实确是如此的打脸)。这个类也没有显式用到堆外内存，而且只占了130M，和4G比起来微不足道，还是先去追查主要矛盾再说。</p> \n <span id=\"OSC_h3_14\"></span> \n <h3>使用jstack dump线程信息</h3> \n <p>现场信息越多，越能找出蛛丝马迹。先用jstack把线程信息dump下来看下。 这一看，立马发现了不同，除了正常的IO线程以及框架本身的一些守护线程外，竟然还多出来了12563多个线程。</p> \n <pre><code>\"Thread-5\" daemon prio=10 tid=0x00007fb79426e000 nid=0x7346 waiting on condition [0x00007fb7b5678000]\r\n   java.lang.Thread.State: TIMED_WAITING (sleeping)\r\n	at java.lang.Thread.sleep(Native Method)\r\n	at com.xxxxx.CachedBnsClient$1.run(CachedBnsClient.java:62)\r\n</code></pre> \n <p>而且这些正好是运行再CachedBnsClient的run方法上面！这些特定线程的数量正好是12452个，和cachedBnsClient数量一致!</p> \n <span id=\"OSC_h3_15\"></span> \n <h3>再次check对应代码</h3> \n <p>原来刚才看CachedBnsClient代码的时候遗漏掉了一个关键的点!</p> \n <pre><code>    public CachedBnsClient(BnsClient client) {\r\n        super();\r\n        this.backendClient = client;\r\n        new Thread() {\r\n            @Override\r\n            public void run() {\r\n                for (; ; ) {\r\n                    refreshCache();\r\n                    try {\r\n                        Thread.sleep(60 * 1000);\r\n                    } catch (InterruptedException e) {\r\n                        logger.error(\"出错\"， e);\r\n                    }\r\n                }\r\n            }\r\n            ......\r\n        }.start();\r\n    }\r\n</code></pre> \n <p>这段代码是CachedBnsClient的构造函数，其在里面创建了一个无限循环的线程，每隔60s启动一次刷新一下里面的缓存!</p> \n <span id=\"OSC_h2_16\"></span> \n <h2>找到关键点</h2> \n <p>在看到12452个等待在CachedBnsClient.run的业务的一瞬间笔者就意识到，肯定是这边的线程导致对外内存泄露了。下面就是根据线程大小计算其泄露内存量是不是确实能够引起OOM了。</p> \n <span id=\"OSC_h3_17\"></span> \n <h3>发现内存计算对不上</h3> \n <p>由于我们这边设置的Xss是512K，即一个线程栈大小是512K，而由于线程共享其它MM单元(线程本地内存是是现在线程栈上的)，所以实际线程堆外内存占用数量也是512K。进行如下计算:</p> \n <pre><code>12563 * 512K = 6331M = 6.3G\r\n</code></pre> \n <p>整个环境一共4G，加上JVM堆内存1.8G(1792M)，已经明显的超过了4G。</p> \n <pre><code>(6.3G + 1.8G)=8.1G &gt; 4G\r\n</code></pre> \n <p>如果按照此计算，应用应用早就被OOM了。</p> \n <span id=\"OSC_h3_18\"></span> \n <h3>怎么回事呢？</h3> \n <p>为了解决这个问题，笔者又思考了好久。如下所示:</p> \n <span id=\"OSC_h4_19\"></span> \n <h4>Java线程底层实现</h4> \n <p>JVM的线程在linux上底层是调用NPTL(Native Posix Thread Library)来创建的，一个JVM线程就对应linux的lwp(轻量级进程，也是进程，只不过共享了mm_struct，用来实现线程)，一个thread.start就相当于do_fork了一把。<br> 其中，我们在JVM启动时候设置了-Xss=512K(即线程栈大小)，这512K中然后有8K是必须使用的，这8K是由进程的内核栈和thread_info公用的，放在两块连续的物理页框上。如下图所示:<br> <img alt=\"gc_thread_task\" src=\"https://static.oschina.net/uploads/img/201801/08104646_NYvq.png\"></p> \n <p>众所周知，一个进程(包括lwp)包括内核栈和用户栈，内核栈+thread_info用了8K，那么用户态的栈可用内存就是:</p> \n <pre><code>512K-8K=504K\r\n</code></pre> \n <p>如下图所示:<br> <img alt=\"gc_kernel_user\" src=\"https://static.oschina.net/uploads/img/201801/08104804_Bk9f.png\"></p> \n <span id=\"OSC_h3_20\"></span> \n <h3>Linux实际物理内存映射</h3> \n <p>事实上linux对物理内存的使用非常的抠门，一开始只是分配了虚拟内存的线性区，并没有分配实际的物理内存，只有推到最后使用的时候才分配具体的物理内存，即所谓的请求调页。如下图所示:<br> <img alt=\"gc_do_page_fault\" src=\"https://static.oschina.net/uploads/img/201801/08105218_fVOt.png\"></p> \n <span id=\"OSC_h3_21\"></span> \n <h3>查看smaps进程内存使用信息</h3> \n <p>使用如下命令，查看</p> \n <pre><code>cat /proc/[pid]/smaps &gt; smaps.txt\r\n</code></pre> \n <p>实际物理内存使用信息，如下所示:</p> \n <pre><code>7fa69a6d1000-7fa69a74f000 rwxp 00000000 00:00 0 \r\nSize:                504 kB\r\nRss:                  92 kB\r\nPss:                  92 kB\r\nShared_Clean:          0 kB\r\nShared_Dirty:          0 kB\r\nPrivate_Clean:         0 kB\r\nPrivate_Dirty:        92 kB\r\nReferenced:           92 kB\r\nAnonymous:            92 kB\r\nAnonHugePages:         0 kB\r\nSwap:                  0 kB\r\nKernelPageSize:        4 kB\r\nMMUPageSize:           4 kB\r\n\r\n7fa69a7d3000-7fa69a851000 rwxp 00000000 00:00 0 \r\nSize:                504 kB\r\nRss:                 152 kB\r\nPss:                 152 kB\r\nShared_Clean:          0 kB\r\nShared_Dirty:          0 kB\r\nPrivate_Clean:         0 kB\r\nPrivate_Dirty:       152 kB\r\nReferenced:          152 kB\r\nAnonymous:           152 kB\r\nAnonHugePages:         0 kB\r\nSwap:                  0 kB\r\nKernelPageSize:        4 kB\r\nMMUPageSize:           4 kB\r\n</code></pre> \n <p>搜索下504KB，正好是12563个，对了12563个线程，其中Rss表示实际物理内存(含共享库)92KB，Pss表示实际物理内存(按比例共享库)92KB(由于没有共享库，所以Rss==Pss)，以第一个7fa69a6d1000-7fa69a74f000线性区来看，其映射了92KB的空间，第二个映射了152KB的空间。如下图所示:<br> <img alt=\"gc_mem\" src=\"https://static.oschina.net/uploads/img/201801/08105319_dPoG.png\"><br> 挑出符合条件（即size是504K）的几十组看了下，基本都在92K-152K之间，再加上内核栈8K</p> \n <pre><code>(92+152)/2+8K=130K，由于是估算，取整为128K，即反映此应用平均线程栈大小。\r\n</code></pre> \n <p>注意，实际内存有波动的原因是由于环境不同，从而走了不同的分支，导致栈上的增长不同。</p> \n <span id=\"OSC_h3_22\"></span> \n <h3>重新进行内存计算</h3> \n <p>JVM一开始申请了</p> \n <pre><code>-Xmx1792m -Xms1792m\r\n</code></pre> \n <p>即1.8G的堆内内存，这里是即时分配，一开始就用物理页框填充。<br> 12563个线程，每个线程栈平均大小128K，即:</p> \n <pre><code>128K * 12563=1570M=1.5G的对外内存\r\n</code></pre> \n <p>取个整数128K，就能反映出平均水平。再拿这个128K * 12563 =1570M = 1.5G，加上JVM的1.8G，就已经达到了3.3G，再加上kernel和日志传输进程等使用的内存数量，确实已经接近了4G，这样内存就对应上了！(注:用于定量内存计算的环境是一台内存用量将近4G，但还没OOM的机器)</p> \n <span id=\"OSC_h3_23\"></span> \n <h3>为什么在物理机上没有应用Down机</h3> \n <p>笔者登录了原来物理机，应用还在跑，发现其同样有堆外内存泄露的现象，其物理内存使用已经达到了5个多G!幸好物理机内存很大，而且此应用发布还比较频繁，所以没有被OOM。<br> Dump了物理机上应用的线程，</p> \n <pre><code>一共有28737个线程，其中28626个线程等待在CachedBnsClient上。 \r\n</code></pre> \n <p>同样用smaps查看进程实际内存信息，其平均大小依旧为</p> \n <pre><code>128K，因为是同一应用的原因\r\n</code></pre> \n <p>继续进行物理内存计算</p> \n <pre><code>1.8+(28737 * 128k)/1024K =(3.6+1.8)=5.4G\r\n</code></pre> \n <p>进一步验证了我们的推理。</p> \n <span id=\"OSC_h3_24\"></span> \n <h3>这么多线程应用为什么没有卡顿</h3> \n <p>因为基本所有的线程都睡眠在</p> \n <pre><code> Thread.sleep(60 * 1000);//一次睡眠60s\r\n</code></pre> \n <p>上。所以仅仅占用了内存，实际占用的CPU时间很少。</p> \n <span id=\"OSC_h1_25\"></span> \n <h1>总结</h1> \n <p>查找Bug的时候，现场信息越多越好，同时定位Bug必须要有实质性的证据。例如内存泄露就要用你推测出的模型进行定量分析。在定量和实际对不上的时候，深挖下去，你会发现不一样的风景!</p> \n</div>',NULL,'2020-02-02 19:20:49',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223929614657736704',NULL,NULL,' 阿里消息中间件ONS消息重复问题和事物问题（三）  ','<div class=\"content\" id=\"articleContent\"> \n <p><img height=\"154\" src=\"https://static.oschina.net/uploads/space/2018/0326/185837_ozlE_3101476.png\" width=\"305\"></p> \n <p>产生的原因：网络不可达问题。</p> \n <p>网络超时之后我们可以做的只有两件事，1 停止（回滚，但对于系统来说影响特别大） 2 继续（另发送到别的服务消费端）</p> \n <p><img height=\"91\" src=\"https://static.oschina.net/uploads/space/2018/0326/190209_zhG1_3101476.png\" width=\"350\"></p> \n <p>一般我们采用第二种处理方式，但是要经过网络，必然会出现消息重复问题。</p> \n <p>最好的解决方法是：</p> \n <blockquote> \n  <p>恰好不需要——幂等操作</p> \n  <p>S * S = S (某个操作不管重复多少次，结果都一样)。</p> \n </blockquote> \n <p>幂等消息去重：</p> \n <blockquote> \n  <ul> \n   <li>保证有个唯一ID标记每一条消息</li> \n   <li>保证消息处理成功与去重表日志同事出现</li> \n  </ul> \n </blockquote> \n <p>代价：去重代价是去重日志的写入，数据校验，多台机器对去重表的维护。</p> \n <p><img height=\"278\" src=\"https://static.oschina.net/uploads/space/2018/0326/191044_xTjK_3101476.png\" width=\"415\"></p> \n <p><img height=\"271\" src=\"https://static.oschina.net/uploads/space/2018/0326/191105_oQa2_3101476.png\" width=\"420\"></p> \n <p><img height=\"203\" src=\"https://static.oschina.net/uploads/space/2018/0326/191208_VYj7_3101476.png\" width=\"403\"></p> \n <p><img height=\"293\" src=\"https://static.oschina.net/uploads/space/2018/0326/191248_lUvN_3101476.png\" width=\"456\"></p> \n <ul> \n  <li>ONS消息与事物转账设计难点：</li> \n </ul> \n <blockquote> \n  <ol> \n   <li>如何保证消息发送与Bob账户减钱同时成功或同时失败？</li> \n   <li>消息处理超时的解决？</li> \n   <li>消息处理失败如何解决？</li> \n  </ol> \n </blockquote> \n <p><img height=\"246\" src=\"https://static.oschina.net/uploads/space/2018/0326/192855_QhMM_3101476.png\" width=\"400\"></p> \n <p><img height=\"305\" src=\"https://static.oschina.net/uploads/space/2018/0326/192916_7Bsz_3101476.png\" width=\"465\"></p> \n <p><img height=\"299\" src=\"https://static.oschina.net/uploads/space/2018/0326/192955_dVa1_3101476.png\" width=\"457\"></p> \n <p>尽量保持消息接受者的幂等性</p> \n <p>但是对于非幂等的消息消费端：要记录日志表，内次执行时进行日志校验。</p> \n <p><img height=\"278\" src=\"https://static.oschina.net/uploads/space/2018/0326/193257_YqtV_3101476.png\" width=\"431\"></p> \n <ol> \n  <li>当消息接收者处理失败时，能挽回失败的方法之一是系统，但是系统回滚的开销往往是很大的。</li> \n  <li>还有一种方式是人工处理，当事件发生的概率 比 写代码挽回失败Bug的概率还要小，这样我们就需要考虑是否使用人工处理了。</li> \n  <li>利用努力送达模型，失败后再重新发往mq中，重新进行消费，尽量保证数据处理成功。努力送达模型是系统希望来进行这样的设计的。</li> \n </ol> \n <p>&nbsp;</p> \n <p>小结：</p> \n <ul> \n  <li>消息系统：解耦 异步&nbsp;最终一致性 并行</li> \n  <li>ONS 和其他消息系统不一样的部分：高吞吐量 高并发。</li> \n  <li>面向于失败的系统： 消息安全性， 消息堆积能力 消息吞吐量 和 延迟&nbsp;（crash崩溃）</li> \n  <li>系统的关键特性： topic、tag、消息组（订阅组：动态将消息通过一个配置文件配置组的名字，动态的归属到某一个组内，能保证消息发送者 和 消息订阅者可以自动的扩展 或 减容）</li> \n  <li>代价：消息重复问题，消息乱序问题。</li> \n  <li>支持事物的消息模式</li> \n </ul> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n</div>',NULL,'2020-02-02 19:22:14',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223929972142460928',NULL,NULL,' Dubbo集群容错和负载均衡  ','<div class=\"content\" id=\"articleContent\"> \n <ul> \n  <li><strong>0、基础知识</strong></li> \n </ul> \n <span id=\"OSC_h3_1\"></span> \n <h3><strong>Dubbo是什么？</strong></h3> \n <p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的<a href=\"http://en.wikipedia.org/wiki/Remote_procedure_call\" target=\"_blank\" rel=\"nofollow\">RPC</a>远程服务调用方案，以及<a href=\"http://en.wikipedia.org/wiki/Service-oriented_architecture\" target=\"_blank\" rel=\"nofollow\">SOA</a>服务治理方案。</p> \n <p>其核心部分包含:</p> \n <ul> \n  <li><strong>远程通讯:</strong>&nbsp;提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li> \n  <li><strong>集群容错:</strong>&nbsp;提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li> \n  <li><strong>自动发现:</strong>&nbsp;基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li> \n </ul> \n <span id=\"OSC_h3_2\"></span> \n <h3>Dubbo能做什么？</h3> \n <ul> \n  <li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li> \n  <li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li> \n  <li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li> \n </ul> \n <p>Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</p> \n <p style=\"text-align:center\"><strong>主要核心部件</strong></p> \n <p>Remoting: 网络通信框架，实现了sync-over-async 和 request-response 消息机制.</p> \n <p>RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能</p> \n <p>Registry: 服务目录框架用于服务的注册和服务事件发布和订阅。</p> \n <p>&nbsp;</p> \n <ul> \n  <li><strong>1、集群容错模式：</strong></li> \n </ul> \n <p>&nbsp; <strong>&nbsp;Failover Cluster</strong></p> \n <p>释义：失败自动切换，当出现失败，重试其它服务器。(缺省)</p> \n <p>应用场景：通常用于读操作，但重试会带来更长延迟。</p> \n <p>设置方法：可通过retries=\"2\"来设置重试次数(不含第一次)。</p> \n <p><strong>&nbsp; Failfast Cluster</strong></p> \n <p>释义：快速失败，只发起一次调用，失败立即报错。</p> \n <p>应用场景：通常用于非幂等性的写操作，比如新增记录。</p> \n <p><strong>&nbsp; Failsafe Cluster</strong></p> \n <p>释义：失败安全，出现异常时，直接忽略。</p> \n <p>应用场景：通常用于写入审计日志等操作。</p> \n <p><strong>&nbsp; Failback Cluster</strong></p> \n <p>释义：失败自动恢复，后台记录失败请求，定时重发。</p> \n <p>应用场景：通常用于消息通知操作。</p> \n <p><strong>&nbsp; Forking Cluster</strong></p> \n <p>释义：并行调用多个服务器，只要一个成功即返回。</p> \n <p>应用场景：通常用于实时性要求较高的读操作，但需要浪费更多服务资源。</p> \n <p>设置方法：可通过forks=\"2\"来设置最大并行数。</p> \n <p>&nbsp; <strong>Broadcast Cluster</strong></p> \n <p>释义：广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0开始支持)</p> \n <p>应用场景：通常用于通知所有提供者更新缓存或日志等本地资源信息。</p> \n <p>设置方法：重试次数配置如：(failover集群模式生效)</p> \n <pre><code class=\"language-xml\">&lt;dubbo:serviceretries=\"2\"/&gt;\n\n或：\n\n&lt;dubbo:referenceretries=\"2\"/&gt;\n\n或：\n\n&lt;dubbo:reference&gt;\n\n&nbsp;&nbsp;&nbsp;&lt;dubbo:methodname=\"findFoo\"retries=\"2\"/&gt;\n\n&lt;/dubbo:reference&gt;</code></pre> \n <ul> \n  <li><strong>2、集群模式配置如：</strong></li> \n </ul> \n <pre><code class=\"language-xml\">&lt;dubbo:servicecluster=\"failsafe\"/&gt;\n\n或：\n\n&lt;dubbo:referencecluster=\"failsafe\"/&gt;</code></pre> \n <p>-------------------------------------------------------------------------------------------------------------</p> \n <ul> \n  <li><strong>3、 负载均衡策略</strong></li> \n </ul> \n <p>以上是Dubbo集群的容错方式,接下来是在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。</p> \n <p>&nbsp;&nbsp;<strong>&nbsp;&nbsp;Random LoadBalance</strong></p> \n <p>随机，按权重设置随机概率。</p> \n <p>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p> \n <p>&nbsp;&nbsp;&nbsp;<strong>&nbsp;RoundRobin LoadBalance</strong></p> \n <p>轮循，按公约后的权重设置轮循比率。</p> \n <p>存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p> \n <p>&nbsp;&nbsp;&nbsp;<strong>&nbsp;LeastActive LoadBalance</strong></p> \n <p>最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。</p> \n <p>使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p> \n <p>&nbsp;<strong>&nbsp;&nbsp;ConsistentHash LoadBalance</strong></p> \n <p>一致性Hash，相同参数的请求总是发到同一提供者。</p> \n <p>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p> \n <p><strong>4、总结</strong></p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dubbo的集群容错和负载均衡同样也是Dubbo本身的高级特性.正如我们在说自定义扩展的时候一样,这两个特征同样也可以进行自定义扩展,用户可以根据自己实际的需求来扩展他们从而满足项目的实际需求.</p> \n</div>',NULL,'2020-02-02 19:23:40',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223930329413275648',NULL,NULL,' 从0到1构建一个电商平台 – 开发篇(转)  ','<div class=\"content\" id=\"articleContent\"> \n <p>文章来自 在外企和互联网碰撞的猴子 的微信公共账号。是我们跨境电商项目的架构师写的。我们项目的每个点读提到了，方便记录查找，我转载一下。</p> \n <span id=\"OSC_h1_1\"></span> \n <h1>背景</h1> \n <p>针对如火如荼的跨境电商行业，催生了提供一个SaaS电商平台为一些传统企业和机构开展跨境电商业务的市场机会，所以我们有机会来做这件事情。今天重点讨论销售和运营系统，不涉及跨境贸易价值链中的采购、通关、购汇结汇以及支撑电商业务的CRM，OMS，ERP等系统。</p> \n <p>团队成员-最初由3名具有比较丰富企业级电商平台开发经验（&gt;6年）的资深工程师组成，经过1年发展，团队规模成长到30+工程师。</p> \n <span id=\"OSC_h1_2\"></span> \n <h1>架构准则</h1> \n <p>1.<strong>&nbsp;领域驱动</strong>&nbsp;– 基于自己对企业级电商平台设计和开发的丰富经验，进行<strong>领域建模</strong>，并将<strong>领域映射到业务子系统</strong>，划分高阶系统边界</p> \n <p>2.&nbsp;<strong>分布式、服务化</strong>&nbsp;- 吸取企业级电商平台的经验教训，<strong>各业务子系统独立开发、测试和部署</strong>，子系统以<strong>服务暴露自己的能力，</strong>子系统与子系统之间以<strong>服务进行通信和交互。</strong>这一点可能会有些争议，在业务发展初期，整个系统的容量不需要那么大，分布式是不是设计过度，特别是在部署上对一个小团队来讲也很难驾驭。在项目中途我也曾经深深的质疑过这一点，但是慢慢也体会到它带来的好处，放开分布式架构带来的未来系统更容易更灵活的优势暂且不谈，至少每个业务子系统能比较独立高效的开发，测试和部署，在一个高速发展的团队，不可避免的沟通会成为一个巨大的挑战，这种独立性可以很大程度减少一些艰难和低效的沟通。</p> \n <p>3.&nbsp;<strong>持续集成</strong>&nbsp;– 从第一天开始建立持续集成的体系和流程，保持开发、测试、部署的高效性</p> \n <span id=\"OSC_h1_3\"></span> \n <h1>第一阶段（2个月）</h1> \n <p>在人员有限的情况下，以一个业务领域切入，构建业务子系统，确定基础技术选型，提供业务子系统的样本项目工程和框架供后续业务子系统开发参考。因为交易是电商平台最重要的一个业务领域，并且涉及到跟几乎所有其他业务领域的交互，我们选择交易子系统为切入点。</p> \n <p>基础技术选型：<strong>Java+Spring作为服务开发的基础框架</strong>，<strong>MySQL存储交易数据</strong>，<strong>RestEasy作为REST服务框架</strong>，<strong>子系统间的服务调用使用Hessian</strong>。因为团队成员曾经在淘宝交易平台的工作经历，整个服务框架基础技术栈的的选型深受阿里的影响。</p> \n <p><strong>1. 一个业务子系统由-app, -client, -server三个项目组成。</strong>其中<strong>app是controller层，通过RestEasy把服务以REST接口发布出去</strong>；<strong>client暴露了业务服务接口及Domain对象</strong>；<strong>server提供业务服务的实现</strong>。这里app不会直接调用server，app需要调用业务服务也是以client为入口。这里主要的考虑是基础服务和应用服务这两级服务的概念。这个概念相信了解淘系系统的人不会陌生，基础服务只提供对核心领域对象的基本操作（典型的增删改查及基于此的一些基本操作），应用服务一般对应一个业务场景，需要调用一个或多个基础服务，进行串联、聚合或其它计算处理。例如：购物车的增删改查是典型的基础服务，而计算购物车时一个典型的应用服务。这样设计，随着业务量的增长，系统未来更容易向微服务架构演进。</p> \n <p><strong>2. 业务子系统打包成WAR部署到Tomcat需要一个web项目，-web，Web项目里，包含datasource，hessian服务发布，声明包含哪些业务子系统，以及配置文件</strong>。因为在项目初期我们需要支撑的业务量还没达到一定的规模，出于成本控制的考虑我们需要将多个业务子系统打包发布到一个WAR中，所以这里出现了需要在Web项目中声明包含哪些业务子系统。未来如果需要从一个WAR中将一些业务子系统拆出来单独发布，也比较灵活。</p> \n <p>3. 服务调用框架，说到这里，大家第一反应肯定是Dubbo，在项目初期，我们并未使用Dubbo的方案，主要是考虑到团队成员并没有Dubbo使用的经验，而且在我们并未产生大规模分布式服务和服务治理的需求时，Dubbo的使用在项目初期反而可能成为我们的不可承受之重，把Dubbo用起来并不难，难的是如何驾驭它。所以我们<strong>选择使用DNS+Load Balance来做服务发现，基于动态代理实现了Hessian/Local/Mock的服务调用机制</strong>（Local主要用于不同业务子系统部署到一个WAR中，Mock主要用于UT），每个Web项目提供一个服务调用的配置文件，配置这个Web项目要调用的服务的调用机制和服务endpoint，因为我们使用DNS+Load Balance来做服务发现，所以服务endpoint都是Load Balance的地址。</p> \n <p>4. 分布式日志，分布式服务调用如何跟踪一个请求的整个服务调用链条，是我们必须要解决的问题，基于Google的Dapper论文，淘宝实现了EagleEye。其实Dapper的原理并不难理解，我们选择自己实现请求的global ID并在分布式服务调用间进行透传，与ELK（ElasticSearch+Logstash+Kibana）相结合，可以比较清晰的呈现一个外部API请求跨系统服务调用的所有日志。</p> \n <p>5. 缓存的使用，对于内容型数据（例如：价格，商品税率），使用Redis缓存，这里特别要注意防缓存穿透（当数据库记录本身不存在每次都穿透缓存去读数据库）；对于配置型数据，使用Local JVM缓存（未使用EhCahce,自己实现MRU和缓存空间设定，主要原因是以前项目有相应的积累，可重用）；对于操作型数据（例如：购物车，库存），使用Redis缓存，操作型数据里，特别是购物车读写同样频繁，在高并发环境下容易因为缓存更新失败而导致缓存和数据库数据不一致，需要使用MQ记录不一致情形并通过Listener应用执行缓存失效。</p> \n <p>6. 图片服务器的使用，团队小伙伴以前有大规模应用TFS的经验，给我反馈是TFS算是淘宝开源作品里为数不多的精品，刹那间我是有点心动的。现实马上打醒我，小伙伴需要去做其它更重要的事情，TFS这玩意，等我们图片规模大到一定程度必须自己来做图片服务器和存储系统再考虑吧。于是我们选择了七牛，很完整的图片管理和CDN服务，算下来一年的价格也不贵。当然第三方服务始终是不可靠的，我们也专门引入了assets的业务子系统管理图片及图片在服务器上的元信息，这样在将来比较容易的迁移到其它图片云服务或者自己使用Nginx+TFS。</p> \n <span id=\"OSC_h1_4\"></span> \n <h1>第二个阶段（4个月）</h1> \n <p>随着人员的逐步到位，各个业务领域的业务子系统开始铺开进行开发，这个时候如何协调开发人员以统一的风格来实现各个业务子系统就显得格外重要了。而且，在基础框架和工具层面，也要尽量统一，减少维护的成本，所以，我们在开发团队里一直有一个由精兵强将组成的小组负责这一部分。</p> \n <p>1. 数据库规范：包括每个业务对象对应的数据库表如何设定主键，唯一ID，唯一性索引，每张数据库的预留字段（创建时间，更新时间，创建人，更新人，乐观锁计数等）。</p> \n <p>2. REST API规范：增删改查的URI pattern，特殊POST操作的URI pattern，API版本。</p> \n <p>3.&nbsp;<strong>通用参数规范</strong>：对语言，货币，请求ID，调用者等的统一命名和处理。</p> \n <p>4.&nbsp;<strong>领域边界划分</strong>：在划分基础领域边界的基础上，为了提高性能，减少不必要的远程服务调用，在业务允许的情况下，进行一定的冗余。例如：在购物车中不仅仅存储商品SKU ID，还包括商品的名称，商品缩略图链接，店铺名称等信息，避免在查询购物车时再去调用商品API获取这些信息。</p> \n <p>5.&nbsp;<strong>异常处理</strong>：提供异常基础类，基于异常基础类提供异常处理框架在业务服务层和REST服务层对异常进行统一处理。各业务子系统仅需扩展异常基础类，在业务代码中抛出这些异常即可。异常处理框架帮助处理剩下的事情。这样对于API调用者来说也是极其友好的。</p> \n <p>6.&nbsp;<strong>配置管理</strong>：在系统还没有发展到一定规模时，可能还不需要一个集中的配置中心。但是，每个业务子系统切忌分散管理配置信息，因为开发，测试，预发布，线上各种环境需要的配置很可能是不相同的，分散管理的配置信息在每次部署一个新的环境简直是噩梦。目前，因为我们已经的系统规模已经发展到10+个业务子系统，即使每个子系统都集中管理配置信息，如何高效的管理各个不同环境的配置信息已经成为一个非常突出的问题，我们基于disconf已经做了POC，计划在下一个阶段把disconf用起来。我本人是Netflix OSS的粉丝，本来Netflix Archiaus是我的首选，但是考虑最近接触的国内开源的工具越来越好，社区也越来越活跃，我们果断的选择了disconf。</p> \n <p>7. Session：在这个方面我们是走了一些弯路的，已开始我们有规划专门的session service，并且与shiro做整合，后面的session信息存到Redis中，这个已经基本开发完毕。但是在项目实际演进的过程中，这个阶段我们的前端应用里PC端和移动端商城都是基于PHP开发（基于Yii Framework），在PHP里已经有比较完整的session处理，我们后端的业务服务完全是无状态的，在这里再去使用这个统一的session service反到在项目时间特别紧张的情况下给PHP开发造成很多困扰，所以，我们决定短期内放弃session service，全权交由PHP来处理。在未来系统演进到前段多应用，甚至不同技术栈时在重新把它找回来。</p> \n <p>8.<strong>&nbsp;Scheduler和任务处理</strong>：对淘宝了解的同学一定听说过他们早期开源的TBScheduler和现在正在使用的TTD，还有最近当当开源的Elastic-Job，可是，对于一个刚刚起步的业务系统，对于这种任务处理还没到需要分布式的地步，所以，我们选择<strong>了从Quartz和Spring Batch切入</strong>，但是Quartz本身只负责调度本身，我们还是需要存储一些任务的详细信息和状态，要支持异步任务的回调通知状态，排他性任务，已经简单的任务流程编排，我们按照自己的需求，基于Quartz做了扩展支持这些功能。未来如果业务发展需要我们引入分布式任务处理的机制，我想Elastic-Job会是我的第一选择。</p> \n <p>9.&nbsp;<strong>统一登录服务：</strong>今天我相信在Java的世界里大家要实现统一登录服务大部分人会第一选择会是CAS。CAS对各种认证协议的支持未尝完备，后面也很容易挂自己实现的credential数据库。不过比较讨厌的是，CAS自带前台登录页面，这部分是基于JSP的，而我们的前端工程师全是PHP的，改造起来那叫一个费劲。虽然我们可以放弃它自带的JSP页面直接调用CAS的API，但是处理起来过于复杂，对于我们这个规模有限的初创团队有点不可承受之重。另外，目前我们团队在注册这个环节是直接绕过了CAS调用用户子系统的注册API，对于PHP同学们来讲也是很高兴的。</p> \n <p>10. 非Java业务子系统：在电商平台中，从业务需求来讲，促销是非常复杂的一个业务子系统，各种不同的促销条件，促销次数限制，促销之间的互斥和组合，促销金额计算，和优惠券或优惠码结合使用，其实这需要一个高效的规则引擎，一方面能够比较清晰的定义这些规则，另一方面在执行期也能够在毫秒级能够完成对一个订单的促销计算，传统的Java+关系数据库建模是很难搞定的。已开始我们想基于一个开源的规则引擎来做，所以我们队Drools做了一定的研究，作为一个通用的规则引擎，Drools功能比较强大，但是也比较复杂，在我们只有1个开发工程师能铺到这个领域的情况下，也很难搞定；另外，Drools在实时规则计算的效率上也是一个很大的问号，而且促销管理业务工具对我们是非常重要的，基于Drools的规则定义语言来开发这个工具难度太高。我们最终选择了DSL，定义一套促销这个领域的专有语言，用JRuby来实现促销DSL的语义模型和语法解析器，一来Ruby的一些声明式语法特性是非常适合来定义DSL的语义模型和进行语法解析，另一方面JRuby运行在JVM中可以和各种Java库无缝整合。促销引擎分为4个子系统：DSL引擎-负责管理促销DSL定义，解析DSL转化为语义模式；预计算引擎-负责对促销规则进行预计算，将商品和其可能应用的促销进行关联（提高runtime计算的效率）；runtime计算引擎-在线为一个订单计算促销结果。优惠券引擎 – 处理优惠券和优惠码的生成，管理和使用。目前，我们的促销规则DSL定义，预计算结果和优惠券信息均使用MongoDB进行存储。其实即使这样，业务管理工具来管理DSL来表达的促销规则还是一个挑战，我们在两者直接加入了一层meta data层来做映射缓解这个问题，这就意味着业务管理工具只是DSL表达能力的一个子集，对于一些高级的促销，我们直接在工具上开放了DSL编辑器直接对DSL进行编辑。另外，促销引擎的4个子系统都已经利用Docker进行部署，也为我们系统向容器化部署演进打下了基础。</p> \n <p>11. 前台商城系统和CMS：本身我自己在CMS上有一些研究，对WordPress, Joomla和Drupal都有一定的了解，加上电商运营的特点，对CMS的要求特别强，我一开始是打算在Drupal上往前走的。而且我们在Drupal上也做了投资，研究学习，POC，前前后后也有小三个月，但是慢慢我也发现一个问题：Drupal本身也是很完整的一个系统，加上生态系统，和电商的领域已经有很多交集，这给我的小伙伴造成了很多困扰，他一直在质疑为什么产品目录树，购物车这些Drupal都有现成的插件我们还要再去实现一套后端服务。虽然从架构上很容易解释，但是现实是当你每天面对这样一个系统时是难免会很纠结的。后来，我们找到了一个既有丰富的Drupal经验，也经历了去Drupal，自主开发CMS的小伙伴，一番沟通和探讨，我们决定放弃Druple，自己干。</p> \n <p>我这里贴一下我的小伙伴给我的建议吧：<strong>drupal善于做cms，模块固然成熟，但是牺牲了性能为代价</strong>。我们的业务场景更加灵活丰富，结合了传统pc，线下收银，以及移动，o2o等各种场景。单纯的依靠定制模块开发将会是事情变得更加复杂且不可控。 采用一个流行且易用的开源框架，使得我们在迅速迭代与稳定架构之间获得了更好的平衡，同时也能更好的结合中国特色的市场需求。通过框架的crud功能，我们迅速完成了传统的cms模块。而通过mvc最流行的业务分层模式，我们更好的通过m层同后台进行了松耦合式的开发体验。使得整个系统既可以脱离应用层纵向拓展，也可以通过其他各种应用层架构（node.js agular.js）实现横向的拓展。drupal的缺点还有一些，比如社区陈旧，模块数量虽多但是优质模块很少。性能上因为其自身机制，当系统复杂之后容易产生性能瓶颈，且不利于开发人员trace。 如果采用drupal，我们将被迫用5-10年的senior phper去学习一个在中国并不流行的技术架构。基本是很难找到人的。换开源php框架之后，那么，只需要有几个senior的开发人员进行组织整体架构并review，就能利用中国大量的码农(coder)。</p> \n <p>12. 业务管理工具：AngularJS+Bootstrap，这个应该没有太多争议，虽然现如今React.js如火如荼，可是在我们那个时候Angular还是更靠谱的选择，另外我们的工具应用选用了Spring的AppFuse框架，让他们能够更快速的开发前台工具应用，并方便的处理访问控制，多语言，前后台交互等问题。</p> \n <span id=\"OSC_h1_5\"></span> \n <h1>单独的话题</h1> \n <p>1. 单元测试 – 节奏再快，资源再短缺，我还是坚守底线，大家做好UT，而且是基于mock的UT，前期在UT的投资虽然对于快速迭代的节奏来讲往往都会有冲突，可是它带来的后期维护的便捷和高效往往是值得我们付出的。</p> \n <p>2. 持续集成 – 从第一天，我们就投入一个专职工程师进行来负责持续集成，Jenkins, Maven repostiory, Git的搭建，持续集成脚本的开发，持续集成流程的建立。这些在很多小团队看来不必要的投资其实随着项目的执行其带来的好处是会不断被放大的。我们采用chef来生成操作系统和中间件级别的标准image（例如：Tomcat, Nginx, MySQL, Redis, MQ, ElasticSearch等等的标准image），但是我们的持续发布脚本并未使用chef来编写，而是直接用ruby来实现的，这个主要原因是直接用ruby提供了更大的灵活性，我们在以前的项目中也有一定的积累。</p> \n <p>3. 测试 – 很遗憾，我们的测试资源是在有限，在保系统功能的基本准则下，我们牺牲了API级别的功能测试，前期只能靠UT来保障了。这也有很多无奈，如果有一天测试资源跟上，需要第一时间把API自动化测试，和基于场景的自动化测试不上。</p> \n <span id=\"OSC_h1_6\"></span> \n <h1>在路上</h1> \n <p>1. 配置中心，目前很痛的一个环节，前文已经提到，我们已完成disconf的POC，接下来就会使用。</p> \n <p>2. 服务发现和调用框架：用不用dubbo?其实有其它更轻量的选择（例如：consul做服务注册和发现，hystrix/turbine做故障隔离和服务metris），我们现在的实现已经很小清新。另一个角度dubbo在国内的生态的确不错，基本上主流电商公司都在使用。这个留着慢慢纠结吧。</p> \n <p>3. 错误数据校正平台：在高并发的场景总是不可避免出现一些异常情况造成错误数据，建立一套错误数据校正平台是很重要的，要知道客户投诉起来，运营抱怨起来，往往技术团队是最惨的。</p> \n <p>4. 全docker化：目前除了促销引擎的4个业务子系统，其他还是使用的青云上的linux虚机，考虑到初期业务不大要节省服务器成本，我们不得不将一些业务子系统合并到一个WAR里面发布，如果每个业务子系统都能够docker化，就不需要这么费劲了。</p> \n <p>5. API网关：目前我们的业务服务已经有需求要被外部系统调用（例如：联盟营销系统），如何将内部的业务服务暴露出去变成一个课题，我们需要引入API网关来解决这个问题，目前我们已经开始调研zuul。</p> \n <p>6. 多租户模式下不同客户的个性化定制：目前我们只能做到前端商城的个性化定制和外部系统集成的个性化定制，核心业务层如何做个性化定制是需要解决的，我们以前有做传统企业级电商平台的定制框架的经验，但是在SaaS多租户的场景下这个将会是个巨大的挑战。</p> \n <p>7. 压测体系：SaaS和传统企业电商平台的压测是很不一样的，如果评估线上环境的容量，如何持续的对线上环境做压测，如何模拟真实流量，现在这些一二线互联网电商平台已经积累了足够的经验，我们要做的，就是一步一步，吸取人家的精华，结合自身的情况，执行起来。</p> \n <p>8. 运维体系：这是一个比较大的话题，我们可以单独再讨论。</p> \n</div>',NULL,'2020-02-02 19:25:05',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223930691503345664',NULL,NULL,' 分布式事务之两阶段提交  ','<div class=\"content\" id=\"articleContent\"> \n <p>作者：Philip A. Bernstein, Vassos Hadzilacos, Nathan Goodman. 1987</p> \n <p>原文：Concurrency Control and Recovery in Database Systems</p> \n <p>译者：phylips@bmy 2013-02-14</p> \n <p>译文：<a href=\"http://duanple.blog.163.com/blog/static/70971767201311810939564/\" target=\"_blank\" rel=\"nofollow\">http://duanple.blog.163.com/blog/static/70971767201311810939564/</a></p> \n <p>&nbsp;</p> \n <p>[序：历史上，数据库领域共产生过三位图灵奖得主<em>Charles Bachman，E.F.Codd和Jim Gray</em></p> \n <p>1961年，通用电气公司(General Electric Co.)的Charles Bachman成功地开发出世界上第一个网状DBMS也是第一个数据库管理系统——集成数据存储(Integrated DataStore IDS)，奠定了网状数据库的基础，并在当时得到了广泛的发行和应用。后Charles Bachman因在数据库方面的贡献获得1973年图灵奖。</p> \n <p>1970年6月，IBM圣约瑟研究实验室的高级研究员Edgar Frank Codd在Communications of ACM上发表了A Relational Model of Data for Large Shared Data Banks。首次明确提出关系数据库模型。此后，之前基于层次模型和网状模型的数据库产品很快消亡。1972年，Codd提出了关系代数和关系演算的概念， 定义了关系的并、交、投影、选择、连接等各种基本运算， 为日后成为标准的结构化查询语言(SQL)奠定了基础。 后来Codd又陆续发表多篇论文，论述了范式理论和衡量关系系统的12条标准，为关系数据库建立了一个严格的数学模型。而此时网状数据库的标准化工作正在进行，同时有人认为关系数据库是一个过于理想化的模型，对它的性能表示担忧。又是出现了关系数据库与反关系数据库两派(历史总是如此相似)。后E.F.Codd获得1981年图灵奖。</p> \n <p>1976年，IBM 的研究员 Jim Gray 发表了名为Granularity of Locks and Degrees of Consistency in a Shared DataBase的论文，正式定义了数据库事务的概念和数据一致性的机制。后Jim Gray因在数据库和事务处理研究和实现方面的开创性贡献获得1998年图灵奖。</p> \n <p>&nbsp;</p> \n <p>迄今，数据库已经是一个理论研究非常成熟同时商业化也足够高的领域了。同时，它本身所涉及的知识面也是非常广的，这篇文章我们将主要关注事务处理方面的提交问题。</p> \n <p>&nbsp;</p> \n <p>上世纪70年代，在关系数据库理论基本成熟后，各大公司在关系数据库管理系统的实现和产品开发中遇到了一系列技术问题。主要是在数据库的规模愈来愈大，数据库的结构愈来愈复杂，又有愈来愈多的用户共享数据库的情况下，如何保障数据的完整性、安全性、并发性以及故障恢复的能力，这些问题成为数据库产品是否能实用化并最终为用户接受的关键因素。Jim Gray在解决这些重大技术问题，使RDBMS成熟并顺利进入市场的过程中，起到了关键性作用。概括地说，解决上述问题的主要技术手段和方法是：把对数据库的操作划分为称为“事务”的基本原子单位，一个事务要么全做，要么全不做（即all-or-nothing原则）；用户在对数据库发出操作请求时，需要对有关的数据“加锁”，防止不同用户的操作之间互相干扰；在事务运行过程中，采用“日志”记录事务的运行状态，以便发生故障时进行恢复；对数据库的任何更新都采用“两阶段提交”策略。以上方法及其他各种方法总称为“事务处理技术”。</p> \n <p>&nbsp;</p> \n <p>首先来回顾一下有关事务处理的一些经典书籍文章。Jim Gray在1977年写过一篇文章“Notes on Data Base Operating Systems”，总共80多页，应该算是早期非常完善地介绍数据库这门学科内容的教科书了，文章内容来源广泛，汇集了那个时代众多数据库先驱们的想法和思考。IBM的System R对该文章产生了重要影响。很多内容都是直接来源于Jim Gray与他人的讨论，因此很多想法已经无法找到明确的参考文献。在这篇文章中，将一个数据库系统划分成了如下四个主要组件：数据字典(dictionary)，数据通信(data communications)，数据库管理(database manager)，事务管理(transaction management)。尤其对事务管理中的并发控制(locking)和系统可靠性机制(recovery)进行了深入讲解。比如5.7.5节，引用的就是Jim Gray 1976年的经典论文“Granularity of Locks and Degrees of Consistency in a Shared DataBase”的内容。同时描述了大量事务处理方面的细节，以及所用到一些重要协议算法，像两阶段提交协议。当然这里关于事务处理的大部分想法也都源自于IBM IMS开发者的实际经验以及作者本身参与的System R的开发过程。之后在1981年的文章“The Transaction Concept:Virtues and Limitations”中，Jim Gray提出事务应具有三个属性：Consistence，Atomicity，Durability。而ACID的叫法，则是在1983年由Theo Harder和Andreas Reuter在他们发表的文章“Principles of Transaction-Oriented Database Recovery”中首次提出，之后才被广泛使用的。顺便来看一些其他重要概念的起源，Write-Ahead-Log概念是Ron Obermark在1974年提出的，大概也是在那个时候他实现了nested-two-phase commit protocol；Earl Jenner和Steve Weick在1975年首次实现了两阶段提交协议，当然实际上它可能源于由Niko Garzado在1970年实现的某些系统，此后IMS，System R都提供了不同形式的实现；Paul McJones和Jim Gray参考Warren Titlemann在INTERLISP中的实现，在System R中实现了DO-UNDO-REDO 策略。此外Lampson和Sturgis在1976年的论文” Crash Recovery in a Distributed System”中独立提出了两阶段提交协议，Lewis, Sterns和Rosenkrantz在论文” System Level Concurrency Control for Data Base Systems”中独立提出了nested commit protocol。1987年，Philip A. Bernstein, Vassos Hadzilacos, Nathan Goodman的书籍“Concurrency Control and Recovery in Database Systems”，全书共300多页，系统描述了数据库系统中的并发控制和恢复机制。</p> \n <p>&nbsp;</p> \n <p>1992年，C.Mohan的ARIES出世，这篇论文详细描述了一系列关于恢复，并发和存储管理的算法。事实上该论文中的很多想法源于C.Mohan与Don Haderle的交流，那个时候Don Haderle正担任IBM DB2的主架构师。通过这个交流，C.Mohan意识到DB2对于某些问题的处理方式与System R有所不同，同时System R基于shadow page的恢复算法留下了一个开放性问题“如何在使用write-ahead logging的情况下对记录加锁”。ARIES就是在这样的背景下写出来的。由于这篇文章试着综合了所有相关工作，并对那些可能成为ARIES算法一部分的特征进行了解释，导致这篇文章写出来后非常长，接近70页，这也使得它成为TODS历史上唯一超过50页限制而被接受的文章。1993年，Jim Gray和Andreas Reuter 合写的关于事务处理的经典书籍“Transaction Processing:Concepts and Techniques”出版。</p> \n <p>&nbsp;</p> \n <p>最后再简要介绍下Jim Gray吧：关系数据库领域大师，因在数据库和事务处理研究和实现方面的开创性贡献而获得1998年图灵奖。美国科学院、工程院两院院士，ACM和IEEE两会会士。1966年在UC Berkeley拿到数学工程系学位，之后去纽约大学科朗研究所呆了一年，1967年又回到了Berkeley，仅用了一年半就拿到了博士学位，不过论文题目不是关于数据库的，而是关于语法分析理论的。博士毕业后，先在Berkeley做了两年博士后，继续从事理论研究与系统开发工作，之后去了IBM。在IBM工作期间参与和主持了IMS、System R、SQL/DS、DB2等项目的开发。后任职于微软研究院，主要关注应用数据库技术来处理各学科的海量信息。2007年1月独自驾船出海后失踪。</p> \n <p>&nbsp;</p> \n <p>起初Jim Gray是做操作系统研究的，之所以转行研究数据库系统，据Jim Gray自己的说法是这样的：有一次，他上司的上司来到他办公室，对他说“Jim啊，你看现在市场上已经出现了这么多的操作系统，但是还没有一个像样的网络操作系统和数据库系统，如果你真想在IBM做出点成绩的话，研究网络操作系统和数据库系统是很有前途的！”，于是Jim Gray就听从了他的建议。其实当时Jim Gray正在做关于面向对象操作系统的研究，现在看来这个选择也是对的，因为面向对象操作系统这个方向很快就被人们放弃了。</p> \n <p>&nbsp;</p> \n <p>Jim Gray有个好习惯，就是经常记笔记写备忘录。无论何时去旅行，都会写旅行报告；无论何时与人谈话都会把得到的想法做备忘录，凭借这些，他写了许多文章，参加了很多国际会议，并出了名。开发System R时，同事Franco一年写了两万行代码，但Jim Gray经常花时间写作，旅游，一年才写了一万行代码，于是老大经常会去敲他的门说“快点写代码!!-_-”，根据Jim Gray的回忆，整个开发过程中他大概写了五万到七万行代码，主要是涉及并发控制，系统恢复，系统启动，安全性管理等方面。</p> \n <p>&nbsp;</p> \n <p>本文主要参考“Concurrency Control and Recovery in Database Systems”，重点回顾下2PC的相关知识。</p> \n <p>]</p> \n <p>&nbsp;</p> \n <p><strong>背景介绍</strong></p> \n <p>&nbsp;</p> \n <p>事务处理的困难源于两个方面：concurrency和failures。为了达到高的性能，并发是必要的。而在现实中，计算机系统会面临各种各样的故障，操作系统可能会出错，硬件也有可能会出错。当这些错误发生时，应用程序可能会在正执行的过程中被打断，而这可能会产生错误的结果。比如用户正在转账，在中间失败可能会导致一个账户上的钱少了，但是另一个账户却没有收到钱的情况。Recovery就是要避免因故障而产生错误结果。所以就引出了Concurrency Control和Recovery这两个概念。</p> \n <p>&nbsp;</p> \n <p>对于一个解决了并发控制和恢复问题的系统来说，在用户看来，所有程序的执行都是原子的(看起来就好像没有其他程序在并行执行)，可靠的(看起来好像并没有故障发生)。这种原子的可靠的程序执行过程就称之为事务。并发控制算法用来保证事务原子性地执行。</p> \n <p>&nbsp;</p> \n <p>一个分布式事务T有一个主节点—即发起事务的那个节点。T首先将它的操作提交给位于主节点上的TM(transaction manager)，之后TM再将这些操作转发给其他对应的节点。比如一个Read(x)或者Write(x)操作将会被转发给x所在的那个节点，然后由那个节点的调度器和DM进行处理，看起来就像是一个本地事务一样。之后会再将操作结果返回给主节点上的TM。因此，除了需要对节点间的请求和响应进行路由外，在一个分布式DBS中对读写操作的处理与一个集中式的系统并没有什么不同。</p> \n <p>&nbsp;</p> \n <p>现在来考虑下T的Commit操作。这个操作需要转发给哪些节点呢？不像Read(x)或者Write(x)操作那样，只需要关注存储了x的那个节点，Commit操作需要关注所有与事务T的处理相关的节点。因此，T的主节点上的TM需要将T中的Commit操作转发给那些T中数据访问涉及的所有节点。对于Abort操作也是一样。也就是说要求单个处理操作(Commit或者Abort)必须作用在分布式DBS的多个节点上，这是集中式与分布式事务处理的一个根本区别。</p> \n <p>&nbsp;</p> \n <p>这个问题比它表面上看起来的要复杂地多。仅仅让分布式事务主节点上的TM给其他所有节点发送Commit操作是不够的。这是因为TM发送了Commit操作并不意味着事务提交完成了，还要DM执行这个Commit操作。虽然TM发送了Commit操作，但是调度器有可能拒绝这个请求，同时将事务Abort。在这种情况下，如果事务是分布式的，那么还需要所有相关节点也都要进行Abort。</p> \n <p>&nbsp;</p> \n <p>集中式与分布式事务的另一个重要的不同点在于它们各自所需关注的错误的属性上。在集中式系统中，错误都是要么不错要么全错(all-or-nothing)，也就是说要么系统正常工作事务正常处理，要么系统出错不会有任何事务完成。但是在分布式系统中，可能出现部分失败(partial failures)的情况，某些节点正常工作但是其他一些节点出错了。</p> \n <p>&nbsp;</p> \n <p>在分布式系统中故障不一定导致严重问题的这种属性为分布式系统提高自身可靠性创造了机会。同时这也是分布式系统倍受推崇的一个属性。但是很少被人提到的是，这种局部失败的情况正是造成分布式系统中很多难解的问题的根源。</p> \n <p>&nbsp;</p> \n <p>在事务处理中就有这样的一个难解问题，即事务终止的一致性。如前所述，分布式事务的Commit或Abort操作必须要保证在事务的数据访问涉及到的所有节点上执行。在允许局部失败的情况下，这个问题变得非常复杂。</p> \n <p>&nbsp;</p> \n <p>我们将可以保证这种一致性的算法称为原子性提交协议(ACP-atomic commitment protocol)。本章我们的主要目标就是介绍这种可以容忍各种错误的ACP协议。在具体介绍之前，我们先详细介绍下分布式系统中存在的各种错误类型。</p> \n <p>&nbsp;</p> \n <p><strong>分布式系统中的故障</strong></p> \n <p>&nbsp;</p> \n <p>分布式系统由两种组件组成：负责处理信息的节点和负责在节点间传递消息的通信链路。通常可以用一个图来进行表示，图的结点代表节点，无向边代表双向的通信链路(如图7-1)。</p> \n <p><img alt=\"分布式事务之两阶段提交 - 星星 - 银河里的星星\" src=\"http://img9.ph.126.net/zLMqW3dxwN52Le2zd3FLAw==/6597564546889655619.png\"></p> \n <p>我们假设图是连通的，即任意结点间都存在一条路径。因此任意两个节点都可以通过它们间的一个或者是多个链路进行通信。我们将这种可以让节点间进行消息传输的软硬件设备统称为计算机网络。我们不需要担心消息是如何被路由的，对于分布式数据库系统来说路由是网络系统提供的基本服务。</p> \n <p>&nbsp;</p> \n <p><strong>节点故障</strong></p> \n <p>&nbsp;</p> \n <p>当节点发生系统故障时，进程将会异常终止同时内存内容会丢失。在这种情况下，我们就说节点发生故障了。当节点从故障中恢复时将会首先执行一个恢复过程，使得节点可以达到一个一致性状态，之后才可以继续正常的处理过程。</p> \n <p>&nbsp;</p> \n <p>在这种故障模型中：站点要么是可以正常工作(称它是operational的)要么是完全无法工作(称之为down)，它永远都不会执行错误的动作，这种类型的行为也被称为fail-stop。很明显这有些理想化。由于软硬件bug的存在，计算机偶尔还是有可能会执行不正确的动作。通过不断的测试以及软硬件内建的冗余，可以构建出一个基本上满足fail-stop的系统。我们并不想在本文中深入讨论这些技术，我们假设节点都是fail-stop的。本章中我们将要讨论的各个协议的正确性将会基于这个假设。</p> \n <p>&nbsp;</p> \n <p>尽管单个节点只有两个状态，要么正常工作要么停止工作，但是不同节点可能处于不同状态。这样仍然会存在一种局部故障(partial failure)的情况：某些节点正常某些节点down掉。如果所有节点都down掉的话就是total failure的情况。</p> \n <p>&nbsp;</p> \n <p>Partial Failure很难处理。从根本上说，这是因为正常工作的节点根本无法确定失败的那些节点的状态。在这些不确定性解决之前，正常节点可能会被阻塞，无法Commit或者Abort一个事务。原子性提交协议的一个重要设计目标就是要尽量将单个节点的故障的影响最小化，使得其他节点可以继续处理。</p> \n <p>&nbsp;</p> \n <p><strong>通信故障</strong></p> \n <p>&nbsp;</p> \n <p>通信链路也有可能发生故障。故障可能使得节点之间无法通信。可能有各种各样的通信故障：消息内容可能会由于链路上的噪声被破坏；链路可能临时失灵，导致单个消息完全丢失；链路可能会中断一段时间，导致通过它的所有消息都丢失。</p> \n <p>&nbsp;</p> \n <p>消息的损坏可以通过错误检测码进行检测，然后在接收者检测到错误的时候进行重传来进行高效地处理。由于链路故障导致的消息丢失可以通过重传丢失的消息进行处理。同时，也可以通过重新路由来降低链路丢包概率。如果消息是从节点A传给节点B的，但是由于链路断开导致网络无法对消息进行传输，那么网络系统会尝试寻找一条新的从A到B的路径。错误检测码，消息重传以及重新路由通常都是由计算机网络协议提供的功能。</p> \n <p>&nbsp;</p> \n <p>不幸的是，即使有自动的重新路由，节点和链路的故障仍可能导致节点间无法通信。当节点间的所有路径上都包含一个有故障的节点或链路时就会出现这种情况。通常称之为网络分区，它会将所有节点分割为两个或者更多个子集，在子集内部的节点相互可以通信，子集之间无法通信。比如，图7-2就展示了图7-1的一个系统分区。图中包含两个分区{B,C}和{D,E}，是由节点A和链路(C,D)(C,E)的故障造成的。</p> \n <p>&nbsp;</p> \n <p>当节点恢复和链路修复后，那些之前无法交换信息的节点的通信就会恢复。比如图7-2，如果节点A恢复或者(C,D)(C,E)中有一个修复了，那么这两个分区就又连接起来了，所有的节点就又可以通信了。</p> \n <p><img alt=\"分布式事务之两阶段提交 - 星星 - 银河里的星星\" src=\"http://img5.ph.126.net/2P4EUOyf-4niSJQY6sadXw==/6597756961424518995.png\"></p> \n <p>&nbsp;</p> \n <p>我们可以通过设计一个高度互联的网络来降低网络分区发生的概率，这样部分节点和链路的故障不会导致节点间的路径全部不通。但是，构建一个高度互联的网络需要使用更多的组件，因此成本会更高。此外，网络拓扑还会受到其他因素的限制，比如地理位置和通信媒介。因此，分区是无法完全避免的。</p> \n <p>&nbsp;</p> \n <p>总之，通信故障发生在节点A无法与节点B无法通信时，尽管两个节点都没有down掉。通信故障可能会引发网络分区。如果两个节点可以通信，消息就会被正确地传输。</p> \n <p>&nbsp;</p> \n <p><strong>无法传送的消息</strong></p> \n <p>&nbsp;</p> \n <p>节点和通信故障的存在需要我们能够处理那些不能发送的消息。消息可能会因为接收者down掉或者网络分区的存在，而无法发送。有两种选择：</p> \n <p>1. 持久化消息。由网络系统对消息进行存储，在可以发送时再发送</p> \n <p>2. 丢失消息。网络系统不再尝试重发</p> \n <p>我们选择第2种方式，这也是很多设备采用的方式。第1种方式需要非常复杂的协议，它们本身非常类似于ACPs，基本上等于是将原子性提交问题扩散到了系统中另一个部分。</p> \n <p>&nbsp;</p> \n <p>采用第2种方式的网络系统会尝试通知消息的发送者消息被丢掉了。但是这样也有其固有的不可靠性。如果节点无法对收到的消息进行确认，网络是无法判断出是这个节点根本没有收到消息还是它已经收到了消息只是确认时失败了。即使它能区分出这个不同，对未发送消息的发送者的通知也可能导致无穷递归，比如如果进行通知的消息本身未能发送成功，那么通知的发送者也需要再次被通知，就会再次产生通知消息，如此循环。因此，是不能依赖这种未发送消息的通知机制的。</p> \n <p>&nbsp;</p> \n <p><strong>通过超时检测故障</strong></p> \n <p>&nbsp;</p> \n <p>节点故障和通信故障都可能使得一个节点无法与另一个节点进行通信。也就是说，如果节点A无法与节点B进行通信，那么要么是因为B出问题了，要么是因为A和B分属于不同的分区。通常，A无法区分出这两种情况。它只是知道无法与B进行通信。</p> \n <p>&nbsp;</p> \n <p>那A怎么知道无法与B进行通信呢？通常都是通过超时机制来确定的。A向B发送一个消息，然后等待一个预先确定的时间段，称之为超时时间段。在此期间，如果收到了响应，那么很明显A和B是可以通信的。如果超过了这个时间段，A还没有收到响应，那么A就认为它无法与B完成通信。这个时间段必须是从A到B发送消息加上B处理消息再加上返回给A这三个过程所花费的最大可能时间。找出一个合理的超时时间并不是一件简单的事情。它依赖于很多难以量化的参数：节点和通信链路的物理特性，系统负载，消息路由算法，时钟精度等等很多因素。实践中通常也只是选择一个对大多数情况都算合理的超时时间。在使用超时机制时，我们都是假设已经定好了这样的一个超时时间取值。事实上，即使是还没到超时时间，节点也有可能认为它无法与另一节点通信。这种情况的发生通常是因为时钟不精确导致的。我们通常将这类故障称为timeout failures或者performance failures。与网络分区不同，这类故障可能会导致很奇怪的情况，比如A认为它可以与B进行通信，但是B却认为它无法与A通信；或者是A认为它可以与B通信，同时B认为可以跟C通信，但是A却认为它不能与C进行通信。</p> \n <p>&nbsp;</p> \n <p><strong>原子性提交</strong></p> \n <p>&nbsp;</p> \n <p>考虑一个执行过程涉及到节点S1,S2…Sn的分布式事务T。假设S1上的TM负责管控T的执行。在S1上的TM向S1,S2…Sn发送Commit操作之前，它必须确保每个节点上的调度器和DM已经准备好并且可以进行Commit。否则，T就可能在某些节点上进行了Commit，而在某些节点上进行了Abort，这样就产生了不一致。我们来看一下调度器和DM满足什么样的条件才算是准备好并且可以进行Commit了。</p> \n <p>&nbsp;</p> \n <p>只要T在节点上满足了可恢复条件，那么该节点上的调度器就允许进行Commit(T)操作。也就是说，只要其他事务针对事务T读取的所有值的相关写入都提交了就可以了。需要注意的是如果调度器产生的执行过程是不会级联abort的，那么上面的条件就总是成立的。在这种情况下，因为调度器随时都可以处理Commit(T)操作，S1的TM发送Commit操作就不需要征求调度器的意见。</p> \n <p>&nbsp;</p> \n <p>只要T在节点上满足了Redo规则，那么该节点上的DM就可以执行Commit(T)了。也就是说，该节点上所有由T写入的value值都已经进入了可靠性存储中—数据库或者日志中，取决于DM的恢复算法。如果T仅仅是向某些节点提交了读请求，那么它就不需要征求这些节点的DM意见。</p> \n <p>&nbsp;</p> \n <p>只有当得到了来自所有节点的调度器和DM的允许后，S1上的TM才能向所有节点的调度器和DM发送Commit(T)。实际上，这就是我们要在下一节中讨论的两阶段提交协议(2PC)。为什么我们要将这样一个看起来很简单的思路放到单独的一节中讨论呢？原因是前面的这些讨论并未解决节点或者通信故障。如果说在处理中有一个或者多个节点出错了会怎么样呢？如果有一个或多个消息丢失了会怎样呢？原子性提交问题的真正难点就在于设计一个具有高度容错性的协议。</p> \n <p>&nbsp;</p> \n <p>为简化讨论以及专注于原子性提交问题的本质，我们不再局限于TM-调度器-DM模型。为将原子性提交问题从事务处理的其他概念中剥离出来，我们假设对于每个分布式事务T，在执行T的每个节点上都有一个进程。这些进程负责为事务T实现原子性提交。我们把在T主节点上的进程称为T的协调者。剩余进程称为T的参与者。协调者知道所有参与者的名字，因此它可以向它们发送消息。参与者知道协调者的名字，但是它们相互之间并不知晓。</p> \n <p>&nbsp;</p> \n <p>需要强调的是协调者和参与者都是我们为了阐述的方便进行的抽象。实际实现中并不需要参与事务执行的每个节点为每个事务创建一个独立进程。通常，这样的实现都会是很低效的，因为需要管理大量的进程。协调者和参与者进程都是一种抽象，实际中在每个节点上可以由单个或多个进程提供它们的功能，而且通常都是由多个事务共享的。</p> \n <p>&nbsp;</p> \n <p>我们还假设每个节点都包含一个分布式的事务日志(DT log)，协调者和参与者可以将事务相关的信息记录在日志中。DT log必须保存在可靠性存储中，因为它的内容必须不受节点故障的影响。</p> \n <p>&nbsp;</p> \n <p>严格地讲，原子性提交协议(ACP)是一种由协调者和参与者执行的算法，通过它来保证协调者和所有的参与者要么是将事务提交要么是将事务回滚。我们可以更精确地描述如下。每个进程只能投两种票：Yes或No，同时最终只能达成一个决定：Commit或Abort。ACP是一种可以让进程达成如下决定的算法：</p> \n <p>AC1：所有达成决定的进程达成的都是相同决定</p> \n <p>AC2：进程一旦达成决定，就不能再改变该决定</p> \n <p>AC3：只有当所有进程都投Yes的时候，才能达成Commit决定</p> \n <p>AC4：如果没有故障并且所有进程投的都是Yes，那么决定最终将会是Commit</p> \n <p>AC5：假设执行中只包含算法设计中可以容忍的那些故障，在执行中的任意时刻，如果所有现有故障都已修复同时在足够长的时间内都不再有新故障发生，那么所有进程最终将会达成一个决定。</p> \n <p>&nbsp;</p> \n <p>该问题的抽象形式与TM-调度器-DM模型的事务处理联系如下。只有当A的调度器和DM已经准备好并且可以进行Commit，节点A上的进程才能投Yes。如果进程决定Commit(或Abort)，那么A的DM要执行Commit(或Abort)操作。在执行该操作时，节点A就像一个集中式DBS，采用第6章中的算法。实际上，处理事务的不同节点可以使用不同的DM算法。</p> \n <p>&nbsp;</p> \n <p>现在我们再讨论下这些条件。AC1是说事务终止的一致性。需要注意的是，我们并未要求所有进程达成一个决定。这也是一个不现实的目标，因为一个进程可能在发生故障后永不恢复。我们甚至也不要求所有正常的进程达成一个决定。这也是不现实的，尽管原因没有那么显而易见。但是，我们确实是要求一旦所有故障被修复所有进程能达成一个决定(AC5)，这个需求就将那些一旦发生故障就允许进程永远处于未决议状态的无意义协议排除了。</p> \n <p>&nbsp;</p> \n <p>AC2是说节点上事务的执行结果是不可更改的。如果事务一旦提交(或abort)，那么之后它就不能再被abort(或提交)。</p> \n <p>&nbsp;</p> \n <p>AC3是说只有当事务执行中涉及的所有节点都同意时事务才能提交。AC4是AC3的逆的一个弱化版本。它确保了在某些情况下必须达成Commit决定，因此就将那些总是采用选择Abort的平凡解法的协议排除在外了。但是我们也并不要求AC3的逆完全成立。因为就算所有进程都投的是Yes，但是最终还是有可能Abort的(比如发生了故障，进程投的Yes并未被接收到)。关于AC3的一个非常重要的推论是，在进程还未投Yes的情况下，它可以在任意时刻单方面的选择Abort。另一方面，一旦投了Yes它就不能再单方面地采取行动。在进程投了Yes之后到它获取足够的信息来确定最终决定是啥之前，这中间的这个时间段称为进程的不确定区间(uncertainty period)。当进程处在这个时间段时，我们就说进程是不确定的(uncertain)。在这个时间段内，进程既不知道最终决定是要Commit还是Abort，也不能单方面地决定Abort。</p> \n <p>&nbsp;</p> \n <p><strong>场景1</strong>：在P处于不确定状态时，故障导致进程P与其他进程不可通信。根据不确定区间的定义，在故障恢复之前进程无法达到决定状态。</p> \n <p>&nbsp;</p> \n <p>在继续处理之前进程必须等待故障被修复，也就是说它被阻塞了。阻塞并不是我们期望的，因为它可能导致进程等待任意长的时间。场景1表明通信故障可能导致进程被阻塞。</p> \n <p>&nbsp;</p> \n <p><strong>场景2</strong>：在处于不确定状态时，进程P发生故障。在P恢复时，它无法仅通过它自身决定状态。它必须与其他进程进行通信以确定决定是啥。</p> \n <p>&nbsp;</p> \n <p>我们将进程不需要与其他进程进行通信就能够进行恢复的能力称为独立可恢复性(independent recovery)。这种能力非常吸引人，因为它简单低廉。此外，如果缺乏这种能力那么在所有进程都发生故障的情况下，会导致阻塞。比如，我们假设p是在一个total failure中第一个恢复的进程，因为p处于不确定状态，因此它需要与其他进程进行通信以确定状态，但是其他的都还down着呢，因此它就无法与它们进行通信，因此p就被阻塞了。</p> \n <p>&nbsp;</p> \n <p>这两个场景表明，在进程处于不确定状态时发生的故障可能导致严重的问题。那么我们是否能够设计出一种没有不确定阶段的ACPs？不幸的是，不能。我们有如下一些结论：</p> \n <p>1. 如果可能发生通信故障或者完全故障，那么所有的ACPs都可能会导致进程被阻塞</p> \n <p>2. 没有一种ACP可以保证故障进程的独立可恢复性</p> \n <p>&nbsp;</p> \n <p><strong>两阶段提交协议</strong></p> \n <p>&nbsp;</p> \n <p>两阶段提交协议是最简单最流行的ACP。在没有故障发生的情况下，它的执行过程如下：</p> \n <p>1. 协调者发送一个VOTE-REQ消息给所有的参与者</p> \n <p>2. 当参与者接收到VOTE-REQ消息后，它会发送一个包含参与者投票结果的消息(YES或NO)给协调者作为响应。如果参与者投的是No，它会决定Abort事务并停止运行</p> \n <p>3. 协调者收集来自所有参与者的投票信息。如果所有的消息都是YES，同时协调者投的也是Yes，那么协调者就会决定进行Commit，并向所有参与者发送COMMIT消息。否则协调者就会决定进行Abort，并向所有投Yes的参与者发送ABORT消息(那些投No的参与者已经在第2步中决定Abort了)。之后，对于这两种情况协调者都会停止运行</p> \n <p>4. 每个投Yes的参与者等待来自协调者的COMMIT或ABORT消息。收到消息后执行相应动作然后停止运行。</p> \n <p>&nbsp;</p> \n <p>2PC的两个阶段是指投票阶段(步骤1和2)和决定阶段(步骤3和4)。参与者的不确定区间始于向协调者发送YES(步骤2)，终于接收到COMMIT或ABORT消息(步骤4)。协调者没有不确定区间，因为只要它投了票结果就确定了，当然它投票时需要知道参与者的投票结果(步骤3)。</p> \n <p>&nbsp;</p> \n <p>很容易可以看出2PC满足条件AC1-AC4。不幸的是，目前为止的描述并不满足AC5。有两个原因，首先在协议的很多点上，进程在继续处理之前必须要等待消息。但是消息可能会由于故障而无法到达。因此，进程可能会无限等待下去。为避免这个问题，需要使用超时机制。当进程的等待因为超时而打断时，进程必须采取特定的动作，称之为超时动作。因此，为满足AC5，必须为协议中进程需要等待消息的地方引入合理的超时动作。</p> \n <p>&nbsp;</p> \n <p>其次，当进程从故障中恢复时，AC5要求进程能够达成与其他进程可能已经达成的决定相一致的决定(可能还必须要等待某些其他故障修复之后才能达成这样的决定)。因此，进程还必须要将某些信息存入可靠性存储中，比如DT log中。为满足AC5，我们还必须要说明需要将哪些信息存入DT log以及如何在恢复时使用它们。下面我们分别来考虑这两个问题。</p> \n <p>&nbsp;</p> \n <p><strong>超时处理</strong></p> \n <p>&nbsp;</p> \n <p>在2PC中有如下三个需要进程等待消息的地方：在步骤2,3和4的开始阶段。在步骤2中，参与者需要等待来自协调者的VOTE-REQ消息。这发生在参与者进行投票之前。由于任何一个进程在它投Yes之前都可以单方面地决定进行Abort，因此如果参与者在等待VOTE-REQ消息时超时，它可以简单地决定进行Abort，然后停止运行。</p> \n <p>&nbsp;</p> \n <p>在步骤3中，协调者需要等待来自所有参与者的YES或NO消息。在这个阶段，协调者也还没有达成任何决定。此外，也没有任何参与者已经决定要Commit。因此协调者可以决定进行Abort，但是必须要向给它发送YES的每个参与者发送ABORT消息。</p> \n <p>&nbsp;</p> \n <p>在步骤4中，投了Yes的参与者p要等待来自协调者的COMMIT或ABORT消息。此时，p处于不确定状态。因此，与前面两种情况下进程可以单方面进行决定不同，在这种情况下参与者必须与其他进程商议决定如何动作。这个商议过程需要通过执行一个terminaion protocol来完成。</p> \n <p>&nbsp;</p> \n <p>最简单的terminaion protocol如下：在与协调者的通信恢复之前p始终保持阻塞。之后，协调者通知p对应的决定结果。协调者肯定支持这样做，因为它没有不确定区间。该terminaion protocol满足AC5，因为如果所有的故障都修复了的话，p就能与协调者通信，然后就能达到决定状态。</p> \n <p>&nbsp;</p> \n <p>这种简单的terminaion protocol缺点在于，p可能要经历不必要的阻塞。比如，假设现在有两个参与者p和q。协调者先给q发送了一个COMMIT或ABORT消息，但是在发送给p之前发生了故障。因此，尽管p是不确定的，但是q不是。如果p可以与q进行通信，那么它就可以从q那得知最终的决定结果。并不需要一直等待着协调者的恢复。</p> \n <p>&nbsp;</p> \n <p>但是这意味着需要参与者之间需要相互知晓，这样它们才能相互直接通信。但是我们前面描述原子性提交问题时，只是说协调者认识所有参与者，参与者认识协调者，但是参与者初始时相互并不知晓。但是这也不是什么大问题，我们可以让协调者在发送VOTE-REQ消息时将参与者信息附加在上面，发给所有参与者。这样在参与者接收到该消息后，相互就都知道了。事实上，在发送该消息之前它们之间也是不需要相互知晓的，因为如果参与者在接收到VOTE-REQ消息前超时了，它可以单方面地决定进行Abort。</p> \n <p>&nbsp;</p> \n <p>下面我们再来介绍下cooperative terminaion protocol：参与者p如果在不确定区间超时，它会发送一个DECISION-REQ消息给所有其他进程，设为q，问下q是否知道决定结果或者能否单方面地做出决定。在这个场景中，p是initiator，q是responder。有如下三种情况：</p> \n <p>1. q已经决定进行Commit(或Abort)：q简单地发送一个COMMIT(或ABORT)消息给p，然后p进行相应动作</p> \n <p>2. q还未进行投票：q可以单方面地决定进行Abort。然后它发送ABORT消息给p，p会因此决定进行ABORT</p> \n <p>3. q已经投了Yes但是还未做决定：q也是处于不确定状态，因此无法帮助p达成决定。</p> \n <p>&nbsp;</p> \n <p>对于该协议来说，如果p可以同某个进程q通信并且上述1或2成立，那么p就可以不经阻塞地达成决定。另一方面，如果p通信的所有进程都是3成立，那么p就会被阻塞。那么p将会一直阻塞，直到故障修复的出现了某个进程q满足条件1或2为止。至少会有一个这样的进程，即协调者。因此这个terminaion protocol满足AC5。</p> \n <p>&nbsp;</p> \n <p><strong>恢复</strong></p> \n <p>&nbsp;</p> \n <p>考虑一个从故障中恢复的进程p，为满足AC5，p必须能够达成一个与其他进程相一致的决定—不一定是恢复完成后就要达成，可能是在等其他故障恢复后的某个时间段内。</p> \n <p>&nbsp;</p> \n <p>假设p恢复时它还记得发生故障时的状态—后面我们会再讨论如何做到这一点。如果p是在它向协调者发送YES之前发生了故障(2PC的步骤2)，那么p可以单方面地决定进行Abort。另外，如果p是在接收到来自协调者的COMMIT或ABORT消息或者已经单方面地决定Abort之后发生的故障，那么此时它已经完成了决定。在这些情况下，p都可以独立地完成恢复。</p> \n <p>&nbsp;</p> \n <p>但是如果p是在处于不确定区间时发生了故障，那么恢复时就无法仅通过自身来完成决定。因为它已经投了Yes，有可能所有其他进程也都投了Yes，这样在p挂掉的时候就已经决定要Commit了。但是也有可能其他一些进程投了No或者是根本还没有投，最终决定变成是要Abort。仅仅依赖本地信息，p无法区分出这两种可能，因此必须与其他进程通信再做决定。这也从一个方面说明了为何没法进行独立地恢复(independent recovery)。</p> \n <p>&nbsp;</p> \n <p>这种情况就跟p等待来自协调者的COMMIT或ABORT消息而超时了的情况是一样的。因此p可以通过使用terminaion protocol达成决定。需要注意的是p可能会被阻塞，因为它可以进行通信的那些进程也是处于不确定状态。</p> \n <p>&nbsp;</p> \n <p>为了记住故障发生时的状态，每个进程必须保存一些信息到节点的DT log中。当然，每个进程只能访问它本地的那个DT log。假设使用的是cooperative terminaion protocol，DT log的管理方式如下：</p> \n <p>1. 当协调者发送VOTE-REQ消息时，它会在DT log中写入一条start-2PC记录。该记录包含了所有参与者的标识符，同时写入可以发生在发送消息之前或之后。</p> \n <p>2. 如果参与者投了Yes，它会在向协调者发送YES消息前向DT log中写入一条记录。该记录包含了协调者名称及参与者列表(由协调者通过VOTE-REQ消息提供)。如果参与者投了No，它可以在向协调者发送NO消息之前或之后写入一个abort记录。</p> \n <p>3. 在协调者向参与者发送COMMIT消息之前，它会向DT log中写入一条commit记录。</p> \n <p>4. 当协调者向参与者发送ABORT消息时，它会向DT log中写入一条abort记录。写入可以发生在发送消息之前或之后。</p> \n <p>5. 在收到COMMIT(或ABORT)消息后，参与者向DT log中写入一条commit(或abort)记录。</p> \n <p>在上述讨论中，在DT log中写入一条commit(或abort)记录实际上就代表进程决定了是Commit还是Abort。</p> \n <p>&nbsp;</p> \n <p>现在可以来简单介绍下事务提交过程是如何与事务处理的其他活动进行交互的。一旦commit(或abort)记录写入了DT log，DM就可以执行Commit(或Abort)操作了。当然这其中还有大量的细节需要考虑。比如，如果DT log是作为DM log的一部分实现的，那么commit(或abort)记录的写入就可能需要通过调用本地DM的接口来实现。通常来说，细节上如何来操作取决于本地DM采用了什么样的算法。</p> \n <p>&nbsp;</p> \n <p>当节点S从故障中恢复时，分布式事务在S上的执行取决于DT log的内容：</p> \n <p>? 如果DT log包含一个start-2PC记录，那么说明S就是协调者所在节点。如果它还有commit(或abort)记录，那么说明在发生故障前协调者已经做出了决定。如果这两种记录(commit或abort)都没有找到，那么协调者可以通过向DT log中插入一条abort记录来单方面地决定进行Abort。这样可以工作的关键在于，协调者是先将commit记录写入DT log，然后再发送COMMIT消息的(上面的第3点)。</p> \n <p>? 如果DT log中没有start-2PC记录，那么S就是参与者节点。那么有如下三种可能：</p> \n <p>? DT log中包含一个commit(或abort)记录。那么说明在发生故障之前，参与者已经达成了决定。</p> \n <p>? DT log中没有yes记录。那么要么是参与者是在投票前发生的故障，要么投的是No(但是在发生故障前还没有完成abort记录的写入)。(这也是为何yes记录必须要在发送YES消息前写入日志的原因；参考上面的第2点。)因此，它可以单方面地通过向DT log中写入一条abort记录决定进行Abort。</p> \n <p>? DT log中包含了yes记录，但是没有commit(或abort)记录。那么说明参与者是在不确定区间内发生的故障。它可以通过使用terminaion protocol来达成决定。回想一下，yes记录中包含了协调者名称以及所有的参与者，这正是terminaion protocol所需要的。</p> \n <p>&nbsp;</p> \n <p>图7-3和7-4给出了2PC协议和cooperative terminaion protocol的具体实现，包括了上面讨论的关于超时处理和DT log相关的处理动作。算法的表达比较随意，但是直接明了。我们采用send和wait来表示进程间通信。比如“send m to p”，m代表一个消息，p代表一个或多个进程，总的意思就是执行进程将m发送给p中的所有进程。“wait for m from p”，m代表一个或多个消息，p代表一个进程，总的意思就是执行进程一直等待，直到收到来自p的消息m。如果消息可能来自多个目标，那么如下两种表示方式，“wait for m from all p”表示进程会一直等待直到收到p中所有进程发送的消息，“wait for m from any p”表示进程会一直等待直到收到p中某个进程发送的消息。为避免无限等待，可以在“wait for”语句后面加上一个“on timeout S”进行限定，S代表某种执行语句。这意味着如果消息在一个预先定义的超时时间内还未收到，那么就不再继续等待，同时语句S将会被执行，之后控制流将会继续正常往下执行，除非S中做了一些特殊控制。如果消息在正常时间内到达，那么S将会被忽略。</p> \n <p><img alt=\"分布式事务之两阶段提交 - 星星 - 银河里的星星\" src=\"http://img9.ph.126.net/f4qXuumZmTPNznB7rsi1tw==/6597306161656629089.jpg\"></p> \n <p><img alt=\"分布式事务之两阶段提交 - 星星 - 银河里的星星\" src=\"http://img2.ph.126.net/nSyaB81fBr3SHZLhutN1yA==/6598159382680069822.png\"></p> \n <p>&nbsp;</p> \n <p>&nbsp;&nbsp;</p> \n <p>尽管我们一直描述的是针对单个事务的ACPs，但是很明显DT log将会包含来自多个事务的与原子性提交相关的记录信息。因此，为防止不同事务间记录信息的混淆，start-2PC,yes,commit和abort记录都会包含一些信息标识它们属于哪个事务。此外，也需要对DT log中的那些过期信息进行垃圾回收。在垃圾回收时，有如下两个基本原则需要遵守：</p> \n <p>GC1：至少要等到RM执行了RM-Commit(T)和RM-Abort(T)之后，节点才能将事务T的相关日志记录从它的DT log中删除。</p> \n <p>GC2：至少有一个节点在它收到事务T涉及的所有节点都执行了RM-Commit(T)和RM-Abort(T)的消息之前，不会将事务T的相关日志记录从它的DT log中删除。</p> \n <p>&nbsp;</p> \n <p>GC1是说与事务T的执行相关的节点，在该事务作用于该节点之前它必须牢记该事务的存在。GC2是说，与事务T的执行相关的某个节点，在该节点确认事务在所有节点上成功执行之前，必须记住事务T的状态。如果不是这样的话，那么从故障中恢复的一个节点可能会无法获取T的状态，同时它也永远都不能确定事务T的状态，这就违背了AC5。</p> \n <p>&nbsp;</p> \n <p>通过使用每个节点上的本地信息就可以确保GC1。但是GC2需要节点间通信的支持。为了实现GC2通常有两种极端策略：GC2只对一个节点成立，通常都是协调者；GC2对于T的执行相关的所有节点都成立。</p> \n <p>&nbsp;</p> \n <p>我们关于ACP的研究都是从单个事务的角度来看的，这也隐藏了节点恢复时的一些问题。在一个节点恢复时，它必须要为那些故障发生前还未commit或abort的所有事务完成ACP的执行。什么时候节点可以恢复正常的事务处理呢？在一个集中化的DBS恢复后，在重启过程完成之前事务是无法被处理的，因为需要恢复那些已存储的数据库状态。分布式DBS中的节点恢复也与之类似，因为某些事务可能会被阻塞。在这种情况下，在该恢复节点的DBS在所有被阻塞的事务被提交或abort之前也是不可访问的。</p> \n <p>&nbsp;</p> \n <p>避免这种问题的方法取决于所使用的调度器类型。考虑strict 2PL的情况。当节点的恢复过程已经为所有的未阻塞事务完成决定时，它应该通知调度器来重新获取那些在故障发生之前由被阻塞的事务占有的锁。实际上，一个被阻塞的事务T只需要获取它的写锁。问题在于锁表通常是保存在内存中的，因此在系统发生故障时会丢失。为避免丢失这些信息，负责管理T的原子性提交的进程需要将T的写锁也记录到它写入到DT log中的yes记录中。当然如果这些信息可以从该节点的RM维护的日志中获取，就没必要这样做。比如，在第6章描述的undo/redo算法，因为在T投Yes之前，所有的更新都会进入日志。这些记录就可以用来确定T的写锁集合。</p> \n <p>&nbsp;</p> \n <p><strong>针对2PC的评价</strong></p> \n <p>&nbsp;</p> \n <p>我们可以从如下几个维度来对2PC进行评价：</p> \n <p>Resiliency：可以容忍哪些故障？</p> \n <p>Blocking：进程是否有可能被阻塞？如果是，什么情况下会被阻塞？</p> \n <p>时间复杂度：达成决定需要花多长时间？</p> \n <p>消息复杂度：达成决定需要多少次消息交换？</p> \n <p>&nbsp;</p> \n <p>前两个维度用来衡量协议的可靠性，后两个用来衡量协议的效率。可靠性和效率是两个冲突的目标：任意一个都可以以另一个为代价来获得。协议如何选择取决于对于特定的应用来说哪个目标更重要。但是，无论协议如何选择，我们都需要尽力对无故障时的情况进行优化—主要是提高系统的正常工作速率。</p> \n <p>&nbsp;</p> \n <p>我们通过对非阻塞情况下节点达成一个决定最坏情况下所需要的消息交换轮数进行计数，来衡量ACP的时间复杂度。轮代表了消息到达目标节点所需的最大时间。用于故障检测的超时机制就是基于这个最大的消息延迟是已知的这样一个假设。需要注意的是，一轮内可能会有很多消息被发送—就看有多少个发送者-接收者对。如果一个消息必须等另一个消息接收到之后才能发送，那么这两个消息就肯定属于不同的轮。比如，2PC中的COMMIT和YES消息就属于不同的轮，因为前者必须要等接收到后者后才能发送。另一方面，所有的VOTE-REQ消息就属于同一轮，因为它们是并发地发送到目标节点的。对于所有的COMMIT消息来说也是这样。用于计算轮数的一种简单方式就是认为同一轮中发送的消息都是同时发出的，同时具有相同的延迟。因此，每一轮都是从消息发送时开始，在消息被接收后结束。</p> \n <p>&nbsp;</p> \n <p>使用轮来衡量时间复杂度实际上就忽略了消息处理所需的时间。这也是合理的，因为通常情况下消息传输延迟都要远远大于消息处理延迟。但是，如果要想得到一个更精确的时间复杂度度量，还需要将另外两个因素考虑进来。</p> \n <p>&nbsp;</p> \n <p>首先，如目前所知，进程必须在发送或接收特定消息时将它们记录到DT log中。在某些情况下，这样的一个文件服务器是在一个本地网络中，这种针对可靠性存储的访问也会引入与消息发送相当的开销。因此针对可靠性存储的访问次数也会成为影响协议的时间复杂度的重要因素。</p> \n <p>&nbsp;</p> \n <p>其次，在某些轮中，进程是要将某个消息发送到所有其他进程。比如，在第一轮协调者会向所有参与者发送VOTE-REQ消息。这种行为称为广播。为了广播一个消息，进程必须将同一消息的n个拷贝放到网络上，n代表接收者数目。通常来说，将消息放到网络上的时间与在网络上传输的时间相比要小很多。但是如果n足够大，那么为广播所进行的准备时间也会变得很大，需要考虑在内。</p> \n <p>&nbsp;</p> \n <p>因此，关于时间复杂度的更精确的衡量可能需要将总的轮数，访问可靠性存储的时间以及消息广播时间加起来。但是，后面的分析中我们还是会忽略后面两个因素，只关注轮数。</p> \n <p>&nbsp;</p> \n <p>我们通过协议所使用的消息总数来衡量消息复杂性。这也是合理的，因为消息本身并不长。但是如果它们很长的话，我们也是需要将长度考虑在内的，而不能仅仅考虑个数。在我们本章中所讨论的协议的消息都是很短的，因此我们还是只关注消息个数。</p> \n <p>&nbsp;</p> \n <p>现在我们来考察下2PC的resiliency，blocking，时间和消息复杂度。</p> \n <p><strong>Resiliency</strong>：2PC可以容忍节点故障和通信故障(无论是网络分区还是超时故障)。我们前面介绍的超时动作那部分的内容本身并未对超时产生的原因做任何假设， 通过这一点就可以得出该结论。超时可能是由节点故障，分区或者仅仅是因为伪超时导致的。</p> \n <p><strong>Blocking</strong>：2PC是会经历阻塞的。如果进程在不确定区间超时，同时可以进行通信的那些进程本身也是不确定的，那么进程就会被阻塞。实际上，即使是在只有节点故障的情况下，2PC仍然可能会被阻塞。如果要精确计算阻塞发生的概率，必需首先要知道故障发生的概率，同时这种类型的分析也超出了本书的范围。</p> \n <p><strong>时间复杂度</strong>：在没有故障发生的情况下，2PC需要三轮：(1)协调者广播VOTE-REQ消息；(2)参与者回复投票信息；(3)协调者广播最终决定结果。如果有故障发生，可能还要额外加上terminaion protocol需要的那两轮：第一轮用于超时的参与者发送DECISION-REQ请求，第二轮用于接收到消息的进程度过不确定区间后进行响应。可能会有多个参与者同时调用terminaion protocol。但是不同的调用可以重叠进行，因此合起来也还是只有两轮。</p> \n <p>因此，在有故障发生的情况下那些未被阻塞或没有发生故障的进程需要五轮才能达成决定。这与故障发生的个数无关。根据定义，一个被阻塞的进程可能会被阻塞无限长的时间。因此，为了得到有意义的结论，我们在考虑时间复杂度时需要将那些被阻塞的进程排除在外。</p> \n <p><strong>消息复杂度</strong>：令n代表参与者数目(因此总进程数就是n+1)。在2PC的每轮中，有n个消息被发送。因此在没有故障的情况下，协议将会使用3n个消息。</p> \n <p>cooperative terminaion protocol将会被那些投了Yes但是未收到来自协调者的COMMIT或ABORT消息的所有参与者调用。假设有m个这样的参与者。因此将会有m个进程初始化terminaion protocol的执行，每个发送n个DECISION-REQ消息。最多有n-m+1(未处于不确定状态的最大进程数)个进程会响应第一个DECISION-REQ消息。收到这些响应后，将会有一个新的进程从不确定状态退出，因此它会向另一个terminaion protocol执行实例发送响应消息。因此最坏情况下，由terminaion protocol发送的消息数将是：</p> \n <p>&nbsp;</p> \n <p>在n=m时该多项式取得最大值，也就是当所有参与者都在处于不确定区间时超时。因此，terminaion protocol贡献了多达n(3n+1)/2个消息，对于整个2PC协议来说就是n(3n+7)/2。</p> \n <p>&nbsp;</p> \n <p><strong>参考文献</strong></p> \n <p>&nbsp;</p> \n <p>http://stevens0102.blogbus.com/logs/43402056.html</p> \n <p>&nbsp;</p> \n <p><strong>附录</strong></p> \n <p>&nbsp;</p> \n <p><img alt=\"分布式事务之两阶段提交 - 星星 - 银河里的星星\" src=\"http://img4.ph.126.net/PVSy4oKpShNDLVpIe65NIg==/6597722876564055504.png\"></p> \n <p>&nbsp;</p> \n <p>左一Ken Thompson、左二Butler Lampson、右二Jim Gray, 右一Niklaus Wirth</p> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n <p><img alt=\"分布式事务之两阶段提交 - 星星 - 银河里的星星\" src=\"http://img3.ph.126.net/EeGCc7iuP63OCEOmbOOIQw==/6597704184866383453.png\"></p> \n <p>&nbsp;</p> \n <p>JimGray与它的同事Gianfranco Putzulo and Irving Traiger</p> \n</div>',NULL,'2020-02-02 19:26:31',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223931048778354688',NULL,NULL,' socket选项 SO_REUSEPORT  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h3_1\"></span> \n <h3>前言</h3> \n <span id=\"OSC_h3_2\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">本篇用于记录学习SO_REUSEPORT的笔记和心得，末尾还会提供一个bindp小工具也能为已有的程序享受这个新的特性。</p></h3> \n <span id=\"OSC_h3_3\"></span> \n <h3>当前Linux网络应用程序问题</h3> \n <span id=\"OSC_h3_4\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">运行在Linux系统上网络应用程序，为了利用多核的优势，一般使用以下比较典型的多进程/多线程服务器模型：</p> \n  <ol> \n   <li><p>单线程listen/accept，多个工作线程接收任务分发，虽CPU的工作负载不再是问题，但会存在：</p></li> \n   <ul> \n    <li><p>单线程listener，在处理高速率海量连接时，一样会成为瓶颈</p></li> \n    <li><p>CPU缓存行丢失套接字结构(socket structure)现象严重</p></li> \n   </ul> \n   <li><p>所有工作线程都accept()在同一个服务器套接字上呢，一样存在问题：</p></li> \n   <ul> \n    <li><p>多线程访问server socket锁竞争严重</p></li> \n    <li><p>高负载下，线程之间处理不均衡，有时高达3:1不均衡比例</p></li> \n    <li><p>导致CPU缓存行跳跃(cache line bouncing)</p></li> \n    <li><p>在繁忙CPU上存在较大延迟</p></li> \n   </ul> \n  </ol><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">上面模型虽然可以做到线程和CPU核绑定，但都会存在：</p> \n  <ul> \n   <li><p>单一listener工作线程在高速的连接接入处理时会成为瓶颈</p></li> \n   <li><p>缓存行跳跃</p></li> \n   <li><p>很难做到CPU之间的负载均衡</p></li> \n   <li><p>随着核数的扩展，性能并没有随着提升</p></li> \n  </ul><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">比如HTTP CPS(Connection Per Second)吞吐量并没有随着CPU核数增加呈现线性增长：&nbsp;</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">Linux kernel 3.9带来了SO_REUSEPORT特性，可以解决以上大部分问题。</p></h3> \n <span id=\"OSC_h3_5\"></span> \n <h3>SO_REUSEPORT解决了什么问题</h3> \n <span id=\"OSC_h3_6\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">linux man文档中一段文字描述其作用：</p> \n  <blockquote> \n   <p style=\"margin-bottom: 5px; background-color: inherit;\">The new socket option allows multiple sockets on the same host to bind to the same port, and is intended to improve the performance of multithreaded network server applications running on top of multicore systems.</p> \n  </blockquote><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">SO_REUSEPORT支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，解决的问题：</p> \n  <ul> \n   <li><p><span style=\"color:#ff0000;background-color: inherit;\">允许多个套接字 bind()/listen() 同一个TCP/UDP端口</span></p></li> \n   <ul> \n    <li><p><span style=\"color:#ff0000;background-color: inherit;\">每一个线程拥有自己的服务器套接字</span></p></li> \n    <li><p><span style=\"color:#ff0000;background-color: inherit;\">在服务器套接字上没有了锁的竞争</span></p></li> \n   </ul> \n   <li><p><span style=\"color:#ff0000;background-color: inherit;\">内核层面实现负载均衡</span></p></li> \n   <li><p>安全层面，监听同一个端口的套接字只能位于同一个用户下面</p></li> \n  </ul><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">其核心的实现主要有三点：</p> \n  <ul> \n   <li><p>扩展 socket option，增加 SO_REUSEPORT 选项，用来设置 reuseport。</p></li> \n   <li><p>修改 bind 系统调用实现，以便支持可以绑定到相同的 IP 和端口</p></li> \n   <li><p>修改处理新建连接的实现，查找 listener 的时候，能够支持在监听相同 IP 和端口的多个 sock 之间均衡选择。</p></li> \n  </ul><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">代码分析，可以参考引用资料 [多个进程绑定相同端口的实现分析[Google Patch]]。</p></h3> \n <span id=\"OSC_h4_7\"></span> \n <h4>CPU之间平衡处理，水平扩展</h4> \n <span id=\"OSC_h3_8\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">以前通过<code>fork</code>形式创建多个子进程，现在有了SO_REUSEPORT，可以不用通过<code>fork</code>的形式，让多进程监听同一个端口，各个进程中<code>accept socket fd</code>不一样，有新连接建立时，内核只会唤醒一个进程来<code>accept</code>，并且保证唤醒的均衡性。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">模型简单，维护方便了，进程的管理和应用逻辑解耦，进程的管理水平扩展权限下放给程序员/管理员，可以根据实际进行控制进程启动/关闭，增加了灵活性。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">这带来了一个较为微观的水平扩展思路，线程多少是否合适，状态是否存在共享，降低单个进程的资源依赖，针对无状态的服务器架构最为适合了。</p></h3> \n <span id=\"OSC_h4_9\"></span> \n <h4>新特性测试或多个版本共存</h4> \n <span id=\"OSC_h3_10\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">可以很方便的测试新特性，同一个程序，不同版本同时运行中，根据运行结果决定新老版本更迭与否。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">针对对客户端而言，表面上感受不到其变动，因为这些工作完全在服务器端进行。</p></h3> \n <span id=\"OSC_h4_11\"></span> \n <h4>服务器无缝重启/切换</h4> \n <span id=\"OSC_h3_12\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">想法是，我们迭代了一版本，需要部署到线上，为之启动一个新的进程后，稍后关闭旧版本进程程序，服务一直在运行中不间断，需要平衡过度。这就像Erlang语言层面所提供的热更新一样。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">想法不错，但是实际操作起来，就不是那么平滑了，还好有一个<a href=\"https://github.com/amscanne/huptime\" rel=\"nofollow\">hubtime</a>开源工具，原理为<code>SIGHUP信号处理器+SO_REUSEPORT+LD_RELOAD</code>，可以帮助我们轻松做到，有需要的同学可以检出试用一下。</p></h3> \n <span id=\"OSC_h3_13\"></span> \n <h3>SO_REUSEPORT已知问题</h3> \n <span id=\"OSC_h3_14\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">SO_REUSEPORT根据数据包的四元组{src ip, src port, dst ip, dst port}和当前绑定同一个端口的服务器套接字数量进行数据包分发。若服务器套接字数量产生变化，内核会把本该上一个服务器套接字所处理的客户端连接所发送的数据包（比如三次握手期间的半连接，以及已经完成握手但在队列中排队的连接）分发到其它的服务器套接字上面，可能会导致客户端请求失败，一般可以使用：</p> \n  <ul> \n   <li><p>使用固定的服务器套接字数量，不要在负载繁忙期间轻易变化</p></li> \n   <li><p>允许多个服务器套接字共享TCP请求表(Tcp request table)</p></li> \n   <li><p>不使用四元组作为Hash值进行选择本地套接字处理，挑选隶属于同一个CPU的套接字</p></li> \n  </ul><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">与RFS/RPS/XPS-mq协作，可以获得进一步的性能：</p> \n  <ul> \n   <li><p>服务器线程绑定到CPUs</p></li> \n   <li><p>RPS分发TCP SYN包到对应CPU核上</p></li> \n   <li><p>TCP连接被已绑定到CPU上的线程accept()</p></li> \n   <li><p>XPS-mq(Transmit Packet Steering for multiqueue)，传输队列和CPU绑定，发送数据</p></li> \n   <li><p>RFS/RPS保证同一个连接后续数据包都会被分发到同一个CPU上</p></li> \n   <li><p>网卡接收队列已经绑定到CPU，则RFS/RPS则无须设置</p></li> \n   <li><p>需要注意硬件支持与否</p></li> \n  </ul><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">目的嘛，数据包的软硬中断、接收、处理等在一个CPU核上，并行化处理，尽可能做到资源利用最大化。</p></h3> \n <span id=\"OSC_h4_15\"></span> \n <h4>SO_REUSEPORT不是一贴万能膏药</h4> \n <span id=\"OSC_h3_16\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">虽然SO_REUSEPORT解决了多个进程共同绑定/监听同一端口的问题，但根据新浪林晓峰同学测试结果来看，在多核扩展层面也未能够做到理想的线性扩展：</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">可以参考Fastsocket在其基础之上的改进，<a href=\"http://www.blogjava.net/yongboy/archive/2015/02/05/422760.html\" rel=\"nofollow\">链接地址</a>。</p></h3> \n <span id=\"OSC_h3_17\"></span> \n <h3>支持SO_REUSEPORT的Tengine</h3> \n <span id=\"OSC_h3_18\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">淘宝的Tengine已经支持了SO_REUSEPORT特性，在其测试报告中，有一个简单测试，可以看出来相对比SO_REUSEPORT所带来的性能提升：</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">使用SO_REUSEPORT以后，最明显的效果是在压力下不容易出现丢请求的情况，CPU均衡性平稳。</p></h3> \n <span id=\"OSC_h3_19\"></span> \n <h3>Java支持否？</h3> \n <span id=\"OSC_h3_20\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">JDK 1.6语言层面不支持，至于以后的版本，由于暂时没有使用到，不多说。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">Netty 3/4版本默认都不支持SO_REUSEPORT特性，但Netty 4.0.19以及之后版本才真正提供了JNI方式单独包装的epoll native transport版本（在Linux系统下运行），可以配置类似于SO_REUSEPORT等（JAVA NIIO没有提供）选项，这部分是在<code>io.netty.channel.epoll.EpollChannelOption</code>中定义（<a href=\"http://grepcode.com/file/repo1.maven.org/maven2/io.netty/netty-transport-native-epoll/4.0.19.Final/io/netty/channel/epoll/EpollChannelOption.java\" rel=\"nofollow\">在线代码部分</a>）。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">在linux环境下使用epoll native transport，可以获得内核层面网络堆栈增强的红利，如何使用可参考<a href=\"http://netty.io/wiki/native-transports.html\" rel=\"nofollow\">Native transports</a>文档。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">使用epoll native transport倒也简单，类名稍作替换：</p><pre><code>NioEventLoopGroup&nbsp;→&nbsp;EpollEventLoopGroup\nNioEventLoop&nbsp;→&nbsp;EpollEventLoop\nNioServerSocketChannel&nbsp;→&nbsp;EpollServerSocketChannel\nNioSocketChannel&nbsp;→&nbsp;EpollSocketChannel</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">比如写一个PING-PONG应用服务器程序，类似代码：</p><pre><code>public&nbsp;void&nbsp;run()&nbsp;throws&nbsp;Exception&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;EventLoopGroup&nbsp;bossGroup&nbsp;=&nbsp;new&nbsp;EpollEventLoopGroup();\n&nbsp;&nbsp;&nbsp;&nbsp;EventLoopGroup&nbsp;workerGroup&nbsp;=&nbsp;new&nbsp;EpollEventLoopGroup();\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerBootstrap&nbsp;b&nbsp;=&nbsp;new&nbsp;ServerBootstrap();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelFuture&nbsp;f&nbsp;=&nbsp;b\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.group(bossGroup,&nbsp;workerGroup)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.channel(EpollServerSocketChannel.class)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.childHandler(new&nbsp;ChannelInitializer&lt;SocketChannel&gt;()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;initChannel(SocketChannel&nbsp;ch)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;Exception&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch.pipeline().addLast(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;StringDecoder(CharsetUtil.UTF_8),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;StringEncoder(CharsetUtil.UTF_8),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;PingPongServerHandler());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).option(ChannelOption.SO_REUSEADDR,&nbsp;true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.option(EpollChannelOption.SO_REUSEPORT,&nbsp;true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.childOption(ChannelOption.SO_KEEPALIVE,&nbsp;true).bind(port)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.sync();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.channel().closeFuture().sync();\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workerGroup.shutdownGracefully();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bossGroup.shutdownGracefully();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">若不要这么折腾，还想让以往Java/Netty应用程序在不做任何改动的前提下顺利在Linux kernel &gt;= 3.9下同样享受到SO_REUSEPORT带来的好处，不妨尝试一下<a href=\"https://github.com/yongboy/bindp\" rel=\"nofollow\">bindp</a>，更为经济，这一部分下面会讲到。</p></h3> \n <span id=\"OSC_h3_21\"></span> \n <h3>bindp，为已有应用添加SO_REUSEPORT特性</h3> \n <span id=\"OSC_h3_22\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">以前所写<a href=\"https://github.com/yongboy/bindp\" rel=\"nofollow\">bindp</a>小程序，可以为已有程序绑定指定的IP地址和端口，一方面可以省去硬编码，另一方面也为测试提供了一些方便。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">另外，为了让以前没有硬编码<code>SO_REUSEPORT</code>的应用程序可以在Linux内核3.9以及之后Linux系统上也能够得到内核增强支持，稍做修改，添加支持。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">但要求如下：</p> \n  <ol> \n   <li><p><span style=\"color:#ff0000;background-color: inherit;\">Linux内核(&gt;= 3.9)支持SO_REUSEPORT特性</span></p></li> \n   <li><p>需要配置<code>REUSE_PORT=1</code></p></li> \n  </ol><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">不满足以上条件，此特性将无法生效。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">使用示范：</p><pre><code>REUSE_PORT=1&nbsp;BIND_PORT=9999&nbsp;LD_PRELOAD=./libbindp.so&nbsp;java&nbsp;-server&nbsp;-jar&nbsp;pingpongserver.jar&nbsp;&amp;</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">当然，你可以根据需要运行命令多次，多个进程监听同一个端口，单机进程水平扩展。</p></h3> \n <span id=\"OSC_h4_23\"></span> \n <h4>使用示范</h4> \n <span id=\"OSC_h3_24\"></span> \n <h3><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">使用python脚本快速构建一个小的示范原型，两个进程，都监听同一个端口10000，客户端请求返回不同内容，仅供娱乐。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">server_v1.py，简单PING-PONG：</p><pre><code>#&nbsp;-*-&nbsp;coding:UTF-8&nbsp;-*-\n\nimport&nbsp;socket\nimport&nbsp;os\n\nPORT&nbsp;=&nbsp;10000\nBUFSIZE&nbsp;=&nbsp;1024\n\ns&nbsp;=&nbsp;socket.socket(socket.AF_INET,&nbsp;socket.SOCK_STREAM)\ns.bind((\'\',&nbsp;PORT))\ns.listen(1)\n\nwhile&nbsp;True:\n&nbsp;&nbsp;&nbsp;&nbsp;conn,&nbsp;addr&nbsp;=&nbsp;s.accept()\n&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;conn.recv(PORT)\n&nbsp;&nbsp;&nbsp;&nbsp;conn.send(\'Connected&nbsp;to&nbsp;server[%s]&nbsp;from&nbsp;client[%s]\\n\'&nbsp;%&nbsp;(os.getpid(),&nbsp;addr))\n&nbsp;&nbsp;&nbsp;&nbsp;conn.close()\n\ns.close()</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">server_v2.py，输出当前时间：</p><pre><code>#&nbsp;-*-&nbsp;coding:UTF-8&nbsp;-*-\n\nimport&nbsp;socket\nimport&nbsp;time\nimport&nbsp;os\n\nPORT&nbsp;=&nbsp;10000\nBUFSIZE&nbsp;=&nbsp;1024\n\ns&nbsp;=&nbsp;socket.socket(socket.AF_INET,&nbsp;socket.SOCK_STREAM)\ns.bind((\'\',&nbsp;PORT))\ns.listen(1)\n\nwhile&nbsp;True:\n&nbsp;&nbsp;&nbsp;&nbsp;conn,&nbsp;addr&nbsp;=&nbsp;s.accept()\n&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;conn.recv(PORT)\n&nbsp;&nbsp;&nbsp;&nbsp;conn.send(\'server[%s]&nbsp;time&nbsp;%s\\n\'&nbsp;%&nbsp;(os.getpid(),&nbsp;time.ctime()))\n&nbsp;&nbsp;&nbsp;&nbsp;conn.close()\n\ns.close()</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">借助于bindp运行两个版本的程序：</p><pre><code>REUSE_PORT=1&nbsp;LD_PRELOAD=/opt/bindp/libindp.so&nbsp;python&nbsp;server_v1.py&nbsp;&amp;\nREUSE_PORT=1&nbsp;LD_PRELOAD=/opt/bindp/libindp.so&nbsp;python&nbsp;server_v2.py&nbsp;&amp;</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">模拟客户端请求10次：</p><pre><code>for&nbsp;i&nbsp;in&nbsp;{1..10};do&nbsp;echo&nbsp;\"hello\"&nbsp;|&nbsp;nc&nbsp;127.0.0.1&nbsp;10000;done</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">看看结果吧：</p><pre><code>Connected&nbsp;to&nbsp;server[3139]&nbsp;from&nbsp;client[(\'127.0.0.1\',&nbsp;48858)]\nserver[3140]&nbsp;time&nbsp;Thu&nbsp;Feb&nbsp;12&nbsp;16:39:12&nbsp;2015\nserver[3140]&nbsp;time&nbsp;Thu&nbsp;Feb&nbsp;12&nbsp;16:39:12&nbsp;2015\nserver[3140]&nbsp;time&nbsp;Thu&nbsp;Feb&nbsp;12&nbsp;16:39:12&nbsp;2015\nConnected&nbsp;to&nbsp;server[3139]&nbsp;from&nbsp;client[(\'127.0.0.1\',&nbsp;48862)]\nserver[3140]&nbsp;time&nbsp;Thu&nbsp;Feb&nbsp;12&nbsp;16:39:12&nbsp;2015\nConnected&nbsp;to&nbsp;server[3139]&nbsp;from&nbsp;client[(\'127.0.0.1\',&nbsp;48864)]\nserver[3140]&nbsp;time&nbsp;Thu&nbsp;Feb&nbsp;12&nbsp;16:39:12&nbsp;2015\nConnected&nbsp;to&nbsp;server[3139]&nbsp;from&nbsp;client[(\'127.0.0.1\',&nbsp;48866)]\nConnected&nbsp;to&nbsp;server[3139]&nbsp;from&nbsp;client[(\'127.0.0.1\',&nbsp;48867)]</code></pre><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">可以看出来，CPU分配很均衡，各自分配50%的请求量。</p><p style=\"margin-bottom: 5px; font-size: 13.3333330154419px; font-weight: normal;\">嗯，虽是小玩具，有些意思 :))</p></h3> \n <h3><br></h3> \n <h3><br></h3> \n <span id=\"OSC_h3_25\"></span> \n <h3>SO_REUSADDR VS SO_REUSEPORT</h3> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">因为能力有限，还是有很多东西（SO_REUSEADDR和SO_REUSEPORT的区别等）没有能够在一篇文字中表达清楚，作为补遗，也方便以后自己回过头来复习。</p> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">两者不是一码事，没有可比性。有时也会被其搞晕，自己总结的不好，推荐StackOverflow的<a href=\"http://stackoverflow.com/questions/14388706/socket-options-so-reuseaddr-and-so-reuseport-how-do-they-differ-do-they-mean-t/14388707\" rel=\"nofollow\">Socket options SO_REUSEADDR and SO_REUSEPORT, how do they differ?</a>资料，总结的很全面。</p> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">简单来说：</p> \n <ul> \n  <li><p>设置了SO_REUSADDR的应用可以避免TCP 的 TIME_WAIT 状态 时间过长无法复用端口，尤其表现在应用程序关闭-重启交替的瞬间</p></li> \n  <li><p>SO_REUSEPORT更强大，隶属于同一个用户（防止端口劫持）的多个进程/线程共享一个端口，<span style=\"color:#ff0000;background-color: inherit;\">同时在内核层面替上层应用做数据包进程/线程的处理均衡</span></p></li> \n </ul> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">若有困惑，推荐两者都设置，不会有冲突。</p> \n <span id=\"OSC_h3_26\"></span> \n <h3>Netty多线程使用SO_REUSEPORT</h3> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">上一篇讲到SO_REUSEPORT，多个程绑定同一个端口，可以根据需要控制进程的数量。这里讲讲基于<code>Netty 4.0.25+Epoll navtie transport</code>在单个进程内多个线程绑定同一个端口的情况，也是比较实用的。</p> \n <span id=\"OSC_h4_27\"></span> \n <h4>TCP服务器，同一个进程多线程绑定同一个端口</h4> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">这是一个PING-PONG示范应用：</p> \n <pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;throws&nbsp;Exception&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;EventLoopGroup&nbsp;bossGroup&nbsp;=&nbsp;new&nbsp;EpollEventLoopGroup();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;EventLoopGroup&nbsp;workerGroup&nbsp;=&nbsp;new&nbsp;EpollEventLoopGroup();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerBootstrap&nbsp;b&nbsp;=&nbsp;new&nbsp;ServerBootstrap();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.group(bossGroup,&nbsp;workerGroup)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.channel(EpollServerSocketChannel.&nbsp;class)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.childHandler(&nbsp;new&nbsp;ChannelInitializer&lt;SocketChannel&gt;()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;initChannel(SocketChannel&nbsp;ch)&nbsp;throws&nbsp;Exception&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch.pipeline().addLast(\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;StringDecoder(CharsetUtil.UTF_8&nbsp;),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;StringEncoder(CharsetUtil.UTF_8&nbsp;),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;PingPongServerHandler());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).option(ChannelOption.&nbsp;SO_REUSEADDR,&nbsp;true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.option(EpollChannelOption.&nbsp;SO_REUSEPORT,&nbsp;true)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.childOption(ChannelOption.&nbsp;SO_KEEPALIVE,&nbsp;true);\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;workerThreads&nbsp;=&nbsp;Runtime.getRuntime().availableProcessors();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelFuture&nbsp;future;</code></pre> \n <p></p> \n <pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//new&nbsp;&nbsp;thread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;workerThreads;&nbsp;++i)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;future&nbsp;=&nbsp;b.bind(&nbsp;port).await();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!future.isSuccess())\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(String.&nbsp;format(\"fail&nbsp;to&nbsp;bind&nbsp;on&nbsp;port&nbsp;=&nbsp;%d.\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port),&nbsp;future.cause());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runtime.&nbsp;getRuntime().addShutdownHook&nbsp;(new&nbsp;Thread(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run(){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workerGroup.shutdownGracefully();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bossGroup.shutdownGracefully();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code></pre> \n <p></p> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">打成jar包，在CentOS 7下面运行，检查同一个端口所打开的文件句柄。</p> \n <pre><code>#&nbsp;lsof&nbsp;-i:8000\nCOMMAND&nbsp;&nbsp;PID&nbsp;USER&nbsp;&nbsp;&nbsp;FD&nbsp;&nbsp;&nbsp;TYPE&nbsp;DEVICE&nbsp;SIZE/OFF&nbsp;NODE&nbsp;NAME\njava&nbsp;&nbsp;&nbsp;&nbsp;3515&nbsp;root&nbsp;&nbsp;&nbsp;42u&nbsp;&nbsp;IPv6&nbsp;&nbsp;29040&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;TCP&nbsp;*:irdmi&nbsp;(LISTEN)\njava&nbsp;&nbsp;&nbsp;&nbsp;3515&nbsp;root&nbsp;&nbsp;&nbsp;43u&nbsp;&nbsp;IPv6&nbsp;&nbsp;29087&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;TCP&nbsp;*:irdmi&nbsp;(LISTEN)\njava&nbsp;&nbsp;&nbsp;&nbsp;3515&nbsp;root&nbsp;&nbsp;&nbsp;44u&nbsp;&nbsp;IPv6&nbsp;&nbsp;29088&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;TCP&nbsp;*:irdmi&nbsp;(LISTEN)\njava&nbsp;&nbsp;&nbsp;&nbsp;3515&nbsp;root&nbsp;&nbsp;&nbsp;45u&nbsp;&nbsp;IPv6&nbsp;&nbsp;29089&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;TCP&nbsp;*:irdmi&nbsp;(LISTEN)</code></pre> \n <p></p> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">同一进程，但打开的文件句柄是不一样的。</p> \n <span id=\"OSC_h4_28\"></span> \n <h4>UDP服务器，多个线程绑同一个端口</h4> \n <pre><code>/**\n&nbsp;*&nbsp;UDP谚语服务器，单进程多线程绑定同一端口示范\n&nbsp;*/\npublic&nbsp;final&nbsp;class&nbsp;QuoteOfTheMomentServer&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;int&nbsp;PORT&nbsp;=&nbsp;Integer.parseInt(System.&nbsp;getProperty(\"port\"&nbsp;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"9000\"&nbsp;));\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;EventLoopGroup&nbsp;group&nbsp;=&nbsp;new&nbsp;EpollEventLoopGroup();\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bootstrap&nbsp;b&nbsp;=&nbsp;new&nbsp;Bootstrap();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.group(group).channel(EpollDatagramChannel.&nbsp;class)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.option(EpollChannelOption.&nbsp;SO_REUSEPORT,&nbsp;true&nbsp;)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.handler(&nbsp;new&nbsp;QuoteOfTheMomentServerHandler());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;workerThreads&nbsp;=&nbsp;Runtime.getRuntime().availableProcessors();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;workerThreads;&nbsp;++i)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ChannelFuture&nbsp;future&nbsp;=&nbsp;b.bind(&nbsp;PORT).await();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!future.isSuccess())\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;Exception(String.format&nbsp;(\"Fail&nbsp;to&nbsp;bind&nbsp;on&nbsp;port&nbsp;=&nbsp;%d.\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PORT),&nbsp;future.cause());\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runtime.&nbsp;getRuntime().addShutdownHook(new&nbsp;Thread()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group.shutdownGracefully();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n}\n\n@Sharable\nclass&nbsp;QuoteOfTheMomentServerHandler&nbsp;extends\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleChannelInboundHandler&lt;DatagramPacket&gt;&nbsp;{\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;String[]&nbsp;quotes&nbsp;=&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Where&nbsp;there&nbsp;is&nbsp;love&nbsp;there&nbsp;is&nbsp;life.\"&nbsp;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"First&nbsp;they&nbsp;ignore&nbsp;you,&nbsp;then&nbsp;they&nbsp;laugh&nbsp;at&nbsp;you,&nbsp;then&nbsp;they&nbsp;fight&nbsp;you,&nbsp;then&nbsp;you&nbsp;win.\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"Be&nbsp;the&nbsp;change&nbsp;you&nbsp;want&nbsp;to&nbsp;see&nbsp;in&nbsp;the&nbsp;world.\"&nbsp;,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"The&nbsp;weak&nbsp;can&nbsp;never&nbsp;forgive.&nbsp;Forgiveness&nbsp;is&nbsp;the&nbsp;attribute&nbsp;of&nbsp;the&nbsp;strong.\",&nbsp;};\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;String&nbsp;nextQuote()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;quoteId&nbsp;=&nbsp;ThreadLocalRandom.current().nextInt(&nbsp;quotes&nbsp;.length&nbsp;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;quotes&nbsp;[quoteId];\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;channelRead0(ChannelHandlerContext&nbsp;ctx,&nbsp;DatagramPacket&nbsp;packet)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;Exception&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(\"QOTM?\"&nbsp;.equals(packet.content().toString(CharsetUtil.&nbsp;UTF_8)))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.write(&nbsp;new&nbsp;DatagramPacket(Unpooled.copiedBuffer(&nbsp;\"QOTM:&nbsp;\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;nextQuote(),&nbsp;CharsetUtil.&nbsp;UTF_8),&nbsp;packet.sender()));\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;channelReadComplete(ChannelHandlerContext&nbsp;ctx)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctx.flush();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;exceptionCaught(ChannelHandlerContext&nbsp;ctx,&nbsp;Throwable&nbsp;cause)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cause.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n}</code></pre> \n <p></p> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">同样也要检测一下端口文件句柄打开情况：</p> \n <pre><code>#&nbsp;lsof&nbsp;-i:9000\nCOMMAND&nbsp;&nbsp;PID&nbsp;USER&nbsp;&nbsp;&nbsp;FD&nbsp;&nbsp;&nbsp;TYPE&nbsp;DEVICE&nbsp;SIZE/OFF&nbsp;NODE&nbsp;NAME\njava&nbsp;&nbsp;&nbsp;&nbsp;3181&nbsp;root&nbsp;&nbsp;&nbsp;26u&nbsp;&nbsp;IPv6&nbsp;&nbsp;27188&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;UDP&nbsp;*:cslistener\njava&nbsp;&nbsp;&nbsp;&nbsp;3181&nbsp;root&nbsp;&nbsp;&nbsp;27u&nbsp;&nbsp;IPv6&nbsp;&nbsp;27217&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;UDP&nbsp;*:cslistener\njava&nbsp;&nbsp;&nbsp;&nbsp;3181&nbsp;root&nbsp;&nbsp;&nbsp;28u&nbsp;&nbsp;IPv6&nbsp;&nbsp;27218&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;UDP&nbsp;*:cslistener\njava&nbsp;&nbsp;&nbsp;&nbsp;3181&nbsp;root&nbsp;&nbsp;&nbsp;29u&nbsp;&nbsp;IPv6&nbsp;&nbsp;27219&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0t0&nbsp;&nbsp;UDP&nbsp;*:cslistener</code></pre> \n <p></p> \n <span id=\"OSC_h3_29\"></span> \n <h3>小结</h3> \n <p style=\"margin-bottom: 5px; white-space: normal; widows: auto; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 13.3333330154419px; line-height: 1.53846153846154; background-color: rgb(255, 255, 255);\">以上为Netty+SO_REUSEPORT多线程绑定同一端口的一些情况，是为记载。</p> \n <p><br></p> \n</div>',NULL,'2020-02-02 19:27:56',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223931405843648512',NULL,NULL,' setsockopt中参数之SO_REUSEADDR的意义  ','<div class=\"content\" id=\"articleContent\"> \n <div> \n  <div> \n   <p> <span style=\"font-family:;\"><span><span>1、</span></span></span><span><span style=\"font-family:;\"><span>一般来说</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>一个端口释放后会等待两分钟之后才能再被使用</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>SO_REUSEADDR</span></span><span><span>是让端口释放后立即就可以被再次使用。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>SO_REUSEADDR</span><span>用于对</span><span>TCP</span><span>套接字处于</span><span>TIME_WAIT</span><span>状态下的</span><span>socket</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>才可以重复绑定使用。server</span><span>程序总是应该在调用</span><span>bind()</span><span>之前设置</span><span>SO_REUSEADDR</span><span>套接字选项。</span></span><span style=\"font-family:;\"><span>TCP，</span></span></span><span style=\"font-family:;\"><span><span>先调用close()</span><span>的一方会进入</span><span>TIME_WAIT</span></span><span><span>状态</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>2、</span></span></span><span style=\"font-family:;\"><span><span>SO_REUSEADDR</span><span>和</span></span><span><span>SO_REUSEPORT</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><strong><span><span>SO_REUSEADDR</span></span><span><span>提供如下四个功能：</span></span></strong></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>SO_REUSEADDR</span><span>允许启动一个监听服务器并捆绑其众所周知端口</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>若不设置此选项</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>则bind</span></span><span><span>时将出错。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>SO_REUSEADDR</span><span>允许在同一端口上启动同一服务器的多个实例</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>只要每个实例捆绑一个不同的本地IP</span><span>地址即可。对于</span><span>TCP</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>我们根本不可能启动捆绑相同IP</span></span><span><span>地址和相同端口号的多个服务器。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>SO_REUSEADDR</span><span>允许单个进程捆绑同一端口到多个套接口上</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>只要每个捆绑指定不同的本地IP</span><span>地址即可。这一般不用于</span><span>TCP</span></span><span><span>服务器。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>SO_REUSEADDR</span><span>允许完全重复的捆绑：当一个</span><span>IP</span><span>地址和端口绑定到某个套接口上时</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>还允许此IP</span><span>地址和端口捆绑到另一个套接口上。一般来说</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>这个特性仅在支持多播的系统上才有</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>而且只对UDP</span><span>套接口而言（</span><span>TCP</span></span><span><span>不支持多播）。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><strong><span><span>SO_REUSEPORT</span></span><span><span>选项有如下语义：</span></span></strong></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>此选项允许完全重复捆绑</span></span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>但仅在想捆绑相同IP</span><span>地址和端口的套接口都指定了此套接口选项才</span></span><span style=\"font-family:;\"><span>行</span></span></span><span style=\"font-family:;\"><span><span>。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>如果被捆绑的IP</span><span>地址是一个多播地址</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>则SO_REUSEADDR</span><span>和</span><span>SO_REUSEPORT</span></span><span><span>等效。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span><strong>使用这两个套接口选项的建议：</strong></span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <u><span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>在所有TCP</span><span>服务器中</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>在调用bind</span><span>之前设置</span><span>SO_REUSEADDR</span></span><span><span>套接口选项；</span></span></span></u><span style=\"font-family:;\"></span> </p> \n   <p> <u><span style=\"font-family:;\"><span><span>当编写一个同一时刻在同一主机上可运行多次的多播应用程序时</span></span></span><span><span style=\"font-family:;\"><span>，</span></span><span style=\"font-family:;\"><span>设置SO_REUSEADDR</span><span>选项</span></span><span style=\"font-family:;\"><span>，</span></span></span><span style=\"font-family:;\"><span><span>并将本组的多播地址作为本地IP</span></span><span><span>地址捆绑。</span></span></span></u><span style=\"font-family:;\"></span> </p> \n   <p> <span><strong><span style=\"font-family:;\"><span>&nbsp;&nbsp;&nbsp; if (setsockopt(</span></span><span><span style=\"font-family:;\">fd</span></span><span style=\"font-family:;\"><span>, SOL_SOCKET, SO_REUSEADDR, </span></span></strong></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"></span><span style=\"font-family:;\"></span><span><strong><span style=\"font-family:;\"><span>&nbsp;&nbsp; (const void *)&amp;nOptval , sizeof(int)) &lt; 0)</span></span><span style=\"font-family:;\"><span> ...</span></span></strong></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span><strong>附</strong></span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span style=\"font-family:;\"><span><span>Q:编写 </span><span>TCP/SOCK_STREAM </span><span>服务程序时，</span><span>SO_REUSEADDR</span></span><span><span>到底什么意思？</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span style=\"font-family:;\"><span><span>A:这个套接字选项通知内核，如果端口忙，但</span><span>TCP</span><span>状态位于 </span><span>TIME_WAIT </span><span>，可以重用端口。如果端口忙，而</span><span>TCP</span><span>状态位于其他状态，重用端口时依旧得到一个错误信息，指明</span><span>\"</span><span>地址已经使用中</span><span>\"</span><span>。如果你的服务程序停止后想立即重启，而新套接字依旧使用同一端口，此时</span><span>SO_REUSEADDR </span></span><span><span>选项非常有用。必须意识到，此时任何非期望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>&nbsp;&nbsp;&nbsp; </span></span></span><span><span style=\"font-family:;\"><span>一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。</span><span>SO_REUSEADDR </span><span>仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用 </span><span>SO_REUSEADDR </span><span>选项。【</span></span></span><span><span><span style=\"font-family:;\">2</span></span><span style=\"font-family:;\"><span>】</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>【</span></span><span><span>1</span><span>】 </span></span></span><span><a href=\"http://topic.csdn.net/u/20090103/16/a0414edb-b289-4c72-84da-39e155e8f4be.html\" rel=\"nofollow\"><span style=\"font-family:;\"><span><span>http://topic.csdn.net/u/20090103/16/a0414edb-b289-4c72-84da-39e155e8f4be.html</span></span></span></a></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>【</span></span><span><span>2</span></span><span><span>】</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>以下博客对这个问题进行了对答式的解答：</span></span></span><span style=\"font-family:;\"></span> </p> \n   <p> <span><a href=\"http://blog.sina.com.cn/s/blog_53a2ecbf010095db.html\" rel=\"nofollow\"><span style=\"font-family:;\"><span><span>http://blog.sina.com.cn/s/blog_53a2ecbf010095db.html</span></span></span></a></span><span style=\"font-family:;\"></span> </p> \n   <p> <span style=\"font-family:;\"><span><span>【</span></span><span><span>3</span><span>】 </span></span></span><span><a href=\"http://www.sudu.cn/info/html/edu/20050101/296180.html\" rel=\"nofollow\"><span style=\"font-family:;\"><span><span>http://www.sudu.cn/info/html/edu/20050101/296180.html</span></span></span></a></span> </p> \n  </div> \n </div> \n</div>',NULL,'2020-02-02 19:29:21',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223931768458006528',NULL,NULL,' Mybatis 缓存学习  ','<div class=\"content\" id=\"articleContent\"> \n <p><br></p> \n <span id=\"OSC_h3_1\"></span> \n <h3>引用</h3> \n <p><span style=\"color: rgb(62, 62, 62); font-family: \'Helvetica Neue\', Helvetica, \'Hiragino Sans GB\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 15px; line-height: 22px; background-color: rgb(255, 255, 255);\">缓存就是存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。</span></p> \n <p><span style=\"color: rgb(62, 62, 62); font-family: \'Helvetica Neue\', Helvetica, \'Hiragino Sans GB\', \'Microsoft YaHei\', Arial, sans-serif; font-size: 15px; line-height: 22px; background-color: rgb(255, 255, 255);\"><br></span></p> \n <span id=\"OSC_h3_2\"></span> \n <h3>1、一级缓存与二级缓存的差异</h3> \n <p>1）二级缓存默认关闭，一级缓存默认开启，二级缓存以Mapper的namespace为单位，但是一级缓存以sqlsession为单位，如果采用Spring管理对象，那么每次一个事务就会有一个sqlsession。</p> \n <p>2）二级缓存的读取都采用了锁控制并发，但是一级缓存并没有，而且Mybatis强调了sqlsession不应该多线程共享，看到这里确实是有道理的，第一个是sqlsession关闭了在使用会报错，其二是读写缓存数据都没有加锁；然而，二级缓存虽然是建立在一级缓存之上，但是二级缓存采用了SynchronizedCache缓存，对数据的读写都进行了加锁，整个二级缓存就是一个责任链模式，从&nbsp;SynchronizedCache(读写加锁)——&gt;LoggingCache（命中率记录）——&gt;SerializedCache（缓存值序列化、反序列化）——&gt;LruCache（移除无用缓存）——&gt;PerpetualCache（一级缓存，缓存数据的存储）；</p> \n <p>3）二级缓存采用的Executor是BaseExecutor；二级缓存采用的Executor是CachingExecutor（内部委托BaseExecutor进行数据库操作）；</p> \n <p><br></p> \n <span id=\"OSC_h3_3\"></span> \n <h3>2、一级缓存代码</h3> \n <pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cachedList&nbsp;!=&nbsp;null)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;=&nbsp;cachedList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;=&nbsp;doQuery(ms,&nbsp;parameter,&nbsp;rowBounds,&nbsp;resultHandler);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localCache.removeObject(key);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localCache.putObject(key,&nbsp;list);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queryStack--;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(queryStack&nbsp;==&nbsp;0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(DeferredLoad&nbsp;deferredLoad&nbsp;:&nbsp;deferredLoads)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deferredLoad.load();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;list;\n&nbsp;&nbsp;}</code></pre> \n <p><br></p> \n <span id=\"OSC_h3_4\"></span> \n <h3>3、一级缓存的理解</h3> \n <p>所谓一级缓存，就是在一次会话当中，有可能重复执行完全相同的查询语句，为了避免数据库的压力，所以采用缓存的方式，第一次查询的数据放在缓存，第二次直接从缓存中获取数据，注意Java返回的是对象的引用，缓存的也是对象的引用，所以这个对象是可write的。PerpetualCache 就是一级缓存的实现。</p> \n <p>一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念,对于一些隔离级别低的数据库，比如一个事务在查询数据时，另一个事务还可以进行对数据库操作，那么导致前者读出的数据其实是过时数据，那么这个时候的缓存就是有问题的，比如数据库隔离级别是 Read Committed ， 那么两次读取的数据可能是不一致的（不可重复读），可是由于缓存将会导致每次得到的数据都是一致的。</p> \n <p><br></p> \n <span id=\"OSC_h3_5\"></span> \n <h3>4、二级缓存代码</h3> \n <pre><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cache&nbsp;!=&nbsp;null)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flushCacheIfRequired(ms);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ms.isUseCache())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CacheKey&nbsp;key&nbsp;=&nbsp;createCacheKey(ms,&nbsp;parameterObject,&nbsp;rowBounds);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;List&nbsp;cachedList&nbsp;=&nbsp;(List)&nbsp;cache.getObject(key);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cachedList&nbsp;!=&nbsp;null)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cachedList;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;list&nbsp;=&nbsp;delegate.query(ms,&nbsp;parameterObject,&nbsp;rowBounds,&nbsp;resultHandler);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tcm.putObject(cache,&nbsp;key,&nbsp;list);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;list;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;delegate.query(ms,&nbsp;parameterObject,&nbsp;rowBounds,&nbsp;resultHandler);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;delegate.query(ms,&nbsp;parameterObject,&nbsp;rowBounds,&nbsp;resultHandler);\n&nbsp;&nbsp;}</code></pre> \n <p><br></p> \n <span id=\"OSC_h3_6\"></span> \n <h3>5、二级缓存理解</h3> \n <p>CachingExecutor: 二级缓存执行器。灵活地使用 delegate机制。其委托执行的类是 BaseExcutor。 当无法从二级缓存获取数据时，同样需要从 DB 中进行查询，于是在这里可以直接委托给 BaseExcutor 进行查询。一级缓存就涉及到一个类<span style=\"line-height: 22.5px;\">PerpetualCache ，然而二级缓存则是一个责任链模式的结构，可以通过配置文件指定需要的缓存类</span></p> \n <p><span style=\"line-height: 22.5px;\"><img src=\"http://static.oschina.net/uploads/space/2016/0220/232101_vcMJ_1989321.png\"></span></p> \n <span id=\"OSC_h3_7\"></span> \n <h3>6、二级缓存的设置</h3> \n <p>在Mapper文件中配置开启二级缓存</p> \n <p>&lt;cache</p> \n <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eviction=\"FIFO\"</p> \n <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushInterval=\"600000\" &nbsp;size=\"512\"</p> \n <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readOnly=\"true\"</p> \n <p>&nbsp; &nbsp; /&gt;</p> \n <p><br></p> \n</div>',NULL,'2020-02-02 19:30:48',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223932127226187776',NULL,NULL,' Mysql心路历程：Mysql各种锁机制(进阶篇)  ','<div class=\"content\" id=\"articleContent\"> \n <blockquote> \n  <p>通过上一篇基本锁的介绍，基本上Mysql的基础加锁步奏，有了一个大概的了解。接下来我们进入最后一个锁的议题：间隙锁。间隙锁，与行锁、表锁这些要复杂的多，是用来解决幻读的一大手段。通过这种手段，我们没必要将事务隔离级别调整到序列化这个最严格的级别，而导致并发量大大下降。读取这篇文章之前，我想，我们要首先还是读一下我先前的两篇文章，否则一些理念还真的透彻不了：</p> \n  <ul> \n   <li><a href=\"https://my.oschina.net/UBW/blog/3023671\">Mysql心路历程：两个\"log\"引发的\"血案\"</a></li> \n   <li><a href=\"https://my.oschina.net/UBW/blog/3057575\">Mysql心路历程：Mysql各种锁机制(入门篇)</a></li> \n  </ul> \n </blockquote> \n <h2>一、基础测试表与数据</h2> \n <p>为了进行整个间隙锁的深入，我们要构建一些基础的数据，本章我们都会用构建的基础数据来进行，下面是数据表与索引的建立：</p> \n <pre><code class=\"language-sql\">create table `t` (\n  `id` int(11) not null,\n  `c` int(11) DEFAULT null,\n  `d` int(11) DEFAULT null,\n  primary key (`id`),\n  key `c` (`c`)\n) ENGINE=InnoDB;\n\n</code></pre> \n <p>然后我们插入一些基础的数据：</p> \n <pre><code class=\"language-sql\">insert into t values \n(0,0,0),\n(5,5,5),\n(10,10,10),\n(15,15,15),\n(20,20,20),\n(25,25,25);\n</code></pre> \n <p>另外，我们本次讲解，都是使用默认的数据库隔离级别：<strong>可重复读</strong></p> \n <h2>二、什么叫幻读</h2> \n <p>好，这个问题，就很关键了！我们来细说，幻读的具体出现的经典场景。其实很简单，先看下面的具体的复现sql语句：</p> \n <table> \n  <thead> \n   <tr> \n    <th></th> \n    <th>sessionA</th> \n    <th>sessionB</th> \n    <th>sessionC</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>t1</td> \n    <td>begin;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t2</td> \n    <td></td> \n    <td>update t set d = 5 where id = 0;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t3</td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t4</td> \n    <td></td> \n    <td></td> \n    <td>insert into t values(1,1,5)</td> \n   </tr> \n   <tr> \n    <td>t5</td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t6</td> \n    <td>commit;</td> \n    <td></td> \n    <td></td> \n   </tr> \n  </tbody> \n </table> \n <p>针对这一系列的操作，我们来一个个分析：</p> \n <ul> \n  <li>sessionA在t1时刻，可见读的结果是：(5,5,5)，d没有索引，所以是全表扫描，对id为5的那一行，加行锁的写锁</li> \n  <li>由于sessionB再t2时刻，将id为0的数据改了下，所以t3时刻，sessionA的可见读的结果是：(0,0,5),(5,5,5)</li> \n  <li>由于sessionC再t4时刻，插入了条不存在的数据，所以t6时刻，sessionA的可见读结果是：(0,0,0)(1,1,5)(5,5,5)</li> \n  <li>如果，我们不添加for update进行可见读，普通的一致性读的情况下，由于mvcc的创建快照机制的影响，sessionA一直都会只看到(5,5,5)这一条数据</li> \n  <li>update之后，可见读查出来的多一条数据，并不是幻读，<strong>只有插入之后的可见读，多读出来的数据，才叫幻读</strong>。就好比我们本来有两条原始数据，可是在事务的没结束之前的前后去读，分别读出来2条和3条，多出一条，就好像我在之后读出的3条数据，是幻影一样，突然出现了，所以叫幻读。</li> \n  <li><strong>虽然我们平时几乎不会使用select for update进行查询，但是，要记住，update语句之前就是要进行一次for update的select查询的！</strong></li> \n </ul> \n <h2>三、幻读会有什么影响</h2> \n <p>大概上，有两个影响，如下。</p> \n <h3>1、语义冲突</h3> \n <pre><code class=\"language-sql\">select * from t where d = 5 for update;\n</code></pre> \n <p>类似的，我们这条语句，其实语义上面是想锁住所有d等于5的行数据，让其不能update和insert。然而，我们接下来的sessionB和sessionC里面，如果没有相关的解决幻读的机制存在，那么都会有问题：</p> \n <pre><code class=\"language-sql\">-- sessionB增加点操作\nupdate t set d = 5 where id = 0;\nupdate t set c = 5 where id = 0;\n</code></pre> \n <p>可见第二条sql已经操作了id等于0，d等于5这一行的数据，与之前的锁所有等于5的行语义上面冲突。</p> \n <h3>2、数据一致性问题</h3> \n <p>这个很关键，涉及到binglog问题。下面是我们具体操作的sql表格：</p> \n <table> \n  <thead> \n   <tr> \n    <th></th> \n    <th>sessionA</th> \n    <th>sessionB</th> \n    <th>sessionC</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>t1</td> \n    <td>begin;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>update t set d = 100 where d = 5;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t2</td> \n    <td></td> \n    <td>update t set d = 5 where id = 0;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>update t set c = 5 where id = 0;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t3</td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t4</td> \n    <td></td> \n    <td></td> \n    <td>insert into t values(1,1,5);</td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td></td> \n    <td>update t set c = 5 where id = 1;</td> \n   </tr> \n   <tr> \n    <td>t5</td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t6</td> \n    <td>commit;</td> \n    <td></td> \n    <td></td> \n   </tr> \n  </tbody> \n </table> \n <p>由于，binglog是要等commit之后，才会记录的（后面文章会有细节的讲解），所以，上面这一系列的sql操作，到了binglog里面会变成下面的样子：</p> \n <pre><code class=\"language-sql\">update t set d=5 where id=0; /*(0,0,5)*/\nupdate t set c=5 where id=0; /*(0,5,5)*/\n\ninsert into t values(1,1,5); /*(1,1,5)*/\nupdate t set c=5 where id=1; /*(1,5,5)*/\n\nupdate t set d=100 where d=5;/* 所有 d=5 的行，d 改成 100*/\n\n</code></pre> \n <p>可以看到，由于我们前面说，只对id等于5这一行，加了行锁，所以sessionB的操作是可以进行的，所以，最终会发现，我们sessionA里面的update操作，是最后执行的，如果拿着这个binglog同步从库的话，必然会导致，(0,5,100)、(1,5,100) 和 (5,5,100)这种数据出现，和主库完全不一致！(主库里面，只有id为5的数据，d才为100)。</p> \n <p>那么我们将所有扫秒到的数据行都加了锁，会如何呢？那么，sessionB里面的第一条update语句将被阻塞，binglog里面的数据如下：</p> \n <pre><code class=\"language-sql\">insert into t values(1,1,5); /*(1,1,5)*/\nupdate t set c=5 where id=1; /*(1,5,5)*/\n\nupdate t set d=100 where d=5;/* 所有 d=5 的行，d 改成 100*/\n\nupdate t set d=5 where id=0; /*(0,0,5)*/\nupdate t set c=5 where id=0; /*(0,5,5)*/\n\n</code></pre> \n <p>这样的结果，id为0的这一行的数据，的确能保证数据的一直性，但是，会发现，刚刚插进去的id为1的这一样，在主库里面，d的值为5，但是在从库里面执行了binglog之后，会变成100，又会有不一致的情况出现了！</p> \n <h2>四、初入\"间隙锁\"</h2> \n <p>针对幻读问题，我们日常理论中经常\"背诵\"的，是：第三事务隔离级别会出现幻读情况，只有通过提高隔离级别，到最高级别的串行化，能解决幻读这样的问题。但是这样，每一个时刻只能有一个线程操作同一个表，并发性大大的降低，根本无法满足，高并发的需求，要知道，Mysql这东西，可是各大顶级互联网公司趋之若鹜的基础数据库，怎么能效率这么差呢？在这里，Mysql就引入了间隙锁的概念。下面我们来看看，间隙锁如何加锁。</p> \n <h3>1、间隙锁的产生</h3> \n <p>首先，如果我们使用下面语句进行查询：</p> \n <pre><code class=\"language-sql\">select * from t where d = 5 for update;\n</code></pre> \n <p>这样，由于d是没有索引的，那么会走全表查询，默认走的是id的主键索引，按照id的主键值，会产生如下的区间：</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/351717bf485e2046f101ad1d5ecc3225451.jpg\" alt=\"\"></p> \n <h3>2、如何加间隙锁</h3> \n <p>例如上面的select语句中，d是没有索引的，所以通过id索引进行全表扫面，又因为是for update，那么，会将表中仅有的六条数据，都加上行锁，然后，针对上面的六个区间，也会加上<strong>间隙锁</strong>。行锁+间隙锁就是我们喜闻乐见的：next-key lock了！所以，整体上看也就是7个next-key lock：</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/5c17a6bc4ef37f842b57153009ae7703912.jpg\" alt=\"\"></p> \n <blockquote> \n  <p>这个+∞是可以进行配置的，给每个索引分配一个不存在的值</p> \n </blockquote> \n <h3>3、间隙锁的特性</h3> \n <p>前面的文章，我们似乎聊过行锁之间的互斥形式：</p> \n <table> \n  <thead> \n   <tr> \n    <th></th> \n    <th>读锁</th> \n    <th>写锁</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>读锁</td> \n    <td>兼容</td> \n    <td>冲突</td> \n   </tr> \n   <tr> \n    <td>写锁</td> \n    <td>冲突</td> \n    <td>冲突</td> \n   </tr> \n  </tbody> \n </table> \n <p>但是间隙锁不是。<strong>和间隙锁冲突的，是往这个间隙里面插入一条数据</strong>！这一点也是很好的保持并发性的一个挽回。下面看一个操作：</p> \n <table> \n  <thead> \n   <tr> \n    <th>sessionA</th> \n    <th>sessionB</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>begin;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>select * from t where c = 7 lock in share model;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>begin;</td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>select * from t where c = 7 for update;</td> \n   </tr> \n  </tbody> \n </table> \n <p>虽然，两个事务，都是真对同一条数据，进行可见读的查询，但是并不会阻塞！因为c没有7的这个值，那结果就是，只会在数据库里面加上了(5,10)这个间隙锁，两个可见读并不会因为间隙锁和互斥冲突！</p> \n <p>如果这样，加上间隙锁的特性，和行锁的特性，针对上面章节的sql操作：</p> \n <table> \n  <thead> \n   <tr> \n    <th></th> \n    <th>sessionA</th> \n    <th>sessionB</th> \n    <th>sessionC</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>t1</td> \n    <td>begin;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>update t set d = 100 where d = 5;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t2</td> \n    <td></td> \n    <td>update t set d = 5 where id = 0;<strong>（阻塞）</strong></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>update t set c = 5 where id = 0;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t3</td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t4</td> \n    <td></td> \n    <td></td> \n    <td>insert into t values(1,1,5);<strong>（阻塞）</strong></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td></td> \n    <td>update t set c = 5 where id = 1;</td> \n   </tr> \n   <tr> \n    <td>t5</td> \n    <td>select * from t where d = 5 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>t6</td> \n    <td>commit;</td> \n    <td></td> \n    <td></td> \n   </tr> \n  </tbody> \n </table> \n <p>最终生成的binglog就会是：</p> \n <pre><code class=\"language-sql\">update t set d=100 where d=5;/* d 改成 100*/\n\ninsert into t values(1,1,5); /*(1,1,5)*/\nupdate t set c=5 where id=1; /*(1,5,5)*/\n\n\n\nupdate t set d=5 where id=0; /*(0,0,5)*/\nupdate t set c=5 where id=0; /*(0,5,5)*/\n</code></pre> \n <p>这样，就解决了数据一致性的问题了，主从库里面都能保持一致。</p> \n <h3>4、间隙锁带来的问题</h3> \n <p>虽然，间隙锁能比较好的解决上诉我们探讨的问题，但是同时也会带来些麻烦，要我们特别的注意。例如下面的操作，是一段业务上面的伪代码：</p> \n <pre><code class=\"language-java\">tx.beginTransaction();\nvar t  = select * from t where id = 9 for update;\nif(t){\n  update t set d = 45 where id = 9;\n}else{\n  insert into t values(9,5,45);\n}\ntx.commit();\n</code></pre> \n <p>（假设id等于9这一行不存在）这段业务逻辑代码，普通情况下，我也经常看到，问题不太会出现，一旦并发量上去了，就会出问题，会造成死锁，下面我们看看造成死锁的sql执行序列：</p> \n <table> \n  <thead> \n   <tr> \n    <th></th> \n    <th>sessionA</th> \n    <th>sessionB</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>t1</td> \n    <td>begin;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>select * from t where id = 9 for update;</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>begin;</td> \n   </tr> \n   <tr> \n    <td>t2</td> \n    <td></td> \n    <td>select * from t where id = 9 for update;</td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>insert into t values(9,5,45);（阻塞，等待sessionA的(5,10)的间隙锁释放）</td> \n   </tr> \n   <tr> \n    <td>t3</td> \n    <td>insert into t values(9,5,45); （阻塞，等待sessionB的(5,10)的间隙锁释放，死锁！）</td> \n    <td></td> \n   </tr> \n  </tbody> \n </table> \n <p>当然，InnoDB的自动死锁检测，会发现这一点，主动将sessionA回滚，报错！</p> \n <h2>五、晋级\"间隙锁\"</h2> \n <p>有关于间隙锁，是最后一层级的细节所在，所以在判断是否加、怎么加、是否会阻塞方面，有非常多的考量。接下来我们来分别来说一下4个细节，分别对应4个例子，来讲讲，首先我们列出五条规则：</p> \n <ul> \n  <li>加锁的基本单位是next-key lock，就是针对扫描过的数据进行加间隙锁</li> \n  <li>索引上进行等值查询时，给唯一索引加锁的时候，next-key lock退化为行锁</li> \n  <li>索引上进行等值查询时，向右遍历，最后一个数值不满足等值的条件的时候，next-key lock退化为间隙锁，就是前后都是开区间</li> \n  <li>唯一索引的范围查询，会访问到第一个不满足的条件为止</li> \n </ul> \n <h3>1、第一条规则</h3> \n <blockquote> \n  <p>加锁的基本单位是next-key lock，就是针对扫描过的数据进行加间隙锁</p> \n </blockquote> \n <p>先来看看几个sql语句：</p> \n <pre><code class=\"language-sql\">select * from t where id = 5 for update;\nselect * from t where id = 10 lock in share model;\n</code></pre> \n <p>两个分别对5和10这两行加了写锁与读锁，但是最开始，再索引树上面，首先加载id为5和10的这两行的时候，加锁步骤如下：</p> \n <ul> \n  <li>加(0,5)和(5,10)这两个间隙锁</li> \n  <li>加5的这一行的行锁(写锁)，加10这一行的行锁(读锁)</li> \n  <li>所以目前为止，基础加锁的单位为next-key lock</li> \n </ul> \n <h3>2、第二条规则</h3> \n <blockquote> \n  <p>索引上进行等值查询时，给唯一索引加锁的时候，next-key lock退化为行锁</p> \n </blockquote> \n <p>还是第一条规则的两天语句，发现，id是主键索引(唯一索引)，所以去掉了(0,5)(5,10)的这两个间隙锁，所以整个next-key lock变成了单纯的行锁</p> \n <h3>3、第三条规则</h3> \n <blockquote> \n  <p>索引上进行等值查询时，向右遍历，最后一个数值不满足等值的条件的时候，next-key lock退化为间隙锁，就是前后都是开区间</p> \n </blockquote> \n <p>先来看看下面的操作过程：</p> \n <table> \n  <thead> \n   <tr> \n    <th>sessionA</th> \n    <th>sessionB</th> \n    <th>sessionC</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>begin;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>update t set d = d+1 where id = 7;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>insert into t values (8,8,8);(阻塞！)</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>update t set d = d+1 where id = 10;(成功)</td> \n   </tr> \n  </tbody> \n </table> \n <p>我们来分析：</p> \n <ul> \n  <li>update之前会进行select for update操作，所以就是对id为7的这一行进行可见读</li> \n  <li>由于7这行记录不存在，但是7落在了(5,10)这个区间，而根据第一条原则，加锁基本单位是next-key lock，所以加锁会加上(5,10)的间隙锁，和10这一行的行锁(写锁)，就是(5,10]</li> \n  <li>由于最后一条记录10和等值查询中的7并不相等，所以退化成了间隙锁，10这个的行锁解除。</li> \n </ul> \n <p>所以根据这个规则，(5,10)这个区间是被锁住额，所以insert会被阻塞，另外10这一行的行锁解除，所以sessionC中的update会成功。</p> \n <h3>4、第四条规则</h3> \n <blockquote> \n  <p>唯一索引的范围查询，会访问到第一个不满足的条件为止</p> \n </blockquote> \n <p>看看下面的操作序列：</p> \n <table> \n  <thead> \n   <tr> \n    <th>sessionA</th> \n    <th>sessionB</th> \n    <th>sessionC</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>begin;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>select * from t where id &gt; 10 and id &lt;=15 for update;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>update t set d = d+1 where id = 20;(阻塞)</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>insert into t values(16,16,16);(阻塞)</td> \n   </tr> \n  </tbody> \n </table> \n <p>分析：</p> \n <ul> \n  <li>由于10不是等值，15是等值，所以10这一条不会加next-key lock，15会，所以首先加上了(10,15]</li> \n  <li>虽然是唯一索引，但是是区间查询，并不会停止加锁的脚步，会继续向右</li> \n  <li>找到20这条记录，加上了next-key lock的(15,20]</li> \n  <li>由于不是等值查询，是范围查询，所以应用不了规则三，所以最终形成的锁是：(10,15],(15,20]</li> \n </ul> \n <p>这么一看，20这一行被行锁锁住，而且15,20的区间还有间隙锁，所以sessionB和sessionC的操作才会阻塞。</p> \n <h3>5、其他方面的细节</h3> \n <p>每次加锁，其实都是锁索引树。众所周知，InnoDB的非主键索引的最终叶子节点，都只存储id主键值，然后还要遍历id主键索引，才能搜索出整条的数据，我们通常将这个过程称之为：回表。当然，如果select的是一个字段，这个字段刚好是id，那么Mysql就不用进行回表查询，因为直接在索引树上就能读取到值，MySQL会进行这种优化，通常我们称之为：索引下推。根据这个特性，我们来看看下面的操作序列：</p> \n <table> \n  <thead> \n   <tr> \n    <th>sessionA</th> \n    <th>sessionB</th> \n    <th>sessionC</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>begin;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td>select id from t where c = 5 lock in share model;</td> \n    <td></td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td>update t set d = d+1 where id = 5;(成功)</td> \n    <td></td> \n   </tr> \n   <tr> \n    <td></td> \n    <td></td> \n    <td>insert into t values(3,3,3);(阻塞)</td> \n   </tr> \n  </tbody> \n </table> \n <ul> \n  <li>只在c这个非唯一索引上，加了行读锁，基础的加锁单位是(0,5]，由于是非唯一索引的查询，并不能退化为行锁</li> \n  <li>由于非唯一索引，要继续往下，加上了(5,10]这一个的next-key lock，由于最右边的最后一个值，和等值查询并不相等，所以退化成间隙锁(5,10)，所以sessionC会被阻塞</li> \n  <li>由于sessionA中的可见读是读锁，并且只查询id的值，所以启动了索引下推优化，只会加c这个索引上面的行锁。如果换成for update，那就会顺便将主键索引上面也加上锁。所以这里要分清两种行锁的粒度。</li> \n  <li>所以，最后，sessionB能成功的愿意是：主键索引上并没有加锁</li> \n </ul> \n <h2>六、结束</h2> \n <p>锁，在我的能力范围能，能说的就这么多，具体还是要用于实践。接下来，打算写很重要的两个日志文件的介绍：binglog和redolog</p> \n</div>',NULL,'2020-02-02 19:32:13',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223932483960131584',NULL,NULL,' 【持久化框架】Mybatis与Hibernate的详细对比  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h2_1\"></span> \n <h2>前言</h2> \n <p>这篇博文我们重点分析一下<strong>Mybatis</strong>与<strong>Hibernate</strong>的区别，当然在前面的博文中我们已经深入的研究了Mybatis和Hibernate的原理。</p> \n <p><strong><em>Mybatis</em></strong></p> \n <ol> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/45286191\" target=\"_blank\" rel=\"nofollow\">【持久化框架】Mybatis简介与原理</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/45132493\" target=\"_blank\" rel=\"nofollow\">【持久化框架】SpringMVC+Spring4+Mybatis3集成，开发简单Web项目+源码下载</a></li> \n </ol> \n <p><strong><em>Hibernate</em></strong></p> \n <ol> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/39078749\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate基本原理（一）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/39380465\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate搭建开发环境+简单实例（二）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/40153905\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate基本映射（三）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/40345389\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate映射——多对一单向关联映射（四）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/43819343\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate映射——一对一单向关联映射（五）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/40384463\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate映射——一对一双向关联映射（六）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/41015641\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate映射——一对多关联映射（七）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/41015645\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate映射——多对多关联映射（八）</a></li> \n  <li><a href=\"http://blog.csdn.net/jiuqiyuliang/article/details/41318751\" target=\"_blank\" rel=\"nofollow\">【SSH进阶之路】Hibernate系列——总结篇(九)</a></li> \n </ol> \n <p>作为一位优秀的程序员，只知道一种ORM框架是远远不够的。在开发项目之前，架构的技术选型对于项目是否成功起到至关重要的作用。我们不仅要了解同类型框架的原理以及技术实现，还要深入的理解各自的优缺点，以便我们能够在项目的实施过程中面对的困难更少。</p> \n <p>所以这篇博文我们要将Mybatis和Hibernate进行一下深入的对比，加深我们对<strong>持久化</strong>框架的理解。下面我们开始今天的旅行。</p> \n <span id=\"OSC_h2_2\"></span> \n <h2>Hibernate与Mybatis对比</h2> \n <span id=\"OSC_h3_3\"></span> \n <h3>1. 简介</h3> \n <p>Hibernate：Hibernate是当前最流行的ORM框架之一，对JDBC提供了较为完整的封装。Hibernate的O/R Mapping实现了POJO 和数据库表之间的映射，以及SQL的自动生成和执行。</p> \n <p>Mybatis：Mybatis同样也是非常流行的ORM框架，主要着力点在于 POJO 与 SQL 之间的映射关系。然后通过映射配置文件，将SQL所需的参数，以及返回的结果字段映射到指定 POJO 。相对Hibernate“O/R”而言，Mybatis 是一种“Sql Mapping”的ORM实现。</p> \n <span id=\"OSC_h3_4\"></span> \n <h3>2. 开发速度</h3> \n <ol> \n  <li> <p>难易度</p> <p>Hibernate的真正掌握要比Mybatis困难，Hibernate比mybatis更加重量级一些。</p> <p>Mybatis框架相对简单很容易上手，但也相对简陋些。</p> </li> \n  <li> <p>开发工作量</p> <p>Mybatis需要我们手动编写SQL语句，回归最原始的方式，所以可以按需求指定查询的字段，提高程序的查询效率。</p> <p>Hibernate也可以自己写SQL语句来指定需要查询的字段，但这样破坏了Hibernate封装以及简洁性。</p> </li> \n </ol> \n <span id=\"OSC_h3_5\"></span> \n <h3>3. 数据库移植性</h3> \n <p>Mybatis由于所有SQL都是依赖数据库书写的，所以扩展性，迁移性比较差。</p> \n <p>Hibernate与数据库具体的关联都在XML中，所以HQL对具体是用什么数据库并不是很关心。</p> \n <span id=\"OSC_h3_6\"></span> \n <h3>4. 缓存机制对比</h3> \n <ol> \n  <li> <p>相同点</p> <p>Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</p> </li> \n  <li> <p>不同点</p> <p>Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</p> <p>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p> </li> \n  <li> <p>两者比较</p> <p>因为Hibernate对查询对象有着良好的管理机制，用户无需关心SQL。所以在使用二级缓存时如果出现脏数据，系统会报出错误并提示。而MyBatis在这一方面，使用二级缓存时需要特别小心。如果不能完全确定数据更新操作的波及范围，避免Cache的盲目使用。否则，脏数据的出现会给系统的正常运行带来很大的隐患。</p> </li> \n </ol> \n <span id=\"OSC_h3_7\"></span> \n <h3>5. 两者对比总结</h3> \n <span id=\"OSC_h4_8\"></span> \n <h4>两者相同点</h4> \n <ul> \n  <li> <p>Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。如下图所示：</p> <p><img alt=\"这里写图片描述\" src=\"https://img-blog.csdn.net/20150430002033414\"></p> </li> \n  <li>Hibernate和MyBatis都支持JDBC和JTA事务处理。</li> \n </ul> \n <span id=\"OSC_h4_9\"></span> \n <h4>Hibernate优势</h4> \n <ul> \n  <li> <p>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</p> </li> \n  <li> <p>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</p> </li> \n  <li> <p>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</p> </li> \n  <li> <p>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p> </li> \n </ul> \n <span id=\"OSC_h4_10\"></span> \n <h4>Mybatis优势</h4> \n <ul> \n  <li> <p>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。</p> </li> \n  <li> <p>MyBatis容易掌握，而Hibernate门槛较高。</p> </li> \n </ul> \n <span id=\"OSC_h2_11\"></span> \n <h2>一句话总结</h2> \n <p>在博文的结尾，我们将Mybatis和Hibernate之间的区别自个用六个词做总结：</p> \n <p><strong>Mybatis</strong>：小巧、方便、高效、简单、直接、半自动化</p> \n <p><strong>Hibernate</strong>：强大、方便、高效、复杂、间接、全自动化</p> \n</div>',NULL,'2020-02-02 19:33:38',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223932842048835584',NULL,NULL,' mysql 大量time wait 解决办法  ','<div class=\"content\" id=\"articleContent\"> \n <p>&nbsp; 今天早上一上班，有同事就反映公司好几个网站都打不开，登陆数据库</p> \n <div>\n   服务器(windows)，发现很卡,于是重启了下服务器，进入系统后，没过一会问题依旧,查看了下系统进程，发现mysql占用率达到99%，可以肯定的是mysql连接出现问题: \n </div> \n <div>\n   netstat -an \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30443&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30444&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30445&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30446&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30447&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30448&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30449&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30450&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30451&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   192.168.12.13:3306&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.12:30452&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT \n </div> \n <div>\n   ... ... \n </div> \n <div> \n  <span style=\"font-family:Verdana;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟,即240秒,TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证.</span> \n  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n  <span style=\"font-family:Verdana;\">在HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters,添加名为TcpTimedWaitDelay的<br> DWORD键,设置为60,以缩短TIME_WAIT的等待时间</span> \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   登陆到web服务器(linux)： \n </div> \n <div>\n   &nbsp;&nbsp;&nbsp;&nbsp; \n </div> \n <div>\n   &nbsp;&nbsp;&nbsp;&nbsp; netstat -ae |grep mysql \n </div> \n <div>\n   &nbsp;&nbsp;&nbsp;&nbsp; tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53045&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53044&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53051&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53050&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53049&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53055&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53054&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53053&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53052&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53059&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53058&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53057&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53056&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53063&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53062&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53061&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53060&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.3:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53067&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53066&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53065&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53064&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa53071&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53070&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:53069&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TIME_WAIT&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 \n  <br> 发现系统存在大量TIME_WAIT状态的连接，通过调整内核参数解决， \n </div> \n <div> \n  <span style=\"font-family:新宋体;\">vi /etc/sysctl.conf</span> \n </div> \n <div> \n  <span style=\"font-family:新宋体;\"><br> </span>编辑文件，加入以下内容： \n  <br> \n  <code><span style=\"font-family:新宋体;\">net.ipv4.tcp_syncookies = 1<br> net.ipv4.tcp_tw_reuse = 1<br> net.ipv4.tcp_tw_recycle = 1<br> net.ipv4.tcp_fin_timeout = 30</span></code> \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   然后执行&nbsp; \n  <code><span style=\"font-family:新宋体;\">/sbin/sysctl -p</span></code>&nbsp;让参数生效。 \n </div> \n <div>\n   &nbsp; \n </div> \n <div> \n  <strong>net.ipv4.tcp_syncookies = 1</strong>&nbsp;表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； \n </div> \n <div> \n  <br> \n  <strong>net.ipv4.tcp_tw_reuse = 1</strong>&nbsp;表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； \n </div> \n <div> \n  <br> \n  <strong>net.ipv4.tcp_tw_recycle = 1</strong>&nbsp;表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 \n </div> \n <div> \n  <br> \n  <strong>net.ipv4.tcp_fin_timeout</strong>&nbsp;修改系統默认的 TIMEOUT 时间 \n </div> \n <div>\n   &nbsp; \n </div> \n <div>\n   修改之后，再用 \n </div> \n <div>\n   netstat -ae|grep mysql \n </div> \n <div>\n   tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:50408&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED nobody&nbsp;&nbsp;&nbsp;&nbsp; 3224651 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:50417&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED nobody&nbsp;&nbsp;&nbsp;&nbsp; 3224673 \n  <br> tcp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 aaaa:50419&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 192.168.12.13:mysql&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ESTABLISHED nobody&nbsp;&nbsp;&nbsp;&nbsp; 3224675 \n </div> \n <div> \n  <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 发现大量的TIME_WAIT&nbsp;已不存在，mysql进程的占用率很快就降下来的，各网站访问正常！！ \n </div> \n <div>\n   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以上只是暂时的解决方法，最后仔细巡查发现是前天新上线的一个系统，程序代码中没有使用mysql.colse()，才导致大量的mysql&nbsp; TIME_WAIT &nbsp; \n </div> \n</div>',NULL,'2020-02-02 19:35:04',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223933199118323712',NULL,NULL,' TIME_WAIT和CLOSE_WAIT  ','<div class=\"content\" id=\"articleContent\"> \n <p>对于保持大量TIME_WAIT或 CLOSE_WAIT状态解决办法。</p> \n <p><span style=\"font-size: 12px;\">服务器命令：</span></p> \n <p><span style=\"font-size: 12px;\"></span></p> \n <pre class=\"brush:shell;toolbar: true; auto-links: false;\"><code>netstat&nbsp;-n&nbsp;|&nbsp;awk&nbsp;\'/^tcp/&nbsp;{++S[$NF]}&nbsp;END&nbsp;{for(a&nbsp;in&nbsp;S)&nbsp;print&nbsp;a,&nbsp;S[a]}\'</code></pre> \n <p></p> \n <p><span style=\"font-size: 12px;\">显示信息：</span></p> \n <p><span style=\"font-size: 12px;\">TIME_WAIT 108</span></p> \n <p><span style=\"font-size: 12px;\">CLOSE_WAIT 1021</span></p> \n <p><span style=\"font-size: 12px;\">ESTABLISHED 44</span></p> \n <p><span style=\"font-size: 12px;\">FIN_WAIT2 11</span></p> \n <p><span style=\"font-size: 12px;\">LAST_ACK 1</span></p> \n <p><span style=\"font-family: Arial, Verdana, sans-serif; line-height: 19.5px; font-size: 12px; background-color: rgb(255, 255, 255);\">常用的三个状态是：<strong>ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。</strong></span></p> \n <p><span style=\"font-size: 12px;\">对于 保持大量<span style=\"font-size: 12px; line-height: 22.5px;\">TIME_WAIT 或&nbsp;<span style=\"font-size: 12px; line-height: 22.5px;\">CLOSE_WAIT 状态 ，理解和解决办法：</span></span></span></p> \n <p><span style=\"font-size: 12px;\"><span style=\"font-size: 12px; line-height: 22.5px;\"><span style=\"font-size: 12px; line-height: 22.5px;\">TIME_WAIT:</span></span></span></p> \n <p><span style=\"font-size: 12px;\"><span style=\"font-size: 12px; line-height: 22.5px;\"><span style=\"font-size: 12px; line-height: 22.5px;\">&nbsp;&nbsp;&nbsp;&nbsp;主动发起关闭的一方最终会进入TIME_WAIT状态，TIME_WAIT会持续一段时间，一般是2MSL，其目的是为了实现TCP全双工连接的终止,并允许老的重复分节从网络中消逝。</span></span></span></p> \n <p><span style=\"font-size: 12px;\"><span style=\"font-size: 12px; line-height: 22.5px;\"><span style=\"font-size: 12px; line-height: 22.5px;\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>优化服务器，</strong>能够快速回收和重用那些TIME_WAIT的资源。</span></span></span></p> \n <p><span style=\"font-size: 12px;\">CLOSE_WAIT:</span></p> \n <p><span style=\"font-size: 12px;\">&nbsp;&nbsp;&nbsp;&nbsp;被动关闭的一方进入CLOSE_WAIT状态，CLOSE_WAIT的意思是等待应用进程调用close()。</span></p> \n <p><span style=\"font-size: 12px;\">&nbsp;&nbsp;&nbsp;&nbsp;<strong>查代码</strong>。问题一定出现在服务器程序，对方关闭连接之后服务器程序自己没有进一步发出ack信号。</span></p> \n <p><br></p> \n <p><br></p> \n</div>',NULL,'2020-02-02 19:36:29',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223933557324468224',NULL,NULL,' Mockplus黑色星期五和网络星期一特惠  ','<div class=\"content\" id=\"articleContent\"> \n <p>作为一个全面的原型设计工具，<a href=\"https://www.mockplus.cn/\" rel=\"nofollow\">Mockplus</a>让做原型变得更快／更简单。在黑色星期五和网络星期一的繁忙购物节期间，Mockplus现在也提供有特别优惠，无需优惠码或者优惠链接。任何用户都可以直接从这个促销页面，获得独家的折扣和优惠。请注意，此促销活动今仅对包年套餐有效，并将持续到2016年11月28日，以下是更详细的信息。</p> \n <p><strong>1.&nbsp;</strong><strong>每笔订单可省59%</strong></p> \n <p>以提供更好／更佳的设计工具和用户体验为目标，Mockplus目前已在全球各地的UX设计师，UI设计师，产品经理，开发人员以及IT专业人员中越来越受欢迎。截止当前，已有超过25万用户，极少有用户的负面评论。</p> \n <p><img alt=\"\" height=\"459\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/714eaaa4-40df-42d9-bad2-eef4a37ddcd8.png\" width=\"795\"></p> \n <p>今年，Mockplus给到你高达59%的折扣。往期的专业版价格是每年348美元，但目前的促销价格为每年144美元，也就是每个月12美元。此优惠适用于当前任何包年用户，设计师们可以一次性节省204美元。但请注意，它不包括包月套餐和团购折扣。这个价格十分有竞争力，不信让我们一起对比下时下最流行的几款原型设计工具。</p> \n <p>Axure (Pro) Balsamiq Justinmind Mockplus UXPin Pidoco (Standard)&nbsp;<br> 包月价 $29 none $29 $29 $29 $30&nbsp;<br> 包年价 $495 $89 $228 $144 $98 $360&nbsp;<br> 项目 不限制 不限制 不限制 不限制 不限制 8&nbsp;</p> \n <p>显而易见，Mockplus是最经济实惠的选择，现成的200个组件和3000个图标，也是它的另一大优势。</p> \n <p><strong>2.&nbsp;</strong><strong>如何获得Mockplus独家优惠？</strong></p> \n <p>与其他公司需要促销码或促销链接来激活优惠不同，Mockplus让任何感兴趣的用户都有机会从此页面兑换和获取优惠，大大简化了流程。下面有两个优惠：</p> \n <p>a.黑色星期五特惠</p> \n <p>正如你所见，包年套餐的价格直降到每月12美元。只需选择“包年”，点击“立即购买”按钮，每个用户都可以得到优惠价。这个特优价，还包括很多强大的功能：</p> \n <p><img alt=\"\" height=\"610\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/26fd3f85-8cc1-49a8-83bc-95ebe45cecc6.png\" width=\"1260\"></p> \n <p>1）导出到HTML，让你的同事或客户通过网页链接测试原型；</p> \n <p>2）3000个图标，素材资源不再担忧；</p> \n <p>3）云同步，让你随时随地地上传并与他人分享你的原型；</p> \n <p>4）导出到项目树，支持多种格式，比如：MindMap/TreeView/XML/CSV/Text/HTML/MarkDown等。</p> \n <p>b.团购优惠</p> \n <p>对于想要批量购买注册码等团队或企业，他们可以看看“团购”。同样地，此优惠只适用于包年的套餐，并有不同力度的折扣优惠：</p> \n <p><img alt=\"\" height=\"746\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/3fa59fdb-2ff0-40cd-96ea-80e93ded08fc.png\" width=\"1077\"></p> \n <p>3. 新手指南和视频教程</p> \n <p>无论你是否有设计基础，都可以轻松掌握Mockplus。对于想要快速上手Mockplus的新手来说，有大量的帮助文章和视频教程，可以在这个“<a href=\"http://doc.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">教程</a>”网站和“YouTube”频道轻松找到。对于紧急或棘手的问题，用户可以发送电子邮件到support@jongde.com，有客服人员提供最贴心／最专业的服务。</p> \n <p><img src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/413a4841-8b56-407c-affd-5f904933ccda.png\"></p> \n</div>',NULL,'2020-02-02 19:37:54',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223933915547389952',NULL,NULL,' 一个工具就够了？原型设计没那么简单！  ','<div class=\"content\" id=\"articleContent\"> \n <p>原型设计是软件设计开发过程中必不可少的一部分，但是现在我们能够看到的原型设计工具种类多到让人眼花缭乱。如果你只是选择了其中的一款工具，并且觉得原型设计工具只需要一个，对于整个设计开发过程就足够了，那你就大错特错了。事实上，这些原型设计工具连接起来，才是一个完整的设计流程。</p> \n <p>草图/线框图阶段：纸笔、白板、Balsamiq、<a href=\"https://www.mockplus.cn/\" rel=\"nofollow\">Mockplus</a></p> \n <p>无论是美术设计还是用户体验设计，或者是用户界面设计，首先要做的事情就是画草图、打草稿。当我们天马行空的进行想象的时候，记录的工作交给它们就好了。纸笔和白板不用多说，千百年来老祖宗留下的好东西为我们解决了太多的记录问题。Balsamiq、Mockplus以及其他的可以产生线框图的工具是新世纪科技带给设计师们的福音。Balsamiq作为一款静态的线框图工具凭借素描的风格收复了不少用户。虽然近几年版本之间的改动并不是很大，但仍然有着坚实的用户基础。Mockplus作为行业新秀，不仅传承了素描风格，同时加入了写实的线框图，满足更多人的需求。</p> \n <p><img alt=\"\" height=\"600\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/4e948925-3486-4942-a07d-03e6c3f2608e.png\" width=\"800\"></p> \n <p>交互设计阶段：Axure、Justinmind、<a href=\"https://www.mockplus.cn/\" rel=\"nofollow\">Mockplus</a>、UXPin</p> \n <p>线框图的设计告一段落，下一步就是为它们添加交互动作。交互，作为程序运行中影响用户体验的关键因素，一点也马虎不得。产业初期并没有专业设计师的时候，很多程序员同事担当起了原型设计的重任，也正是因为如此，Axure和FramerJS之类的在原型设计领域大行其道。然而，如今的产品迭代速度之快使得在原型设计过程中根本没有时间去写代码，敏捷开发已经呼啸而来。而且随着专业设计师人数的逐年增加，工具的选择也变得多种多样。比较年轻的、更加轻快的交互设计工具享受了更多的礼遇。Mockplus和UXPin就是比较具有代表性的两款敏捷型交互设计工具。</p> \n <p>Mockplus不只是简单的线框图工具，它通过一种拖拽的操作方式和高度的可视化，把原型设计的复杂程度降到了最低。其中提供的三种交互创建方式和八种测试预览方式确实让人眼前一亮。而UXPin在做好交互设计的同时，其团队成员分享了大量的关于设计思维和设计趋势的书籍，可谓是开卷有益。</p> \n <p><img alt=\"\" height=\"615\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/98c911d6-6d92-47af-8429-aa87147b02e6.jpg\" width=\"927\"></p> \n <p>界面演示阶段：InVision、Flinto、Principle、<a href=\"https://www.chainco.cn/\" rel=\"nofollow\">Chainco</a></p> \n <p>界面演示类工具有一个普遍的共性，那就是它们自身是没有办法产生组件的。这些工具的组件和页面来自其它图像类工具的导出文件，InVision就是一个很好的代表。InVision并没有像Flinto或者Principle那样，与某一款固定的图像处理工具进行捆绑，而是可以上传和导入各种类型的图片以及设计文件。其操作内容主要以热区的设置和页面的跳转。Flinto和Principle则更侧重于页面状态的切换。</p> \n <p><img alt=\"\" height=\"582\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/fb47a91f-999b-4b7d-a3b2-f44ff2afc348.png\" width=\"845\"></p> \n <p>一个程序的各个设计阶段并不是单一的原型设计工具就可以完全覆盖的。根据自己的职责来选择合适的工具，这才是上上之策。</p> \n</div>',NULL,'2020-02-02 19:39:20',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223934280648970240',NULL,NULL,' 看了这三个问题，你就知道UX设计师如何起步  ','<div class=\"content\" id=\"articleContent\"> \n <p>如何成为一个合格的UX设计师，怎样才能从菜鸟转变为设计高手，每天都有无数的设计师思考着同样的问题。凡事要做好，必须得回答这三个问题：做什么？怎么做？用什么做？看了这三个方面的问题，你就应该能够明白如何起步了。为此，笔者收集了一些资源并且做了归纳，希望对你可以有所帮助。</p> \n <p>一、做什么？</p> \n <p>既然是一名UX设计师，那么首先，你要知道什么是UX，以及UX和其它岗位的区别。</p> \n <p><a href=\"http://blog.careerfoundry.com/ui-design/the-difference-between-ux-and-ui-design-a-laymans-guide/\" target=\"_blank\" rel=\"nofollow\">The Difference Between UX and UI Design-A Layman’s Guide</a></p> \n <p>这篇文章中主要讲解了UX和UI的区别，到底什么是UX，什么是UI，作者不仅指出了他们的不同，还做了更进一步的比较。（还有薪资的比较呢。）</p> \n <p><a href=\"http://www.mockplus.com/blog/post/ux-vs-ui-vs-ia-vs-ixd-4-confusing-digital-design-terms-defined?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark-h\" target=\"_blank\" rel=\"nofollow\">UX vs UI vs IA vs IxD : 4 Confusing Digital Design Terms Defined</a></p> \n <p>如果你的疑问不只是关于UX和UI，还对IA和IxD也不明白，那么Becky的这篇文章绝对会帮到你。这里不仅解释了UX、UI、IA、IxD分别所代表的意义，而且还针对工作内容的不同推荐了一些简单实用的工具，可谓是一举两得。</p> \n <p><img alt=\"\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/bea5a784-e62b-4916-a067-1aca6200de86.png\"></p> \n <p>二、怎么做？</p> \n <p>在你从宏观上明白了UX到底是什么，UX设计师的工作内容是什么之后。你需要明白：设计的成败，往往取决于细节。</p> \n <p><a href=\"http://uxmovement.com/buttons/when-to-use-a-switch-or-checkbox/\" rel=\"nofollow\">When to Use a Switch or Checkbox</a></p> \n <p>开关按钮和复选框，似乎看上去功能比较相近，但是实际上他们之间有这很大的区别。举个例子：</p> \n <p>设计中一个简单的选择，看似无伤大雅，实际上却决定着这个设计的可用性和用户体验度。想知道更多关于开关按钮和复选框的事情？赶快打开看看吧。</p> \n <p><a href=\"http://uxmovement.com/mobile/how-to-design-a-walkthrough-that-users-will-read/\" rel=\"nofollow\">How to Design a Walkthrough That Users Will Read</a></p> \n <p>消息满天飞的时候，怎样能够吸引读者的目光？这个问题想必已经困扰了很多的设计师了。来看一下Anthony的做法。</p> \n <p><a href=\"http://usabilitygeek.com/mood-boards-ux-design/\" rel=\"nofollow\">Mood Boards In UX Design: Ignite Passion In Your Users</a></p> \n <p>设计的突破在于创新，在UX设计中使用心情的晴雨板无疑是一个创新的好方法。用这个又去的功能来激活用户心中的热情，也是一个抓住用户的新思维。</p> \n <p><img alt=\"\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/cf9f8718-bdd4-4e2e-a416-9df94fcf4e51.png\"></p> \n <p>三、用什么做？</p> \n <p>1. 工具的选择：</p> \n <p>明确了方法之后，准备行动起来了么？先不要急，工欲善其事必先利其器，选择到适合我们的工具将会使我们的工作更加有效，设计更加符合需求。</p> \n <p>作为UX的设计师，最常使用的工具恐怕就是原型设计工具了，我这里收集了一些关于原型设计工具推荐的文章，我们一起选选看，这里总有一款适合你：</p> \n <p><a href=\"http://www.mockplus.com/blog/post/10-prototyping-tools-recommended-for-uiux-designers?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark\" rel=\"nofollow\">10 Prototyping Tools Recommended For UI/UX Designers</a></p> \n <p>10款设计工具的推荐，而且已经根据难易程度做了等级分类。听上去就很有用。这10款工具可都是作者亲身试用，到底那一款才是他的最爱，这一款又是不是你想要的？</p> \n <p><a href=\"http://www.mockplus.com/blog/post/top-5-desktop-website-based-prototyping-tools?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark-j\" rel=\"nofollow\">Top 5 Desktop &amp; Website Based Prototyping Tools</a></p> \n <p>桌面端和网页端排名前五的基础原型设计工具，入门选手工作设计必备之选。</p> \n <p><img alt=\"\" height=\"519\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/86bccac9-7016-4f4b-b8c5-9d15ad29540d.png\" width=\"960\"></p> \n <p>2. 素材的收集</p> \n <p>设计中只靠自己是不行的，你需要搜集大量的素材。在你觉得现在的设计样式需要改进的时候，看下这些文章吧，它们会提供给你灵感的来源。</p> \n <p><a href=\"http://www.mockplus.com/blog/post/7-ways-to-get-vector-icons-for-uxui-design?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark\" target=\"_blank\" rel=\"nofollow\">7 Ways to Get Vector Icons For UX/UI Design</a></p> \n <p>UX/UI的设计需要大量的矢量图标，尤其是在原型设计的过程中，矢量图标显得尤为重要。那么这么好的矢量图标，要到哪里去找？Mark向你推荐7个能找到矢量图标的地方。</p> \n <p><a href=\"http://www.mockplus.com/blog/post/12-free-ui-kits-ux-design-resources-collection-for-2016?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark-d\" target=\"_blank\" rel=\"nofollow\">12+ Free UI Kits &amp; UX Design Resources Collection</a></p> \n <p>有一个中国成语“照猫画虎”，那么，如果你的模特是老虎呢？我想你一定能画出逼真的威风凛凛的老虎来了。12个免费UI Kit的收集，把“老虎们”带到你面前，让它们成为你临摹的好标版。</p> \n <p><a href=\"http://www.mockplus.com/blog/post/the-best-uiux-design-books-resources-for-designers?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark-j\" rel=\"nofollow\">The Best UI/UX Design Books &amp; Resources for Designers</a></p> \n <p>每天都泡在网络上，回归到书籍的怀抱才是我想要的，这里有一些关于UX/UI设计的书籍，让你在业余时间充电满分。</p> \n <p><img alt=\"\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/16f33448-387a-42f3-aba6-2b9e4df964f7.png\"></p> \n <p>3. 原型的测试</p> \n <p>完成了设计之后，接下来要怎么办呢？我来告诉你吧，下一步，你需要对你的原型设计做测试了。</p> \n <p><a href=\"http://www.mockplus.com/blog/post/how-to-test-the-usability-of-your-prototypes-on-mobile-and-desktop-devices?utm_source=promote&amp;utm_medium=click&amp;utm_campaign=mark-d\" target=\"_blank\" rel=\"nofollow\">How to Test the Usability of Your Prototypes on Mobile and Desktop Devices?</a></p> \n <p>现在的应用很多都是包括了桌面端和移动端两个部分，那么如果对这两个部分进行可用性的测试？Berry在这里详细的讲解了测试的每一步。快来看看吧。</p> \n <p><a href=\"http://doc.mockplus.cn/?p=1323\" rel=\"nofollow\">Mockplus Rapid Prototyping Tutorial - Test Your Prototype in 8 Different Ways</a></p> \n <p><a href=\"https://www.mockplus.cn/\" rel=\"nofollow\">Mockplus</a>是原型设计工具领域的后起之秀，但是这位后起之秀在测试预览功能上已经做到了行业前列，8种不同的预览方式，总有一种是你需要的。</p> \n <p><img alt=\"\" height=\"491\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/a7f6f248-0cdb-4508-b3fb-3b32281a8bb4.png\" width=\"960\"></p> \n <p>怎么样？有没有得到一点启发？希望看过之后你可以在UX设计上有所创新和突破。</p> \n</div>',NULL,'2020-02-02 19:40:47',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223934637382914048',NULL,NULL,' 使用Mockplus的九大理由  ','<div class=\"content\" id=\"articleContent\"> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><strong><strong><strong>简洁高效，是它的主要产品特点。</strong></strong><strong></strong></strong></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; display: inline !important; background: 0px 0px rgb(255, 255, 255);\"><strong><strong>关注设计，而非工具，是它带给设计人员的理念。</strong></strong></p> \n <p><strong><br></strong></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><strong>1.不为工具所累，关注设计而不是工具</strong><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">Mockplus超级简单，但是功能够用。你根本不用专门学习如何使用。记住：工具毕竟是工具，工具只是辅助你的工作，不要让工具左右你的工作，让工具成为你的负担。真正的剑客，剑只是攻防武器，厉害的是对剑道的领悟。了解了这一点，你会发现你不是道编程的笨鸟，也不是软件使用手册的奴隶，你有的是创意，你会爱上你自己。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>2.项目经理和技术知道你要做什么东西了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">拿着设计的原型，给项目经理和技术讲解，人家一眼就能看明白你要做什么东西了。附上简单的说明，人家就能拿你的原型图做开发了。这样一样，项目经理和技术都会爱上你的，因为他们再也不需要被大篇幅的文字和产品经理啰嗦的讲解折磨了。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>3.开发和测试看需求不那么费劲了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">带有交互和说明的原型，可以直接指导技术进行开发，同时也可以指导测试编写测试用例和进行测试指导了。这样一来，开发和测试也会爱上你了的。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>&nbsp;4.UE、UI知道怎么设计你的产品了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">模块齐全、带有交互的原型设计，已经给出了产品前端展示的面貌，UE知道怎么在现有体验设计上怎么改进和优化了，UI知道怎么发挥想象力进行交互了。UE、UI也会爱上你的。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>5.领导知道你的想法，更好做评估和立项了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">当你想做一个产品或功能时，直接拿出原型给领导演示，直观有效的让领导评估是否可行。这比ppt讲解、word说明、邮件交流直观易懂多了，领导很快就能知道你要做的东西，并评估你的想法是否可行。这种方式，可能你老板也会爱上你哟。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>6.你可以通过共享的方式和同事一起设计产品了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"></span></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">如果较为复杂的产品，需要多人来协作进行产品设计，Mockplus也能帮到你。Mockplus一大重要功能就是项目共享，使得同事间可以同步工作，并保留所有工作历史，并可以随时导出历史版本的项目文档。看吧，你同事也会爱上你的。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>7.你可以拿着产品原型找投资人了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">创业者拿着厚厚的商业计划书，需要在几分钟甚至几十秒内打动投资者，是不是很难。如果辅以你的产品原型，直接演示给投资者看，是不是更生动、更能吸引投资人的关注呢。把项目说明白，投资人也会爱上你的。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>8.你可以拿着广告方案找客户签单了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">卖创意、卖方案给广告主，拿着厚厚的文档和别人的案例，是不是难以让广告主签单。如果你拿出已经做好的方案原型，演示给你的广告主，应该能取到别样的效果。这不，你的客户也会爱上你的。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><span style=\"border: 0px; font-size: 15px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline; line-height: 1.45em; background: 0px 0px;\"><strong>9.你个人看起来很帅了</strong></span><br></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">通过高效试用原型工具Mockplus，大大提高高中效率，提高自己的产能，证明自己的能力。这样一来，你自己都会爱上自己的，每天被自己帅醒，然后每天都信心满满的上班去。</p> \n <p><br></p> \n</div>',NULL,'2020-02-02 19:42:12',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223934994964107264',NULL,NULL,' JVM学习总结二——垃圾回收算法  ','<div class=\"content\" id=\"articleContent\"> \n <span style=\"font-size:14px;\">&nbsp; &nbsp; 昨天总结了JVM内存分区相关的知识，这次我们将来了解下JVM的另一个核心知识点——垃圾回收算法。这一部分其实并不太难，如果对操作系统的内存处理算法有所了解，那么这部分算法其实只看名字就能明白，两者在原理上是一样的，而且JVM的相对更为简单点。</span> \n <br> \n <p> <span style=\"font-size:14px;\">&nbsp; &nbsp; 在初学JVM的时候，我们往往会对这部分感到迷惑：网上不少博客介绍的五花八门，像引用计数算法、串行、并行、并发算法等，他们到底算不算垃圾回收算法，算的话又和基本的那几个算法有什么关系呢？（PS：其实如果认真看过书的话，就不会疑惑了，因为书里边介绍的很清晰），下边我们来理一下这些算法的关系：</span> </p> \n <ul> \n  <li> <span style=\"line-height:1.5;font-size:14px;\"><strong><span style=\"color:#003399;\">对象存活判断算法</span></strong>：引用计数、可达性分析</span> </li> \n  <li> <span style=\"line-height:1.5;font-size:14px;\"><strong><span style=\"color:#003399;\">基本的垃圾回收算法</span></strong>：标记-清除、复制、标记-整理</span> </li> \n  <li> <span style=\"line-height:1.5;font-size:14px;\"><strong><span style=\"color:#003399;\">依赖线程实现的回收算法</span></strong>：串行、并行、并发</span> </li> \n </ul> \n <span></span> \n <span style=\"font-size:14px;\">&nbsp; &nbsp; 其中对象存活判定算法是其他算法的基石，用来判断对象是否存活，能否回收；基本的垃圾回收算法是垃圾垃圾收集器实现的基础算法；而依赖线程实现的算法，则是基本算法在考虑线程环境下的运用，这个有多线程基础的看名字就明白了。此外，还有综合以上算法并从特定角度实现的算法，如分代回收（针对分区）、增量回收（针对实时性）等，在此不再介绍</span> \n <span style=\"font-size:14px;\">。</span> \n <h1> <span style=\"font-size:16px;color:#E53333;\">一、</span><span style=\"font-size:16px;color:#E53333;\">对象存活判断算法</span> </h1> \n <p> <span style=\"font-size:14px;\">&nbsp;</span><span style=\"font-size:14px;\"> &nbsp;在我们回收一个对象之前，我们首先要搞明白的一点是</span><span style=\"font-size:14px;\">这个对象是不是已经死了（没有用了），而对于java程序而言，当一个对象不再被引用，那么他就死了（没被引用就无法被正常访问了）。为实现这个判断，可以使用两种算法实现：</span><strong><span style=\"color:#003399;font-size:14px;\">引用计数</span></strong><span style=\"font-size:14px;\">和</span><strong><span style=\"color:#003399;font-size:14px;\">可达性分析</span></strong><span style=\"font-size:14px;\">。</span><br> <span style=\"font-size:14px;\">&nbsp; &nbsp; </span><strong><span style=\"color:#003399;font-size:14px;\">引用计数</span></strong><span style=\"font-size:14px;\">实现计较简单，每个对象对应一个引用计数器，当有被引用的时候就+1，引用被释放的时候-1，这样当该值为0时，则对象已死。这一算法有个问题就是：当出现相互引用（类似于多线程死锁的情况）的时候，对象虽死，但是计数器却不为0。</span><br> <span style=\"font-size:14px;\">&nbsp; &nbsp; </span><strong><span style=\"color:#003399;font-size:14px;\">可达性分析</span></strong><span style=\"font-size:14px;\">也叫<span style=\"background-color:#FFFFFF;\">做</span></span><span style=\"font-size:14px;line-height:20px;background-color:#FFFFFF;\">根节点搜索算法，其实现是根据图的搜索（当然，图的搜索其实就是树遍历），JVM首先创建一个GC Root的根节点，所有创建的对象在存活的时候都能根据引用关系找到到达</span><span style=\"font-size:14px;\"><span style=\"background-color:#FFFFFF;\"></span>该根节点的路径，如果找不到路径，则说明该对象已死。这一算法不仅解决了引用计数的缺陷，而且不用每一对象都维护一个计数器，目前最常用的HotSpot虚拟机就采用该算法。</span> </p> \n <h1> <span style=\"color:#E53333;font-size:16px;\">二、基本</span><span style=\"color:#E53333;font-size:16px;\">垃圾回收算法</span> </h1> \n <p> &nbsp;<span style=\"font-size:14px;\">&nbsp;</span><span style=\"font-size:14px;\"><span style=\"font-size:14px;\">&nbsp;&nbsp;</span></span><span style=\"font-size:14px;\">所谓算法，就是在时间、空间、实现复杂度这三者的互博中寻求一个最优的实现。而几种垃圾回收算法也是在这几个方面各有侧重。</span><br> <span style=\"font-size:14px;\">&nbsp; &nbsp; </span><strong><span style=\"font-size:14px;color:#003399;\">标记-清除算法</span></strong><span style=\"font-size:14px;\">分为两个阶段：先对回收对象进行标记，然后统一回收。这种思路很简单，实现也很容易，但是却头两个缺点：一是标记、清除效率都很低，二是会产生碎片化，清除后空出来的空间是零散的。</span><br> <span style=\"font-size:14px;\">&nbsp; &nbsp; </span><strong><span style=\"font-size:14px;color:#003399;\">复制算法</span></strong><span style=\"font-size:14px;\">是将内存空间分为两个部分，对象同时只存在其中一个里边，当回收时将存活对象复制到另一区即可，这样就不用再进行清除了（直接覆盖即可），还不会产生生碎片。之前提到分代回收中Eden去的s</span><span style=\"color:#333333;line-height:21px;background-color:#FFFFFF;\"><span style=\"font-size:14px;\">urvivor便使用该算法。但是该算法缺点也很明显，有一半空间浪费了，典型的空间换时间。</span><br> </span><span style=\"font-size:14px;\">&nbsp; &nbsp; </span><strong><span style=\"font-size:14px;color:#003399;\">标记-整理算法</span></strong><strong><span style=\"font-size:14px;color:#003399;\"></span></strong><span style=\"font-size:14px;\">是</span><span><span style=\"font-size:14px;\">标记-清除的升级版，上边说到，清理过程也是效率很低的，那么该算法第二步就不进行清理，而是将对象向前移动，覆盖该回收的区域，这样整理后就不会产生碎片了。年老代一般采用该算法。</span><br> </span><span style=\"font-size:14px;\">&nbsp; &nbsp; 该部分可</span><a href=\"http://blog.csdn.net/java2000_wl/article/details/8022293\" target=\"_blank\" rel=\"nofollow\"><span style=\"font-size:14px;\">参考</span></a><span style=\"font-size:14px;\">。</span> </p> \n <h1> <span><span style=\"font-size:16px;color:#E53333;\">三、</span><span style=\"font-size:16px;color:#E53333;\">串行、并行、并发</span><span style=\"font-size:16px;color:#E53333;\">垃圾回收器</span></span> </h1> \n <p> <span><span style=\"color:#000000;font-size:14px;\">&nbsp; &nbsp;</span><span style=\"font-size:14px;color:#000000;\"> 首先我们要提到一点是，垃圾回收由于涉及对内存的整理，要求整理时内存状态是不能被程序改变的，也就是Stop-The-World模式下进行。当gc时间过长时，程序会出现长时间停顿，这对于响应较高的应用是不可接受的。因此，在结合线程后实现了不同方式的收集器，以满足不同需求。</span><br> </span> </p> \n <ul> \n  <li> <strong><span style=\"color:#000000;font-size:14px;\"><span style=\"color:#003399;font-family:\'Microsoft YaHei\';\">串行收集</span><span style=\"font-family:\'Microsoft YaHei\';\">:</span></span></strong><span style=\"line-height:1.5;\"><span style=\"font-size:14px;color:#000000;font-family:\'Microsoft YaHei\';\">串行收集使用单线程处理所有垃圾回收工作，因为无需多线程交互，实现容易，而且效率比较高。但是，其局限性也比较明显，即无法使用多处理器的优势，所以此收集适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。一般</span><span style=\"color:#000000;line-height:23px;background-color:#FFFFFF;font-size:14px;\"><span style=\"font-family:\'Microsoft YaHei\';\">只能用于小型应用</span><span style=\"font-family:\'Microsoft YaHei\';\">。</span></span><span style=\"font-size:14px;color:#000000;font-family:\'Microsoft YaHei\';\"></span></span> </li> \n  <li> <strong><span style=\"color:#000000;font-size:14px;\"><span style=\"color:#003399;font-family:\'Microsoft YaHei\';\">并行收集</span><span style=\"font-family:Microsoft YaHei;\">:</span></span></strong><span style=\"line-height:1.5;\"><span style=\"font-size:14px;color:#000000;font-family:\'Microsoft YaHei\';\">并行收集使用多线程处理垃圾回收工作，因而速度快，效率高。而且理论上CPU数目越多，越能体现出并行收集器的优势。</span><span style=\"color:#000000;line-height:23px;background-color:#FFFFFF;font-size:14px;font-family:\'Microsoft YaHei\';\">&nbsp;适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。</span><span style=\"font-size:14px;color:#000000;font-family:\'Microsoft YaHei\';\"></span></span> </li> \n  <li> <span style=\"line-height:1.5;color:#000000;font-size:14px;\"><strong><span style=\"color:#003399;font-family:\'Microsoft YaHei\';\">并发收集</span><span style=\"font-family:Microsoft YaHei;\">:</span></strong></span><span style=\"line-height:1.5;\"><span style=\"font-size:14px;color:#000000;font-family:\'Microsoft YaHei\';\">相对于串行收集和并行收集而言，前面两个在进行垃圾回收工作时，需要暂停整个运行环境，而只有垃圾回收程序在运行，因此，系统在垃圾回收时会有明显的暂停，而且暂停时间会因为堆越大而越长。</span><span style=\"color:#000000;line-height:23px;background-color:#FFFFFF;font-size:14px;font-family:\'Microsoft YaHei\';\">适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。</span><span style=\"font-size:14px;color:#000000;font-family:\'Microsoft YaHei\';\"></span></span> </li> \n </ul> \n <span style=\"font-size:14px;color:#000000;\"></span> \n <span style=\"font-size:14px;color:#000000;\">&nbsp; &nbsp; 此外还要提到的一点是，因为不同系统、不同JVM对于线程的处理不同，所以这几个算法的的实现都是依赖于垃圾收集器的实现的，我们可以通过JVM参数来指定不同收集器进行处理。</span> \n <p> <span><span style=\"font-size:14px;color:#000000;\">&nbsp; &nbsp; 本次JVM相关算法介绍完毕，下次将重点放在JVM监控、调优等方面，由于个人没有太多实践经验，这部分主要会整理相关资料。</span><span style=\"color:#000000;font-size:14px;\">&nbsp;&nbsp;&nbsp;&nbsp;</span></span><span></span><span></span> </p> \n <p> <br> </p> \n <p> <span></span> </p> \n</div>',NULL,'2020-02-02 19:43:37',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223935363257552896',NULL,NULL,' 10个完全免费的网页原型（线框图）工具  ','<div class=\"content\" id=\"articleContent\"> \n <p>网页的线框图是非常直观、但是也没什么技术上难点的东西。只需要你大概描出页面上需要的一些元素，比如头部、导航、页脚等等，最多再就是一些交互、内容区域什么的。<br> 但这对于任何网络应用的开发都是非常重要的。<br> 当然有很多种方法可以做这件事情，最简单的就是拿起纸和笔，但是在这篇文章中，我们要介绍的是一些非常高效好用的在线原型工具，并且他们完全免费。</p> \n <h3><a href=\"http://www.lumzy.com/\">Lumzy</a> 快速原型工具</h3> \n <p>使用Lumzy你可以为你的应用创建原型图，还能添加一些交互事件。有了它，你可以创建弹出框，交互的页面导航，添加外部链接等等。他对于团队协作设计和交流提供了一个很好的平台，而且他完全免费。<br> <a href=\"http://www.lumzy.com/\"><img title=\"Lumzy快速原型工具\" src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_023.jpg\" alt=\"Lumzy快速原型工具\" height=\"306\" width=\"640\"></a></p> \n <h3><a href=\"http://www.mockupbuilder.com/\">Mockup Builder</a> 杀手级的原型工具</h3> \n <p>MockupBuilder最近才发布，很值得期待。他有非常多的功能：UI模型，交互的线框图，页面布局，客户端原型甚至站点地图和屏幕导航。</p> \n <p>当然，对于与客户和团队成员交流也是非常强大的。并且，他全部免费。<br> <a href=\"http://www.mockupbuilder.com/\"><img title=\"Mockup Builder杀手级的原型工具\" src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_b1.jpg\" alt=\"Mockup Builder杀手级的原型工具\" height=\"312\" width=\"640\"></a></p> \n <h3><a href=\"http://gotiggr.com/\">Tiggr</a>协作制作原型图</h3> \n <p>Tiggr的思想是给你需要做成最终稿的所有资源。你可以设计很多的元素，然后分享，其他的协作用户会帮你制作相应HTML/CSS代码，以达到最快生成。花10秒钟注册，你就能享用这个免费的东东了。<br> <a href=\"http://gotiggr.com/\"><img title=\"Tiggr协作原型\" src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_031.jpg\" alt=\"Tiggr协作原型\" height=\"306\" width=\"640\"></a></p> \n <h3><a href=\"http://framebox.org/\">Frame Box</a>轻量级原型在线制作</h3> \n <p>FrameBox并没有多么特别的特色。你可以拖放、设置大小、复制粘贴这些UI组件，但是他的特色在于你可以非常轻松的通过它的拖拽很容易就完成你的原型制作。想要用这个轻量级的免费的工具，也需要注册一下。<br> <a href=\"http://framebox.org/\"><img title=\"Frame Box轻量级原型\" src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_051.jpg\" alt=\"Frame Box轻量级原型\" height=\"306\" width=\"640\"></a></p> \n <h3><a href=\"http://www.simplediagrams.com/free.html\">SimpleDiagrams 免费版</a>(Adobe Air App)</h3> \n <p>simplediagrams是一个非常小巧的Adobe Air程序，通过他你可以非常轻松的实现自己的想法。拖拽组件，添加图片或者便签，导出PNG图都是他的特色，通过添加一些小功能就能实现一个非常不错的原型图。<br> <a href=\"http://www.simplediagrams.com/free.html\"><img title=\"SimpleDiagrams\" src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_081.jpg\" alt=\"SimpleDiagrams\" height=\"299\" width=\"640\"></a></p> \n <h3><a href=\"http://iphonemockup.lkmc.ch/\">iPhone Mockup</a>iPhone原型制作</h3> \n <p>在iPhone Mockup里面你可以使用铅笔模式，也可以使用图表模式的编辑器。不管你选择什么，功能都是一样的，都可以很简单很方便的生成iPhone上的应用原型。你也可以分享给别人，就算你更改了设计，别人通过那个链接也一样可以看到。<br> <a href=\"http://iphonemockup.lkmc.ch/\"><img src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_091.jpg\" alt=\"iPhone Mockup\" title=\"iPhone Mockup\" height=\"299\" width=\"640\"></a></p> \n <h3><a href=\"http://www.fluidia.org/\">fluidIA</a></h3> \n <p>fluidIA是一个在线的但是可以下载的富用户界面原型设计工具。它基于面向对象的理念，可以让你快速完善。它设计的基本思想是团队中的任何成 员，无论是设计师还是工程师都可以自由的设计自己的原型。最近fluidIA的更新稍微慢了点，但是它仍是一个非常优秀的线框图工具。<br> <a href=\"http://www.fluidia.org/\"><img src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_111.jpg\" alt=\"fluidIA\" title=\"fluidIA\" height=\"299\" width=\"640\"></a></p> \n <h3><a href=\"http://pencil.evolus.vn/en-US/Home.aspx\">Pencil Project</a>FireFox插件</h3> \n <p>Pencil Project是一个原型界面设计的Firefox插件，通过它内置的模板，你可以创建可链接的文档，并输出成为HTML文件、PNG、OpenOffice文档、Word文档、PDF。还有什么可说的呢？这么优秀的插件，是每个设计师和开发人员必备啊。<br> <a href=\"http://pencil.evolus.vn/en-US/Home.aspx\"><img src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_141.jpg\" alt=\"Pencil Project Editor Screenshot\" title=\"Pencil Project Editor Screenshot\" height=\"299\" width=\"640\"></a></p> \n <h3><a href=\"http://cogtool.hcii.cs.cmu.edu/\">CogTool</a>Win MAC下应用程序</h3> \n <p>CogTool是一个强大原型生成工具，他与别的工具还有一些不同，他可以对你的设计自动根据人类认知模型进行评估。你可以通过一些图标啊按钮啊图 片，生成一个描述，然后点击评估的按钮，他就会对你的设计进行人类认知模型的评估，他会告诉你一般人需要多久才能理解你的意图。CogTools有很多用 户引导的文档，还有很多教程，论坛上也能让你很快的成长起来。<br> <a href=\"http://cogtool.hcii.cs.cmu.edu/\"><img src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_171.jpg\" alt=\"CogTool\" title=\"CogTool\" height=\"299\" width=\"640\"></a></p> \n <h3><a href=\"http://www.serena.com/products/prototype-composer/index.html\">Prototype Composer</a></h3> \n <p>Prototype Composer可以让你在真正的代码编写之前就看到网站是如何运行的。以前的那些无数的文字入口，复杂的数据结构以及技术含量不低的UML图，这个工具可以让你很方便的协作完成一个看起来能运行的程序。<br> 社区版本是免费的，他可以让你以用户定义的一个项目做一个样例程序。<br> <a href=\"http://www.serena.com/products/prototype-composer/index.html\"><img src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_182.jpg\" alt=\"Prototype Composer\" title=\"Prototype Composer\" height=\"299\" width=\"640\"></a></p> \n <h3><a href=\"http://dub.washington.edu:2007/denim/\">DUB – DENIM</a>（跨平台应用程序）</h3> \n <p>DENIM是一个跨平台的桌面程序。他自己的介绍是为早期网站设计提供帮助的非正式工具。<br> 他有很多理念来自于纸笔设计原型。你可以快速的画出草图，保证重要的功能优先。但是跟纸笔的草图不同的是，他还可以有交互和动画。<br> <a href=\"http://dub.washington.edu:2007/denim/\"><img src=\"http://rockux.com/wp-content/uploads/2011/02/wireframe_191.jpg\" alt=\"DENIM\" title=\"DENIM\" height=\"283\" width=\"640\"></a></p> \n <p><a href=\"http://speckyboy.com/2011/02/23/10-completely-free-wireframing-and-mockup-tools/\">译文原文</a> </p> \n <br> \n</div>',NULL,'2020-02-02 19:45:05',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223935721455308800',NULL,NULL,' 《深入理解Java虚拟机》学习小记一之自动内存管理机制(二)  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1> 1.概要<br> </h1> \n <p> <span style=\"font-family:SimSun;font-size:16px;\">在</span><a target=\"_blank\" href=\"http://my.oschina.net/linuxfelix/blog/128406\" rel=\"nofollow\"><span style=\"font-family:SimSun;font-size:16px;\">《深入理解Java虚拟机》学习小记一之自动内存管理机制(一)</span></a><span style=\"font-family:SimSun;font-size:16px;\">中，我们罗列了以下几个问题：</span> </p> \n <div> \n  <ol> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">什么操作可能导致内存溢出？</span> </li> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">有哪些种类的内存溢出？</span> </li> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">都是在内存的哪些区域溢出？</span> </li> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">垃圾收集有哪些原则？</span> </li> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">有哪些垃圾收集算法及其实现？</span> </li> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">新生代和老年代的回收策略如何？</span> </li> \n   <li> <span style=\"color:#E53333;font-family:SimSun;font-size:16px;\">各种内存相关的JVM参数是什么意思？</span> </li> \n  </ol> \n </div> \n <span style=\"font-family:SimSun;font-size:16px;\">本文主要总结问题4、问题5和问题7.总体如下：</span> \n <br> \n <img src=\"http://static.oschina.net/uploads/space/2013/0512/093934_Wj42_944787.png\" alt=\"\"> \n <br> \n <span style=\"font-size:16px;\"></span> \n <p> <br> </p> \n <span id=\"OSC_h1_2\"></span> \n <h1> 2.判断对象是否存活的算法<br> </h1> \n <p> <span style=\"font-family:SimSun;font-size:16px;\">常用的判断对象是否存活的算法有两种：一种是引用计数算法，另外一种是根搜索算法。例如Python语言就是使用了引用计数算法进行内存管理的。Java、C#和古老的Lisp等语言使用了根搜索算法判断对象是否存活。下面就算法的思想上介绍这两种算法。</span><br> <span style=\"font-size:16px;\"></span> </p> \n <span id=\"OSC_h2_3\"></span> \n <h2> 2.1引用计数算法<br> </h2> \n <p> <span style=\"font-family:SimSun;font-size:16px;\">引用计数算法最主要的步骤如下描述：</span> </p> \n <ol> \n  <li> <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">给对象中添加一个引用计数器，每当一个地方引用它时，计数器值就加1</span> </li> \n  <li> <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">当引用失效时，计数器值就减1</span> </li> \n  <li> <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">当计数器的值为0时，就判断该对象不能被使用</span> </li> \n </ol> \n <div> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;\"><span style=\"font-size:16px;\">这个算法实现简单，但是很难解决对象之间循环引用</span><span style=\"font-size:16px;\"></span><span style=\"font-size:16px;\">的问题，因此Java并没有使用这种算法来管理内存。</span></span> \n </div> \n <span id=\"OSC_h2_4\"></span> \n <h2> 2.2根搜索算法<br> </h2> \n <div> \n  <div> \n   <span style=\"font-family:SimSun;font-size:16px;\">根搜索算法是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到<span></span>GC Roots没有任何引用链相连时,则证明此对象是不可用的。</span> \n  </div> \n </div> \n <span id=\"OSC_h1_5\"></span> \n <h1> 3.GC算法<br> </h1> \n <span id=\"OSC_h2_6\"></span> \n <h2> 3.1标记-清除（Mark-Sweep）算法<br> </h2> \n <div> \n  <span style=\"color:#000000;font-family:Tahoma;font-style:normal;font-weight:normal;line-height:normal;\"><span style=\"font-family:SimSun;font-size:16px;\">算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。算法示意图如下：</span><img src=\"http://static.oschina.net/uploads/space/2013/0512/095018_DFYb_944787.png\" alt=\"\"><br> \n   <div> \n    <span style=\"color:#000000;font-family:Tahoma;font-style:normal;font-weight:normal;line-height:normal;font-size:medium;\">该算法是最基础的收集算法，后续的搜集算法都是基于这种思路并对其缺点进行改进得到的。</span> \n   </div> <span></span></span> \n </div> \n <span id=\"OSC_h2_7\"></span> \n <h2> 3.2复制（Copying）算法<br> </h2> \n <p> <br> </p> \n <div> \n  <div> \n   <span style=\"font-family:SimSun;font-size:16px;\">为了解决效率问题，复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一快。当这块的内存用完了，就讲还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。算法示意图如下：</span> \n  </div> \n </div> \n <h2> <img src=\"http://static.oschina.net/uploads/space/2013/0512/095112_cNgD_944787.png\" alt=\"\"><span></span> </h2> \n <p> <br> </p> \n <div> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">现在的商业虚拟机都采用这种收集算法来回收新生代。</span> \n </div> \n <p></p> \n <span id=\"OSC_h2_8\"></span> \n <h2> 3.3标记<span></span>-整理（Mark-Compact）算法<br> </h2> \n <p> <br> </p> \n <div> \n  <div> \n   <span style=\"font-family:SimSun;\">复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会很低。因此在老年代一般不能直接使用这种算法。</span> \n  </div> \n  <div> \n   <span style=\"font-family:SimSun;\">为了解决这个问题，标记-整理算法为此诞生。该算法标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，算法示意图如下：</span> \n  </div> \n </div> \n <p></p> \n <h2> \n  <div> \n   <br> \n  </div> <img src=\"http://static.oschina.net/uploads/space/2013/0512/095308_eRXA_944787.png\" alt=\"\"><br> </h2> \n <h2> </h2> \n <span id=\"OSC_h2_9\"></span> \n <h2> 3.4分代收集算法<br> </h2> \n <p> <br> </p> \n <div> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">当前商业虚拟机的垃圾收集都采用分代收集算法，该算法只是根据对象的存活周期不同将内存划分为几块。一般将Java堆划分为新生代和老年代。新生代一般采用复制算法，老年代一般采用标记-清除算法或标记-整理算法。</span> \n </div> \n <p></p> \n <span id=\"OSC_h2_10\"></span> \n <h2> 3.5几种算法的优缺点 </h2> \n <h2> <img src=\"http://static.oschina.net/uploads/space/2013/0512/095924_OgO4_944787.png\" alt=\"\"><br> </h2> \n <span id=\"OSC_h1_11\"></span> \n <h1> 4.垃圾收集器<br> </h1> \n <p> <span style=\"font-family:SimSun;font-size:16px;\">关于垃圾收集器的知识在这里不做介绍，有兴趣的可以参考</span><a target=\"_blank\" href=\"http://book.51cto.com/art/201107/278913.htm\" rel=\"nofollow\"><span style=\"font-family:SimSun;font-size:16px;\">http://book.51cto.com/art/201107/278913.htm</span></a> </p> \n <span id=\"OSC_h1_12\"></span> \n <h1> 5.垃圾收集器的参数总结<br> <img src=\"http://static.oschina.net/uploads/img/201305/12100355_5vQf.jpg\" title=\"垃圾收集器参数总结\" alt=\"垃圾收集器参数总结\"><br> 6.关于GC的几点补充<br> </h1> \n <div> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">经过上述的说明，可以发现垃圾回收有以下的几个特点：</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 1.垃圾收集发生的不可预知性：由于实现了不同的垃圾收集算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。</span> \n  <br> \n  <br> \n  <p> <span style=\"color:#000000;font-family:Tahoma;font-style:normal;font-weight:normal;line-height:normal;font-size:medium;\"><span style=\"font-family:SimSun;font-size:16px;\">&nbsp; 2.垃圾收集的精确性：主要包括2 个方面：</span><br> <span style=\"font-family:SimSun;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"font-family:SimSun;font-size:16px;\">a.垃圾收集器能够精确标记活着的对象；</span><br> <span style=\"font-family:SimSun;font-size:16px;\">&nbsp;&nbsp;&nbsp;&nbsp;</span><span style=\"font-family:SimSun;font-size:16px;\">b.垃圾收集器能够精确地定位对象之间的引用关系。</span><br> <span style=\"font-family:SimSun;font-size:16px;\">前者是完全地回收所有废弃对象的前提，否则就可能造成内存泄漏。而后者则是实现归并和复制等算法的必要条件。所有不可达对象都能够可靠地得到回收，所有对象都能够重新分配，允许对象的复制和对象内存的缩并，这样就有效地防止内存的支离破碎。</span></span> </p> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 3.现在有许多种不同的垃圾收集器，每种有其算法且其表现各异，既有当垃圾收集开始时就停止应用程序的运行，又有当垃圾收集开始时也允许应用程序的线程运行，还有在同一时间垃圾收集多线程运行。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 4.垃圾收集的实现和具体的JVM 以及JVM的内存模型有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集。现在，HotSpot 系列JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 5.随着技术的发展，现代垃圾收集技术提供许多可选的垃圾收集器，而且在配置每种收集器的时候又可以设置不同的参数，这就使得根据不同的应用环境获得最优的应用性能成为可能。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 针对以上特点，我们在使用的时候要注意：</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 1.不要试图去假定垃圾收集发生的时间，这一切都是未知的。比如，方法中的一个临时对象在方法调用完毕后就变成了无用对象，这个时候它的内存就可以被释放。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 2.Java中提供了一些和垃圾收集打交道的类，而且提供了一种强行执行垃圾收集的方法--调用System.gc()，但这同样是个不确定的方法。Java 中并不保证每次调用该方法就一定能够启动垃圾收集，它只不过会向JVM发出这样一个申请，到底是否真正执行垃圾收集，一切都是个未知数。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 3.挑选适合自己的垃圾收集器。一般来说，如果系统没有特殊和苛刻的性能要求，可以采用JVM的缺省选项。否则可以考虑使用有针对性的垃圾收集器，比如增量收集器就比较适合实时性要求较高的系统之中。系统具有较高的配置，有比较多的闲置资源，可以考虑使用并行标记/清除收集器。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 4.关键的也是难把握的问题是内存泄漏。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。</span> \n  <br> \n  <br> \n  <span style=\"color:#000000;font-family:SimSun;font-style:normal;font-weight:normal;line-height:normal;font-size:16px;\">&nbsp; 5.尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果有，则要去掉监听器，然后再赋空值。</span> \n </div> --------------------------------------------------全文完--------------------------------------- \n <br> 摘至 \n <a target=\"_blank\" href=\"http://book.douban.com/subject/6522893/\" rel=\"nofollow\">《深入理解Java虚拟机》</a> \n</div>',NULL,'2020-02-02 19:46:30',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1223936078793232384',NULL,NULL,' 《大型网站技术架构——核心原理与案例分析》目录  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1><strong><span style=\"color:#2980b9\">第1篇：概述</span></strong></h1> \n <p>&nbsp; &nbsp; <a href=\"https://my.oschina.net/lienson/blog/3011339\" target=\"_blank\" rel=\"nofollow\">第1章：大型网站架构演化</a></p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第2章：大型网站架构模式</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第3章：大型网站核心架构要素</p> \n <span id=\"OSC_h1_2\"></span> \n <h1><strong><span style=\"color:#2980b9\">第2篇：架构</span></strong></h1> \n <p>&nbsp; &nbsp; 第4章：瞬时响应：网站的高性能架构</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第5章：万无一失：网站的高可用架构</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第6章：永无止境：网站的伸缩性架构</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第7章：随需应变：网站的可扩展架构</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第8章：固若金汤：网站的安全架构</p> \n <span id=\"OSC_h1_3\"></span> \n <h1><strong><span style=\"color:#2980b9\">第3篇：案例</span></strong></h1> \n <p>&nbsp; &nbsp; 第9章：淘宝网的架构演化案例分析</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第10章：维基百科的高性能架构设计分析</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第11章：海量分布式存储系统Doris的高可用架构设计分析</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第12章：网购秒杀系统架构设计案例分析</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第13章：大型网站典型故障案例分析</p> \n <span id=\"OSC_h1_4\"></span> \n <h1><strong><span style=\"color:#2980b9\">第4篇：架构师</span></strong></h1> \n <p>&nbsp; &nbsp; 第14章：架构师领导艺术</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第15章：网站架构师职场攻略</p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;第16章：漫话网站架构师</p> \n</div>',NULL,'2020-02-02 19:47:55',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226400134452051968',NULL,NULL,' 《良质！PHP企业级系统开发》- PDF抢鲜版，附全书高清脑图   ','<div class=\"content\" id=\"articleContent\"> \n <p><img alt=\"\" height=\"862\" src=\"https://oscimg.oschina.net/oscnet/9509b1303f5e681bdcc1d78cf9936747bef.jpg\" width=\"600\"></p> \n <p>&nbsp;</p> \n <p><span style=\"color:#e74c3c\"><strong>百度网盘链接: <a href=\"https://pan.baidu.com/s/1J47O2F8PiMG4APp1lbVqiQ\" target=\"_blank\" rel=\"nofollow\">https://pan.baidu.com/s/1J47O2F8PiMG4APp1lbVqiQ</a> </strong></span></p> \n <p><span style=\"color:#e74c3c\"><strong>提取码: t22h</strong></span></p> \n <p><span style=\"color:#e74c3c\"><strong><img alt=\"\" height=\"276\" src=\"https://oscimg.oschina.net/oscnet/be77589f77dbdcdae523ad4a0a5b3a7cc5a.jpg\" width=\"678\"></strong></span></p> \n <p>&nbsp;</p> \n <p><strong>推荐序</strong></p> \n <p>你是否对PHP又爱又恨？是否在为PHP架构瓶颈发愁？我们都曾有同感，PHP强大的易用性受人爱戴，但也带来一系列麻烦，特别是业务高速发展阶段猝不及防的高流量、高并发、大数据状况，质量、性能、效率等奇葩问题涌现。<br> <br> 本书《良质！》，正是一个为了解决以上问题而生的企业级解决方案，作者亲身经历了整个过程，以顶尖互联网公司中核心工程师身份，负责面向用户项目的核心研发工作，期间业务及流量短时期数十倍井喷增长，性能压力巨大，质量要求倍增，危机重重，作者砥砺前行，以PHP切入到整体架构设计，对每个事件深入分析，从故障回顾到问题预判，形成无数最佳实践，精华心血汇集于本书，为开发者提供了一个高起点的『巨人肩膀』，为公司中长期技术发展提供了清晰的路径。<br> <br> 相信读者一定眼前一亮，推荐大家在业务中加以实践，必将事半功倍！</p> \n <p>&nbsp;</p> \n <p><strong>全书目录</strong></p> \n <p>&nbsp;&nbsp;&nbsp; 推荐序<br> &nbsp;&nbsp;&nbsp; 前言<br> &nbsp;&nbsp;&nbsp; 献辞<br> &nbsp;&nbsp;&nbsp; 第一部分 重新定义项目开发<br> &nbsp;&nbsp;&nbsp; 第 1 章 软件开发本质论<br> &nbsp;&nbsp;&nbsp; 第 2 章 选择高起点<br> &nbsp;&nbsp;&nbsp; 第 3 章 向世界发布你的代码<br> &nbsp;&nbsp;&nbsp; 第二部分 PHP高级编程<br> &nbsp;&nbsp;&nbsp; 第 4 章 回归原生态<br> &nbsp;&nbsp;&nbsp; 第 5 章 PHPUnit单元测试新解<br> &nbsp;&nbsp;&nbsp; 第三部分 PHP企业级系统开发<br> &nbsp;&nbsp;&nbsp; 第 6 章 核心基础模块设计<br> &nbsp;&nbsp;&nbsp; 第 7 章 大型网站开发范式<br> &nbsp;&nbsp;&nbsp; 第 8 章 高可用接口服务系统<br> &nbsp;&nbsp;&nbsp; 第 9 章 极致的管理后台系统<br> &nbsp;&nbsp;&nbsp; 第 10 章 深藏不露的计划任务系统<br> &nbsp;&nbsp;&nbsp; 第四部分 追求卓越<br> &nbsp;&nbsp;&nbsp; 第 11 章 如何成为明星员工<br> &nbsp;&nbsp;&nbsp; 第 12 章 赢在角色转换<br> &nbsp;&nbsp;&nbsp; 致谢</p> \n</div>',NULL,'2020-02-09 14:59:11',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226400358029426688',NULL,NULL,' 【我的新书】《良质！PHP企业级系统开发》- 图灵社区  ','<div class=\"content\" id=\"articleContent\"> \n <p><strong>前言</strong></p> \n <p>今年，花了近一年的时间编写了我的第二本书《良质！PHP企业级系统开发》，发表在图灵社区。</p> \n <p>感兴趣的，可前往图灵社区阅读：<a href=\"http://www.ituring.com.cn/book/2664\" rel=\"nofollow\"><strong>http://www.ituring.com.cn/book/2664</strong></a></p> \n <p>&nbsp;</p> \n <p><a href=\"http://www.ituring.com.cn/book/2664\" rel=\"nofollow\"><img alt=\"\" height=\"583\" src=\"https://oscimg.oschina.net/oscnet/27644ebfaa22d91cd93d0d5f5cc41003398.jpg\" width=\"642\"></a></p> \n <p>目录<br> 前言 &nbsp;&nbsp; &nbsp;<br> 献辞 &nbsp;&nbsp; &nbsp;<br> 第一部分 重新定义项目开发 &nbsp;&nbsp; &nbsp;<br> 第 1 章 软件开发本质论 &nbsp;&nbsp; &nbsp;<br> 第 2 章 选择高起点 &nbsp;&nbsp; &nbsp;<br> 第 3 章 向世界发布你的代码 &nbsp;&nbsp; &nbsp;<br> 第二部分 PHP高级编程 &nbsp;&nbsp; &nbsp;<br> 第 4 章 回归原生态 &nbsp;&nbsp; &nbsp;<br> 第 5 章 PHPUnit单元测试新解 &nbsp;&nbsp; &nbsp;<br> 第三部分 PHP企业级系统开发 &nbsp;&nbsp; &nbsp;<br> 第 6 章 核心基础模块设计 &nbsp;&nbsp; &nbsp;<br> 第 7 章 大型网站开发范式 &nbsp;&nbsp; &nbsp;<br> 第 8 章 高可用接口服务系统 &nbsp;&nbsp; &nbsp;<br> 第 9 章 极致的管理后台系统 &nbsp;&nbsp; &nbsp;<br> 第 10 章 深藏不露的计划任务系统 &nbsp;&nbsp; &nbsp;<br> 第四部分 追求卓越 &nbsp;&nbsp; &nbsp;<br> 第 11 章 如何成为明星员工 &nbsp;&nbsp; &nbsp;<br> 第 12 章 赢在角色转换 &nbsp;&nbsp; &nbsp;<br> 致谢 &nbsp;&nbsp;&nbsp;</p> \n <span id=\"OSC_h3_1\"></span> \n <h3><strong>本书特色</strong></h3> \n <p>本书主要侧重点在于企业级系统的开发，注意这里指的是企业级，意味着是有一定规模并且是具备商业价值的，而不是单纯教学式的示例。此外，我们着重讨论的是系统开发，这里不仅包括网站系统的开发，还包括微服务、接口系统、定时任务系统的开发。除了探讨如何增强对系统整体性的把控，还会涉及系统在整个企业生态圈中扮演和承载的角色。最后，在企业级网站系统这一特定领域，我们又重点关注技术开发这一范畴。<br> <br> 当然，使用的主要编程语言是PHP，本书所介绍分享的经验、技巧、原则和策略等，需要有项目经验或者已经掌握基本PHP网站开发的功底才能更好理解。所以，这本书更多是集中在使用PHP开发企业级网站系统这一领域，并且集中关注为有项目开发经验的工程师，尤其是当前处于迷茫期、瓶颈期或困难期的开发工程师提供启发性的帮助和技术干货。<br> <br> 此外，本书也会：</p> \n <ul> \n  <li>为编程爱好者和初学者提供实践指引，避免掉进教条式的理论学习，在最短时间内掌握基本企业级系统的开发技能。</li> \n  <li>为即将毕业投身软件开发行业的学生提供实用开发指南，为即将面对的挑战做好准备，在职场上掌握主动性。</li> \n  <li>为已经在职的开发工程师提供职业发展路线规划图，提升自己的专业能力，尽早获得晋升，脱颖而出。</li> \n  <li>为资深有经验的行业人士，提供总结，便于培养人才、建设团队、或进行恰如其分的架构设计。</li> \n </ul> \n</div>',NULL,'2020-02-09 15:00:05',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226400583418740736',NULL,NULL,' CentOS 6.5系统安装配置图解教程  ','<div class=\"content\" id=\"articleContent\"> \n <p><img alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101758_GoEC.jpg\"></p> \n <p><strong>说明：</strong></p> \n <p>截止目前CentOS 6.x最新版本为CentOS 6.5，下面介绍CentOS 6.5的具体安装配置过程</p> \n <p>服务器相关设置如下：</p> \n <p>操作系统：CentOS 6.5 64位</p> \n <p>IP地址：192.168.21.129</p> \n <p>网关：192.168.21.2</p> \n <p>DNS：8.8.8.8&nbsp;&nbsp;8.8.4.4</p> \n <p><strong>备注：</strong></p> \n <p>CentOS 6.5系统镜像有32位和64位两个版本，生产服务器如果是大内存（4G以上内存）</p> \n <p>建议安装64位版本CentOS-6.5-x86_64-bin-DVD1.iso</p> \n <p><strong>附：CentOS 6.5下载地址</strong></p> \n <p>32位：</p> \n <p><a href=\"http://mirror.centos.org/centos/6.5/isos/i386/CentOS-6.5-i386-bin-DVD1to2.torrent\" target=\"_blank\" rel=\"nofollow\">http://mirror.centos.org/centos/6.5/isos/i386/CentOS-6.5-i386-bin-DVD1to2.torrent</a></p> \n <p>64位：</p> \n <p><a href=\"http://mirror.centos.org/centos/6.5/isos/x86_64/CentOS-6.5-x86_64-bin-DVD1to2.torrent\" target=\"_blank\" rel=\"nofollow\">http://mirror.centos.org/centos/6.5/isos/x86_64/CentOS-6.5-x86_64-bin-DVD1to2.torrent</a></p> \n <p>1、CentOS 6.5系统镜像有两个，安装系统只用到第一个镜，即CentOS-6.5-i386-bin-DVD1.iso（32位）或者CentOS-6.5-x86_64-bin-DVD1.iso（64位）,第二个镜像是系统自带软件安装包；</p> \n <p>2、安装CentOS 6.5系统的计算机内存必须等于或者大于628M（最小内存628M），才能启用图形安装模式；</p> \n <p>3、CentOS 6.5文本安装模式不支持自定义分区，建议使用图形安装模式安装；</p> \n <p>4、CentOS 6.5的系统安装方式分为：图形安装模式和文本安装模式；</p> \n <p>5、CentOS 6.5的系统运行方式分为：带图形界面、可以用鼠标操作的图形化方式和不带图形界面、直接用命令行操作的文本方式（具体的系统运行方式，可以在系统安装的过程中自定义选择）；</p> \n <p><strong>一、安装CentOS 6.5</strong></p> \n <p>用光盘成功引导系统，会出现下面的界面</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328023.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101758_Hmj2.png\"></a></p> \n <p><strong>界面说明：</strong></p> \n <p>Install or upgrade an existing system&nbsp;安装或升级现有的系统</p> \n <p>install system with basic video driver&nbsp;安装过程中采用 基本的显卡驱动</p> \n <p>Rescue installed system&nbsp;进入系统修复模式</p> \n <p>Boot from local drive&nbsp;退出安装从硬盘启动</p> \n <p>Memory test&nbsp;内存检测</p> \n <p>这里选择第一项，安装或升级现有的系统，回车。</p> \n <p>出现是否对CD媒体进行测试的提问，这里选择“Skip”跳过测试。</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328024.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"375\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101759_AXmJ.png\"></a></p> \n <p>出现下面的界面</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328025.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101759_QN3W.png\"></a></p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328026.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101759_O8Rg.png\"></a></p> \n <p>选择语言为：English（English）&nbsp;#生产服务器建议安装英文版本</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328027.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101800_I1AS.png\"></a></p> \n <p>键盘选择为：U.S.English</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328028.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101800_W6gA.png\"></a></p> \n <p>选择第一项，基本存储设备</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/201401051328029.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101800_FnEh.png\"></a></p> \n <p>选择第一项：Yes，忽略所有数据</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280210.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101800_4UFy.png\"></a></p> \n <p>设置主机名，这里默认即可，安装完成之后再修改</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280211.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101800_Yygu.png\"></a></p> \n <p>时区选择：Etc/GMT +8 北京时区</p> \n <p>\"System clock user UTC\"&nbsp;前面打勾，使用UTC时间</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280212.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101800_l3Vd.png\"></a></p> \n <p>设置root密码</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280213.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101801_jxhw.png\"></a></p> \n <p>注意：如果你使用的密码过于简单，系统会自动提示：您的密码不够安全，过于简单化/系统化</p> \n <p>这里选择“Use Anyway\" 无论如何都使用</p> \n <p><strong>生产环境必须设置强壮复杂的密码</strong></p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280214.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101801_KZGh.png\"></a></p> \n <p>选择最后一项，Create Custom Layout 创建自定义分区</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280215.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101801_eVQB.png\"></a></p> \n <p>可以看到硬盘的容量，我这里显示的是25G，现在自定义分区。</p> \n <p>注意：分区之前，自己先要规划好，怎么分区</p> \n <p>我这里的分区如下：</p> \n <p>硬盘总共25G</p> \n <p>/boot &nbsp;#128M</p> \n <p>/ &nbsp;&nbsp;#剩余所有空间</p> \n <p><strong>特别说明：</strong></p> \n <p>用于正式生产的服务器，切记必须把数据盘单独分区，防止系统出问题时，保证数据的完整性。比如可以再划分一个</p> \n <p>/data专门用来存放数据。</p> \n <p>这里没有划分swap分区，对于大内存服务器，可以不用设置swap分区，或者在确定系统需要使用的内存大小后，</p> \n <p>再增加swap</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280216.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101801_TiGc.png\"></a></p> \n <p>选中空闲分区Free，点创建Create</p> \n <p>选择标准分区Standard Partition，点创建Create</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280217.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101801_w5Yt.png\"></a></p> \n <p>挂载点：/boot</p> \n <p>文件系统类型：ext3</p> \n <p>大小Size：128</p> \n <p>其他选项默认即可</p> \n <p>确定 OK</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280218.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101802_QAYV.png\"></a></p> \n <p>继续选中空闲分区Free，点创建Create</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280219.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101802_Iz52.png\"></a></p> \n <p>选择标准分区Standard Partition，点创建Create</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280220.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101802_VDAb.png\"></a></p> \n <p>挂载点：/</p> \n <p>文件系统类型：ext4</p> \n <p>选中“使用全部可用空间”</p> \n <p>其他选项默认即可</p> \n <p>确定 OK</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280221.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101802_Pjsr.png\"></a></p> \n <p>创建好分区之后，如上图所示，然后点Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280222.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101802_Vcjh.png\"></a></p> \n <p>默认Yes #提示没有创建swap分区，后面再创建</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280223.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101802_ghlA.png\"></a></p> \n <p>点“Format”格式化</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280224.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_uwOE.png\"></a></p> \n <p>选择“Write changes to disk”将修改写入磁盘</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280225.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_BSyY.png\"></a></p> \n <p>默认</p> \n <p>Next</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280226.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_oRPo.png\"></a></p> \n <p>默认是：第一项，Desktop桌面</p> \n <p>这里选择：Minimal 最小</p> \n <p>Next</p> \n <p>备注：可以点Customize now，选择安装需要的开发工具包软件，</p> \n <p>也可以在需要的时候通过yum源、rpm或者编译来安装软件包。</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280227.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_c1kN.png\"></a></p> \n <p>开始安装</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280228.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"504\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_NfJK.png\"></a></p> \n <p>安装完成</p> \n <p>点“Reboot”重新引导，系统自动重启</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280229.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"375\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_NE39.png\"></a></p> \n <p>重启之后，出现下面登录界面</p> \n <p><a href=\"http://files.jb51.net/file_images/article/201401/2014010513280230.png\" target=\"_blank\" rel=\"nofollow\"><img width=\"670\" height=\"375\" alt=\"\" src=\"http://static.oschina.net/uploads/img/201408/19101803_SoeJ.png\"></a></p> \n <p>系统安装完成</p> \n <p><strong>二、设置IP地址、网关、DNS</strong></p> \n <p>约定：</p> \n <p>第一块网卡为外网</p> \n <p>第二块网卡为内网（没有外网的机器也要将内网配置在第二块网卡上）</p> \n <p><strong>说明：CentOS 6.5默认安装好之后是没有自动开启网络连接的！</strong></p> \n <p>输入账号root</p> \n <p>再输入安装过程中设置的密码，登录到系统</p> \n <p>vi&nbsp; /etc/sysconfig/network-scripts/ifcfg-eth0&nbsp;&nbsp; #编辑配置文件,添加修改以下内容</p> \n <p>BOOTPROTO=static&nbsp;&nbsp; #启用静态IP地址</p> \n <p>ONBOOT=yes&nbsp; #开启自动启用网络连接</p> \n <p>IPADDR=192.168.21.129&nbsp; #设置IP地址</p> \n <p>NETMASK=255.255.255.0&nbsp; #设置子网掩码</p> \n <p>GATEWAY=192.168.21.2&nbsp;&nbsp; #设置网关</p> \n <p>DNS1=8.8.8.8 #设置主DNS</p> \n <p>DNS2=8.8.4.4 #设置备DNS</p> \n <p>IPV6INIT=no&nbsp; #禁止IPV6</p> \n <p>:wq!&nbsp; #保存退出</p> \n <p>service ip6tables stop&nbsp;&nbsp; #停止IPV6服务</p> \n <p>chkconfig ip6tables off&nbsp; #禁止IPV6开机启动</p> \n <p>service yum-updatesd stop&nbsp;&nbsp; #关闭系统自动更新</p> \n <p>chkconfig yum-updatesd off&nbsp; #禁止开启启动</p> \n <p>service network restart &nbsp;#重启网络连接</p> \n <p>ifconfig&nbsp; #查看IP地址</p> \n <p><strong>三、设置主机名</strong></p> \n <p>约定：</p> \n <p>主机名命名规范：业务.机房.主备.域名</p> \n <p>这里设置主机名为：bbs.hz.m.osyunwei.com</p> \n <p>1、hostname&nbsp;“bbs.hz.m.osyunwei.com”</p> \n <p>#设置主机名为bbs.hz.m.osyunwei.com</p> \n <p>2、vi /etc/sysconfig/network&nbsp;&nbsp;#编辑配置文件</p> \n <p>HOSTNAME= bbs.hz.m.osyunwei.com</p> \n <p>#修改localhost.localdomain为bbs.hz.m.osyunwei.com</p> \n <p>:wq!&nbsp;&nbsp;#保存退出</p> \n <p>3、vi /etc/hosts&nbsp;#编辑配置文件</p> \n <p>127.0.0.1&nbsp; bbs.hz.m.osyunwei.com localhost</p> \n <p>#修改localhost.localdomain为bbs.hz.m.osyunwei.com</p> \n <p>:wq!&nbsp;&nbsp;#保存退出</p> \n <p>shutdown -r now&nbsp;&nbsp;#重启系统</p> \n <p><strong>四、增加swap分区</strong></p> \n <p>在确定了服务器所需要使用的内存后，需要增加1024M的swap空间</p> \n <p>具体操作：</p> \n <p>1、dd if=/dev/zero of=/tmp/swap bs=1M &nbsp;count=1024M&nbsp; #创建1024M的文件块</p> \n <p>2、mkswap /tmp/swap &nbsp;#创建swap文件</p> \n <p>3、swapon /tmp/swap&nbsp; #激活swap文件</p> \n <p>4、swapon -s&nbsp; #查看swap</p> \n <p>5、修改/etc/fstab文件，增加以下内容，让系统引导时自动启动</p> \n <p>vi /etc/fstab&nbsp; #在最后添加下面代码</p> \n <p>/tmp/swap swap swap default&nbsp; 0 0</p> \n <p>:wq!&nbsp;&nbsp;#保存退出</p> \n <p><strong>至此，CentOS 6.5系统安装配置完成</strong></p> \n <p></p> \n</div>',NULL,'2020-02-09 15:00:59',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226400805381308416',NULL,NULL,' 【Linux】DELL R720 服务器 安装 centos 7经历  ','<div class=\"content\" id=\"articleContent\"> \n <h2>dell R720 服务器</h2> \n <blockquote> \n  <p>F2：进入 BLOS 设置 F11：启动项设置 F12： F10：raid</p> \n </blockquote> \n <h2>raid 配置</h2> \n <p>RAID卡配置涉及的一些名称解释</p> \n <blockquote> \n  <p>Disk Group ：磁盘组，这里相当于是阵列，例如配置了一个Raid 1 ，就是一个磁盘组；</p> \n  <p>VD（virtual Disk）：虚拟磁盘，虚拟磁盘可以不使用阵列的全部容量，也就是说一个可以分为多个VD；</p> \n  <p>PD（physical disk）：故名思义，主是物理硬盘；</p> \n  <p>HS：Hot Spare ，热备盘</p> \n </blockquote> \n <ul> \n  <li>1、进入</li> \n </ul> \n <p>有两种，F10 和 ctrl+R</p> \n <p>我选择ctrl+R</p> \n <ul> \n  <li>2、功能键</li> \n </ul> \n <p>ctrl+N/P 菜单切换</p> \n <p>F2 选项</p> \n <p>F5刷新</p> \n <p>在选择硬盘的时候，空格表选择[X]</p> \n <ul> \n  <li>3、功能</li> \n </ul> \n <blockquote> \n  <p>配置 VD</p> \n </blockquote> \n <p>new create VD</p> \n <p>如果只有一个硬盘，设置为raid0</p> \n <p>多个可设置raid 5/10</p> \n <blockquote> \n  <p>配置 HS</p> \n </blockquote> \n <blockquote> \n  <p>格式化</p> \n </blockquote> \n <ul> \n  <li>资料</li> \n </ul> \n <p><strong><a href=\"https://www.linuxidc.com/Linux/2017-02/140756.htm\">DELL R720 服务器 RAID阵列卡配置图解</a></strong></p> \n <h2>用U盘制作linux启动盘</h2> \n <ul> \n  <li> <p>1、选中&nbsp;UltraISO-&gt;右键 【用管理员权限运行】</p> </li> \n  <li> <p>2、插上U盘，打开 ***.iso</p> </li> \n  <li> <p>3、启动-&gt;写入硬盘映像</p> </li> \n  <li> <p>4、确认后，点击【写入】</p> </li> \n  <li> <p>资料</p> </li> \n </ul> \n <p><strong><a href=\"https://jingyan.baidu.com/article/25648fc18f56b29191fd00e5.html\">如何制作CentOS安装U盘</a></strong></p> \n <h2>linux安装</h2> \n <ul> \n  <li>1、u 盘启动</li> \n </ul> \n <p>开启后按F11 -&gt; BLOS SETTING -&gt; 按【下】键 -&gt; 到【front USB:XXX】-&gt; 回车</p> \n <ul> \n  <li>2、【上/下】键选择后按回车。</li> \n </ul> \n <p>这里多说一下：</p> \n <p>我安装centos 7/red hat e..... 7 这两个版本在这里出错，错误信息：no default or UI ...，安装网上说的，我试了很多次很多方法不能够解决</p> \n <p>安装centos 6.5，在分区之后，一直【重试下载】,网上说，因为u盘挂载点是【/dev/sda】这种只能重装。</p> \n <p>折腾两天之后，因为我之前装是没有问题的，所以我怀疑是我的u盘有问题，更换了一个u盘就好了。</p> \n <ul> \n  <li>3、一路 【next】就算是搞定了</li> \n </ul> \n <p>需要注意3点：</p> \n <p>分区的时候，一定要看仔细分的是哪个硬盘</p> \n <p>密码不能太简单</p> \n <p>软件最小化安装。</p> \n <ul> \n  <li>资料</li> \n </ul> \n <p><strong><a href=\"https://www.osyunwei.com/archives/7829.html\">CentOS 7.0系统安装配置图解教程</a></strong></p> \n</div>',NULL,'2020-02-09 15:01:52',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226401027280961536',NULL,NULL,' CentOS 7.2 下安装 Docker 1.12.3 版的详细方法  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1>CentOS 7.2 下安装 Docker 1.12.3 版的详细方法</h1> \n <p>&nbsp;更新时间：2016年11月14日 14:32:41 &nbsp; 作者：Scoter &nbsp;&nbsp;<a href=\"https://www.jb51.net/article/97258.htm#comments\" rel=\"nofollow\"><img height=\"15\" src=\"https://www.jb51.net/skin/2018/images/text-message.png\" width=\"15\">&nbsp;我要评论</a></p> \n <p>&nbsp;</p> \n <p>这篇文章主要介绍了CentOS 7.2 安装 Docker 1.12.3 版的相关资料,本文分步骤给大家介绍了CentOS 7.2 下安装 Docker 1.12.3 版的详细方法，需要的朋友可以参考下</p> \n <p><a href=\"http://www.php.cn/course.html?ad51\" target=\"_blank\" rel=\"nofollow\"><img height=\"99\" src=\"https://files.jb51.net/image/phpcn.gif?0121\" width=\"690\"></a></p> \n <p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p> \n <p><strong>1、强大的官方文档</strong></p> \n <p><a href=\"https://docs.docker.com/engine/installation/linux/centos/\" target=\"_blank\" rel=\"nofollow\">https://docs.docker.com/engine/installation/linux/centos/</a></p> \n <p><strong>2、按步骤来，先更新yum源，这里用163的源</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td> \n    <td> <p><code>yum </code><code>install</code> <code>-y wget</code></p> <p><code>cd</code> <code>/etc/yum</code><code>.repos.d</code></p> <p><code>wget http:</code><code>//mirrors</code><code>.163.com/.help</code><code>/CentOS7-Base-163</code><code>.repo</code></p> <p><code>/usr/bin/yum</code> <code>clean all</code></p> <p><code>/usr/bin/yum</code> <code>makecache</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p>其他系统自带的源可以保留，也可以全部干掉</p> \n <p><strong>3、更新系统</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>yum update</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>4、如果遇到问题：Delta RPMs disabled because /usr/bin/applydeltarpm not installed.</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>yum </code><code>install</code> <code>-y deltarpm</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>5、编辑生成docker的yum源文件</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td> \n    <td> <p><code>tee</code> <code>/etc/yum</code><code>.repos.d</code><code>/docker</code><code>.repo &lt;&lt;-</code><code>\'EOF\'</code></p> <p><code>[dockerrepo]</code></p> <p><code>name=Docker Repository</code></p> <p><code>baseurl=https:</code><code>//yum</code><code>.dockerproject.org</code><code>/repo/main/centos/7/</code></p> <p><code>enabled=1</code></p> <p><code>gpgcheck=1</code></p> <p><code>gpgkey=https:</code><code>//yum</code><code>.dockerproject.org</code><code>/gpg</code></p> <p><code>EOF</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>6、安装Docker</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>yum </code><code>install</code> <code>docker-engine</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>7、如果遇到问题：Public key for docker-engine-selinux-1.10.1-1.el7.centos.noarch.rpm is not installed，执行下面的命令</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>rpm --</code><code>import</code> <code>https:</code><code>//yum</code><code>.dockerproject.org</code><code>/gpg</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>8、Docker下载速度很慢，请耐心等待</strong></p> \n <p><strong>9、安装完成后设置开机自启</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>systemctl </code><code>enable</code> <code>docker.service</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>10、启动docker守护进程</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>systemctl start docker</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>11、查看docker版本</strong></p> \n <p><a href=\"https://www.jb51.net/article/97258.htm#\" rel=\"nofollow\">?</a></p> \n <table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"> \n  <tbody> \n   <tr> \n    <td> <p>1</p> </td> \n    <td> <p><code>[root<a href=\"https://my.oschina.net/u/570656\" class=\"referer\" target=\"_blank\">@localhost</a> ~]</code><code># docker version</code></p> </td> \n   </tr> \n  </tbody> \n </table> \n <p>Client:</p> \n <p>Version: 1.12.3<br> API version: 1.24<br> Go version: go1.6.3<br> Git commit: 6b644ec</p> \n <p>Built:&nbsp;</p> \n <p>OS/Arch: linux/amd64</p> \n <p>Server:</p> \n <p>Version: 1.12.3<br> API version: 1.24<br> Go version: go1.6.3<br> Git commit: 6b644ec</p> \n <p>Built:&nbsp;</p> \n <p>OS/Arch: linux/amd64</p> \n <p><strong>12、 Done，enjoy it!</strong></p> \n <p>&nbsp;</p> \n <span id=\"OSC_h4_2\"></span> \n <h4>您可能感兴趣的文章:</h4> \n <ul> \n  <li><a href=\"https://www.jb51.net/article/103267.htm\" target=\"_blank\" rel=\"nofollow\">在Ubuntu 16.04安装与使用Docker的教程详解</a></li> \n  <li><a href=\"https://www.jb51.net/article/75726.htm\" target=\"_blank\" rel=\"nofollow\">在windows下的安装Docker的教程</a></li> \n  <li><a href=\"https://www.jb51.net/article/94067.htm\" target=\"_blank\" rel=\"nofollow\">在CentOS 7上安装Docker环境的方法与注意事项</a></li> \n  <li><a href=\"https://www.jb51.net/article/96177.htm\" target=\"_blank\" rel=\"nofollow\">docker centos7 安装ssh具体步骤</a></li> \n  <li><a href=\"https://www.jb51.net/article/94064.htm\" target=\"_blank\" rel=\"nofollow\">Centos 6.5中安装docker的步骤(简洁版)</a></li> \n  <li><a href=\"https://www.jb51.net/article/101799.htm\" target=\"_blank\" rel=\"nofollow\">CentOS/RedHat 6.5 离线安装Docker</a></li> \n  <li><a href=\"https://www.jb51.net/article/97617.htm\" target=\"_blank\" rel=\"nofollow\">Docker的安装方法及运行Docker Swarm模式的使用</a></li> \n  <li><a href=\"https://www.jb51.net/article/110520.htm\" target=\"_blank\" rel=\"nofollow\">在Docker上安装配置Oracle教程</a></li> \n  <li><a href=\"https://www.jb51.net/article/153865.htm\" target=\"_blank\" rel=\"nofollow\">Docker入门安装教程(小白篇)</a></li> \n </ul> \n <p>原文链接：http://www.cnblogs.com/scoter2008/archive/2016/11/13/605849</p> \n</div>',NULL,'2020-02-09 15:02:45',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226401248996065280',NULL,NULL,' Virtualbox虚拟机安装CentOS6.5图文详细教程  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h1_1\"></span> \n <h1>什么是Virtualbox？</h1> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">VirtualBox 是一款开源虚拟机软件(注：跟vmware差不多)。VirtualBox 是由德国 Innotek 公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。Innotek 以 GNU General Public License (GPL) 释出 VirtualBox，并提供二进制版本及 OSE 版本的代码。使用者可以在VirtualBox上安装并且执行Solaris、Windows、DOS、Linux、OS/2 Warp、BSD等系统作为客户端操作系统。</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">这里我使用Virtualbox虚拟机最新版本（以下简称VBOX，版本号4.3.14）。</p> \n <span id=\"OSC_h1_2\"></span> \n <h1>什么是CentOS？</h1> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">CentOS（Community Enterprise Operating System，中文意思是：社区企业操作系统）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码规定释出的源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。两者的不同，在于CentOS并不包含封闭源代码软件。CentOS6.5是2013-12-01发行的。</p> \n <span id=\"OSC_h1_3\"></span> \n <h1>1、首先<a href=\"http://www.2cto.com/soft\" target=\"_blank\" rel=\"nofollow\">下载</a>VBox并且安装</h1> \n <p><span style=\"color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(255, 255, 255);\">VBox官网：https://www.virtualbox.org/</span></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">VBox 的安装比较简单，根据提示下一步就行。</p> \n <span id=\"OSC_h1_4\"></span> \n <h1>2、打开VBox，并且创建CentOS 6.5 64位环境。</h1> \n <p><span style=\"color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(255, 255, 255);\">a）新建</span><a href=\"http://www.2cto.com/os/xuniji/\" target=\"_blank\" rel=\"nofollow\">虚拟机</a><span style=\"color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(255, 255, 255);\">环境，由于VBox环境没有CentOS的选项，所以可以选择Red Hat Linux（64Bit）</span></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp;<img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171137_oM42.png\"><br><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171137_1TaD.png\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171137_efop.png\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">b）动态分配硬盘大小所以你可以选择大一点的硬盘空间（不用的话不会占用的，但是C盘性能上没固定的好）</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_CtG5.png\"><br><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_Mapf.png\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_P7UT.png\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_HNGn.png\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">&nbsp;</p> \n <span id=\"OSC_h1_5\"></span> \n <h1>3、下载CentOS 6.5系统</h1> \n <p><span style=\"color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; background-color: rgb(255, 255, 255);\">CentOS系统官网：http://www.centos.org&nbsp;&nbsp;</span></p> \n <span id=\"OSC_h1_6\"></span> \n <h1>4、安装CentOS</h1> \n <span id=\"OSC_h2_7\"></span> \n <h2>a）在VBOX主界面，选择刚刚新建的CentOS64，点击启动。</h2> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_fYYU.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">b) 选择你下载的CentOS6.5 的ISO文件</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_fLDP.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">c)启动后看到CentOS6.5的安装界面，这里我选择第2个install system with basic video driver 安装</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_a9IL.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">Install or upgrade an existing system 安装或升级现有的系统</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">install system with basic video driver 安装过程中采用基本的显卡驱动</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">Rescue installed system 进入系统修复模式</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">Boot from local drive 退出安装从硬盘启动</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">Memory test 内存检测</p> \n <span id=\"OSC_h2_8\"></span> \n <h2>d)Disc Found，选择Skip（跳过）</h2> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_TpLz.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">e)welcome信息，点击ok</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_iNI0.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">f)语言选择English。（我在安装的时候选择中文会报错）</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_XixD.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">g)键盘设置选择us</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171138_U4OR.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">h)错误警告，不用去管，直接选择Re-initialize</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_TVQQ.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">i)时间时区选择Asia/Shanghai（UTC时间）</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_jN5t.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">j)Password设置（root密码设置界面）</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_iLmg.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">k)弱密码提醒，继续选择use Anyway（我设置的密码比较弱，所以有这个提示）</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_JfLv.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">l)分区类型Partitioning Type选择ok</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_gfL1.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">m)write changes to disk，然后就是等待CentOS安装。</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_2GqM.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">n)安装完成，需要重启，点击reboot</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_GJMt.jpg\"></p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">到此安装已经完成，没有安装桌面<a href=\"http://www.2cto.com/kf/all/zujian/\" target=\"_blank\" rel=\"nofollow\">组件</a>，需要安装桌面组件的可以自行百度安装</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\">重启之后，输入root 和安装时设置的密码即可进入：</p> \n <p style=\"border-width: 0px; padding: 0px; margin-top: 0px; margin-bottom: 8px; list-style: none; text-indent: 2em; color: rgb(51, 51, 51); font-family: 宋体; font-size: 14px; line-height: 28px; white-space: normal; background-color: rgb(255, 255, 255);\"><img alt=\"\\\" src=\"http://static.oschina.net/uploads/img/201412/18171139_GAOF.jpg\"></p> \n <p><br></p> \n</div>',NULL,'2020-02-09 15:03:38',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226401471050907648',NULL,NULL,' Axure RP 各个版本中文版 汉化包 破解版 下载地址及注册码   ','<div class=\"content\" id=\"articleContent\">\n  一、Axure RP原型设计工具介绍： \n <br> Axure RP是美国Axure Software Solution公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或Web网站的线框图、 流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。 \n <br> \n <br> \n <p> 二、Axure RP原型设计工具相关下载：<br> Axure RP Pro 6.0下载地址：<br> 1、axure rp pro 6.0简体中文破解版&nbsp;下载地址：http://down.drv5.cn/www.drv5.cn/axure_rp_pro_6.0.0.2887_HA_99D.COM.rar<br> 2、Axure RP Pro for Windows 简体中文加强版 6.0.0.2899 下载地址：http://west263.onlinedown.net/down /Axure_RP_Pro_6.0.0.2899_for_Windows_Chinese.zip<br> 3、Axure RP Pro for Mac 6.0.0.2900 英文正式版 下载地址：http://west263.onlinedown.net/down/AxureRP-Pro-Beta-Setup_114414.zip<br> 本站提供axure6.0下载、axure6.0 注册码、axure6.0中文版、axure6.0汉化包等资源。<br> <br> Axure RP Pro 6.5 下载地址：<br> 1、Axure RP Pro 6.5Windows版下载地址：http://axure.cachefly.net/AxureRP-Pro-Setup.exe<br> 2、Axure RP Pro 6.5MAC版地址地址：http://axure.cachefly.net/AxureRP-Pro-Setup.dmg<br> 3、Axure6.5汉化语言包20130418版：http://www.axure.us/wp-content/uploads/2012/05/lang.zip<br> 本文提供axure rp、axure rp 6.5 下载、axure 6.5 下载、axure rp pro 6.5、axure rp 6.5 注册码、axure rp 7.0、axure rp 6.5 mac、axure rp pro、axure rp pro 6.5教程等资源。<br> <br> Axure RP 7.0下载地址：<br> 1、Axure RP Pro下载：http://dlsw.baidu.com/sw-search-sp/soft/81/15574/arp7.0.0.4104.1435826335.exe<br> 2、Axure RP Pro MAC版下载；http://dlsw.baidu.com/sw-search-sp/soft/91/25837/AxureRP-Pro-Setup.1426488743.dmg<br> 3、Axure RP 7.0简体中文版（附汉化包注册）：http://down.newasp.net/soft1/AxureRP-Pro-Setup.rar<br> 本文提供axure 7.0 注册码、axure 7.0 汉化、axure、axure 7.0 下载、axure 7.0 教程、axure 7.0 mac、axure7.0汉化包、axure7.0破解版、axure rp pro 7.0。<br> <br> Axure RP 8.0 下载地址：<br> 1、Axure8.0中文汉化语言包下载地址：http://www.axure.com.cn/wp-content/uploads/2015/08/lang.zip<br> 2、Axure8测试版下载地址：<br> （1）、Win版下载地址：http://axure.cachefly.net/AxureRP-Setup-Beta.exe<br> （2）、MAC版下载地址：http://axure.cachefly.net/AxureRP-Setup-Beta.dmg<br> 3、测试版下载地址：（含汉化包）<br> （1）、MAC版：http://pan.baidu.com/s/1hqs7WZ6<br> （2）、Windows版：http://pan.baidu.com/s/1gd95bH5<br> <br> 三、Axure RP原型设计工具注册码序列号激活码：<br> Axure RP Pro 6.0注册码：<br> IloveyouAxure<br> UChpuxwbDW6eAIaAf9UujEFSBwN3vpEz9snHvlCQVJGQy4p7WrCyKLLvV5QLvqva<br> 本站提供axure6.0下载、axure6.0 注册码、axure6.0中文版、axure6.0汉化包等资源。<br> <br> Axure RP Pro 6.5注册码：<br> 1、IloveyouAxure&nbsp;&nbsp;&nbsp;UChpuxwbDW6eAIaAf9UujEFSBwN3vpEz9snHvlCQVJGQy4p7WrCyKLLvV5QLvqva<br> 2、Axure&nbsp;&nbsp;&nbsp;8t+3Yk/zu4cX601/seX6wBZgYRVj/lkC2PICCdO4+sFKCCLx8mcCnccoylVb40lP<br> 本文提供axure rp、axure rp 6.5 下载、axure 6.5 下载、axure rp pro 6.5、axure rp 6.5 注册码、axure rp 7.0、axure rp 6.5 mac、axure rp pro、axure rp pro 6.5教程等资源。<br> <br> Axure RP 7.0注册码：<br> 1、用户名：aaa&nbsp;&nbsp;&nbsp;注册码：2GQrt5XHYY7SBK/4b22Gm4Dh8alaR0/0k3gEN5h7FkVPIn8oG3uphlOeytIajxGU<br> 2、用户名:&nbsp;aaa&nbsp;&nbsp;&nbsp;注册码：h624pifAqt7It5e8boKkML+Y4RjDX5xknP4k7QktJYQoxsvv7VUS7hBCv/2ef45P<br> 3、用户名:&nbsp;aaa&nbsp;&nbsp;&nbsp;注册码：+f4T7ql2FvMB6Jx0PvfoGBB8T5UdAfIZi3uJiP4VHI6xGkev7hKHh+xJrJDNZjRS<br> 4、用户名：axureuser&nbsp;&nbsp;&nbsp;序列号：8wFfIX7a8hHq6yAy6T8zCz5R0NBKeVxo9IKu+kgKh79FL6IyPD6lK7G6+tqEV4LG<br> 本文提供axure 7.0 注册码、axure 7.0 汉化、axure、axure 7.0 下载、axure 7.0 教程、axure 7.0 mac、axure7.0汉化包、axure7.0破解版、axure rp pro 7.0。<br> <br> Axure RP 8.0 激活码：（亲测可用）<br> 用户名：aaa<br> 注册码：2GQrt5XHYY7SBK/4b22Gm4Dh8alaR0/0k3gEN5h7FkVPIn8oG3uphlOeytIajxGU<br> 本文提供axure 8.0、axure、axure 8 下载、axure 8.0 注册码、axure 8 mac、axure 7.0 注册码、axure官网、证照之星、axure8.0 下载。<br> <br> 三、Axure RP 8.0 介绍：<br> 1、Axure RP对工作流改进的一个重要方法是可以为团队提供自定义的小部件库（widget libraries），这有效地节约了大家的时间并提高了项目的一致性。<br> 2、但是美中不足的是，Axure RP缺少一种可以绘制这些自定义小部件的工具，自定义小部件库只能通过各种不同颜色和形状的图像来填充。<br> 3、将在今夏晚些时候推出的Axure RP 8 Beta版本里，全新的钢笔工具可以让用户自己绘制自定义小部件。由于这些图形都是矢量图，你可以对它们进行自由拉伸，另外你还可以改变它们的填充和边框，这对于设计图标、图表、弯曲箭头、图案轮廓、按钮等是非常有用的。<br> 4、你也可以使用结合（unite）、差集（Subtract）、交集（Intersect）、排除（Exclude）等选项来选择图像，下面的GIF动画显示了使用钢笔工具和差集选项来创建一个自定义的表情符号。<br> <br> 四、Axure RP相关文章链接：<br> 1、<a target=\"_blank\" href=\"http://www.adobezcm.com/axurerp/1.html\" rel=\"nofollow\">Axure RP 6.0 中文版汉化包破解版下载地址及注册码</a><br> 2、<a target=\"_blank\" href=\"http://www.adobezcm.com/axurerp/2.html\" rel=\"nofollow\">Axure RP 6.5 中文版汉化包破解版下载地址及注册码</a><br> 3、<a target=\"_blank\" href=\"http://www.adobezcm.com/axurerp/3.html\" rel=\"nofollow\">Axure RP 7.0 中文版汉化包破解版下载地址及注册码</a><br> 4、<a target=\"_blank\" href=\"http://www.adobezcm.com/axurerp/4.html\" rel=\"nofollow\">Axure RP 8.0 中文版汉化包破解版下载地址及注册码<br> </a> </p> \n <p> <a target=\"_blank\" href=\"http://www.adobezcm.com/axurerp.html\" rel=\"nofollow\">更多。。。</a> </p> \n <p> <br> </p> 转自： \n <a href=\"http://www.adobezcm.com/special/25.html\" target=\"_blank\" rel=\"nofollow\">http://www.adobezcm.com/special/25.html</a>（Adobe注册码） \n</div>',NULL,'2020-02-09 15:04:31',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226401693592289280',NULL,NULL,' TiKV 源码解析系列文章（十）Snapshot 的发送和接收  ','<div class=\"content\" id=\"articleContent\"> \n <p>作者：黄梦龙</p> \n <h2>背景知识</h2> \n <p>TiKV 使用 Raft 算法来提供高可用且具有强一致性的存储服务。在 Raft 中，Snapshot 指的是整个 State Machine 数据的一份快照，大体上有以下这几种情况需要用到 Snapshot：</p> \n <ol> \n  <li>正常情况下 leader 与 follower/learner 之间是通过 append log 的方式进行同步的，出于空间和效率的考虑，leader 会定期清理过老的 log。假如 follower/learner 出现宕机或者网络隔离，恢复以后可能所缺的 log 已经在 leader 节点被清理掉了，此时只能通过 Snapshot 的方式进行同步。</li> \n  <li>Raft 加入新的节点的，由于新节点没同步过任何日志，只能通过接收 Snapshot 的方式来同步。实际上这也可以认为是 1 的一种特殊情形。</li> \n  <li>出于备份/恢复等需求，应用层需要 dump 一份 State Machine 的完整数据。</li> \n </ol> \n <p>TiKV 涉及到的是 1 和 2 这两种情况。在我们的实现中，Snapshot 总是由 Region leader 所在的 TiKV 生成，通过网络发送给 Region follower/learner 所在的 TiKV。</p> \n <p>理论上讲，我们完全可以把 Snapshot 当作普通的 <code>RaftMessage</code> 来发送，但这样做实践上会产生一些问题，主要是因为 Snapshot 消息的尺寸远大于其他 <code>RaftMessage</code>：</p> \n <ol> \n  <li>Snapshot 消息需要花费更长的时间来发送，如果共用网络连接容易导致网络拥塞，进而引起其他 Region 出现 Raft 选举超时等问题。</li> \n  <li>构建待发送 Snapshot 消息需要消耗更多的内存。</li> \n  <li>过大的消息可能导致超出 gRPC 的 Message Size 限制等问题。</li> \n </ol> \n <p>基于上面的原因，TiKV 对 Snapshot 的发送和接收进行了特殊处理，为每个 Snapshot 创建单独的网络连接，并将 Snapshot 拆分成 1M 大小的多个 Chunk 进行传输。</p> \n <h2>源码解读</h2> \n <p>下面我们分别从 RPC 协议、发送 Snapshot、收取 Snapshot 三个方面来解读相关源代码。本文的所有内容都基于 v3.0.0-rc.2 版本。</p> \n <h3>Snapshot RPC call 的定义</h3> \n <p>与普通的 raft message 类似，Snapshot 消息也是使用 gRPC 远程调用的方式来传输的。在 <a href=\"https://github.com/pingcap/kvproto\">pingcap/kvproto</a> 项目中可以找到相关 RPC Call 的定义，具体在 <a href=\"https://github.com/pingcap/kvproto/blob/5cb23649b361013f929e0d46a166ae24848fbcbb/proto/tikvpb.proto#L57\">tikvpb.proto</a> 和 <a href=\"https://github.com/pingcap/kvproto/blob/5cb23649b361013f929e0d46a166ae24848fbcbb/proto/raft_serverpb.proto#L42-L47\">raft_serverpb.proto</a> 文件中。</p> \n <pre><code class=\"language-proto\">rpc Snapshot(stream raft_serverpb.SnapshotChunk) returns (raft_serverpb.Done) {}\n...\nmessage SnapshotChunk {\n  RaftMessage message = 1;\n  bytes data = 2;\n}\n\nmessage Done {}\n</code></pre> \n <p>可以看出，Snapshot 被定义成 client streaming 调用，即对于每个 Call，客户端依次向服务器发送多个相同类型的请求，服务器接收并处理完所有请求后，向客户端返回处理结果。具体在这里，每个请求的类型是 <code>SnapshotChunk</code>，其中包含了 Snapshot 对应的 <code>RaftMessage</code>，或者携带一段 Snapshot 数据；回复消息是一个简单的空消息 <code>Done</code>，因为我们在这里实际不需要返回任何信息给客户端，只需要关闭对应的 stream。</p> \n <h3>Snapshot 的发送流程</h3> \n <p>Snapshot 的发送过程的处理比较简单粗暴，直接在将要发送 <code>RaftMessage</code> 的地方截获 Snapshot 类型的消息，转而通过特殊的方式进行发送。相关代码可以在 <a href=\"https://github.com/tikv/tikv/blob/892c12039e0213989940d29c232bddee9cbe4686/src/server/transport.rs#L313-L344\">server/transport.rs</a> 中找到：</p> \n <pre><code class=\"language-rust\">fn write_data(&amp;self, store_id: u64, addr: &amp;str, msg: RaftMessage) {\n  if msg.get_message().has_snapshot() {\n      return self.send_snapshot_sock(addr, msg);\n  }\n  if let Err(e) = self.raft_client.wl().send(store_id, addr, msg) {\n      error!(\"send raft msg err\"; \"err\" =&gt; ?e);\n  }\n}\n\nfn send_snapshot_sock(&amp;self, addr: &amp;str, msg: RaftMessage) {\n  ...\n  if let Err(e) = self.snap_scheduler.schedule(SnapTask::Send {\n      addr: addr.to_owned(),\n      msg,\n      cb,\n  }) {\n      ...\n  }\n}\n</code></pre> \n <p>从代码中可以看出，这里简单地把对应的 <code>RaftMessage</code> 包装成一个 <code>SnapTask::Send</code> 任务，并将其交给独立的 <code>snap-worker</code> 去处理。值得注意的是，这里的 <code>RaftMessage</code> 只包含 Snapshot 的元信息，而不包括真正的快照数据。TiKV 中有一个单独的模块叫做 <code>SnapManager</code> ，用来专门处理数据快照的生成与转存，稍后我们将会看到从 <code>SnapManager</code> 模块读取 Snapshot 数据块并进行发送的相关代码。</p> \n <p>我们不妨顺藤摸瓜来看看 <code>snap-worker</code> 是如何处理这个任务的，相关代码在 <a href=\"https://github.com/tikv/tikv/blob/892c12039e0213989940d29c232bddee9cbe4686/src/server/snap.rs#L329-L398\">server/snap.rs</a>，精简掉非核心逻辑后的代码引用如下：</p> \n <pre><code class=\"language-rust\">fn run(&amp;mut self, task: Task) {\n  match task {\n      Task::Recv { stream, sink } =&gt; {\n           ...\n           let f = recv_snap(stream, sink, ...).then(move |result| {\n               ...\n           });\n           self.pool.spawn(f).forget();\n      }\n      Task::Send { addr, msg, cb } =&gt; {\n          ...\n          let f = future::result(send_snap(..., &amp;addr, msg))\n              .flatten()\n              .then(move |res| {\n                  ...\n              });\n          self.pool.spawn(f).forget();\n      }\n  }\n}\n</code></pre> \n <p><code>snap-worker</code> 使用了 <code>future</code> 来完成收发 Snapshot 任务：通过调用 <code>send_snap()</code> 或 <code>recv_snap()</code> 生成一个 future 对象，并将其交给 <code>FuturePool</code> 异步执行。</p> \n <p>现在我们暂且只关注 <code>send_snap()</code> 的 <a href=\"https://github.com/tikv/tikv/blob/892c12039e0213989940d29c232bddee9cbe4686/src/server/snap.rs#L103-L175\">实现</a>：</p> \n <pre><code class=\"language-rust\">fn send_snap(\n  ...\n  addr: &amp;str,\n  msg: RaftMessage,\n) -&gt; Result&lt;impl Future&lt;Item = SendStat, Error = Error&gt;&gt; {\n  ...\n  let key = {\n      let snap = msg.get_message().get_snapshot();\n      SnapKey::from_snap(snap)?\n  };\n  ...\n  let s = box_try!(mgr.get_snapshot_for_sending(&amp;key));\n  if !s.exists() {\n      return Err(box_err!(\"missing snap file: {:?}\", s.path()));\n  }\n  let total_size = s.total_size()?;\n  let chunks = {\n      let mut first_chunk = SnapshotChunk::new();\n      first_chunk.set_message(msg);\n\n      SnapChunk {\n          first: Some(first_chunk),\n          snap: s,\n          remain_bytes: total_size as usize,\n      }\n  };\n\n  let cb = ChannelBuilder::new(env);\n  let channel = security_mgr.connect(cb, addr);\n  let client = TikvClient::new(channel);\n  let (sink, receiver) = client.snapshot()?;\n\n  let send = chunks.forward(sink).map_err(Error::from);\n  let send = send\n      .and_then(|(s, _)| receiver.map_err(Error::from).map(|_| s))\n      .then(move |result| {\n          ...\n      });\n  Ok(send)\n}\n</code></pre> \n <p>这一段流程还是比较清晰的：先是用 Snapshot 元信息从 <code>SnapManager</code> 取到待发送的快照数据，然后将 <code>RaftMessage</code> 和 <code>Snap</code> 一起封装进 <code>SnapChunk</code> 结构，最后创建全新的 gRPC 连接及一个 Snapshot stream 并将 <code>SnapChunk</code> 写入。这里引入 <code>SnapChunk</code> 是为了避免将整块 Snapshot 快照一次性加载进内存，它 impl 了 <code>futures::Stream</code> 这个 trait 来达成按需加载流式发送的效果。如果感兴趣可以参考它的 <a href=\"https://github.com/tikv/tikv/blob/892c12039e0213989940d29c232bddee9cbe4686/src/server/snap.rs#L55-L92\">具体实现</a>，本文就暂不展开了。</p> \n <h3>Snapshot 的收取流程</h3> \n <p>最后我们来简单看一下 Snapshot 的收取流程，其实也就是 gRPC Call 的 server 端对应的处理，整个流程的入口我们可以在 <a href=\"https://github.com/tikv/tikv/blob/892c12039e0213989940d29c232bddee9cbe4686/src/server/service/kv.rs#L714-L729\">server/service/kv.rs</a> 中找到：</p> \n <pre><code class=\"language-rust\">fn snapshot(\n  &amp;mut self,\n  ctx: RpcContext&lt;\'_&gt;,\n  stream: RequestStream&lt;SnapshotChunk&gt;,\n  sink: ClientStreamingSink&lt;Done&gt;,\n) {\n  let task = SnapTask::Recv { stream, sink };\n  if let Err(e) = self.snap_scheduler.schedule(task) {\n      ...\n  }\n}\n</code></pre> \n <p>与发送过程类似，也是直接构建 <code>SnapTask::Recv</code> 任务并转发给 <code>snap-worker</code> 了，这里会调用上面出现过的 <code>recv_snap()</code> 函数，<a href=\"https://github.com/tikv/tikv/blob/892c12039e0213989940d29c232bddee9cbe4686/src/server/snap.rs#L237-L291\">具体实现</a> 如下：</p> \n <pre><code class=\"language-rust\">fn recv_snap&lt;R: RaftStoreRouter + \'static&gt;(\n  stream: RequestStream&lt;SnapshotChunk&gt;,\n  sink: ClientStreamingSink&lt;Done&gt;,\n  ...\n) -&gt; impl Future&lt;Item = (), Error = Error&gt; {\n  ...\n  let f = stream.into_future().map_err(|(e, _)| e).and_then(\n      move |(head, chunks)| -&gt; Box&lt;dyn Future&lt;Item = (), Error = Error&gt; + Send&gt; {\n          let context = match RecvSnapContext::new(head, &amp;snap_mgr) {\n              Ok(context) =&gt; context,\n              Err(e) =&gt; return Box::new(future::err(e)),\n          };\n\n          ...\n          let recv_chunks = chunks.fold(context, |mut context, mut chunk| -&gt; Result&lt;_&gt; {\n              let data = chunk.take_data();\n              ...\n              if let Err(e) = context.file.as_mut().unwrap().write_all(&amp;data) {\n                  ...\n              }\n              Ok(context)\n          });\n\n          Box::new(\n              recv_chunks\n                  .and_then(move |context| context.finish(raft_router))\n                  .then(move |r| {\n                      snap_mgr.deregister(&amp;context_key, &amp;SnapEntry::Receiving);\n                      r\n                  }),\n          )\n      },\n  );\n  f.then(move |res| match res {\n      ...\n  })\n  .map_err(Error::from)\n}\n</code></pre> \n <p>值得留意的是 stream 中的第一个消息（其中包含有 <code>RaftMessage</code>）被用来创建 <code>RecvSnapContext</code> 对象，其后的每个 chunk 收取后都依次写入文件，最后调用 <code>context.finish()</code> 把之前保存的 <code>RaftMessage</code> 发送给 <code>raftstore</code> 完成整个接收过程。</p> \n <h2>总结</h2> \n <p>以上就是 TiKV 发送和接收 Snapshot 相关的代码解析了。这是 TiKV 代码库中较小的一个模块，它很好地解决了由于 Snapshot 消息特殊性所带来的一系列问题，充分应用了 <code>grpc-rs</code> 组件及 <code>futures</code>/<code>FuturePool</code> 模型，大家可以结合本系列文章的 <a href=\"https://pingcap.com/blog-cn/tikv-source-code-reading-7/\">第七篇</a> 和 <a href=\"https://pingcap.com/blog-cn/tikv-source-code-reading-8/\">第八篇</a> 进一步拓展学习。</p> \n <p><strong>原文阅读</strong>：<a href=\"https://www.pingcap.com/blog-cn/tikv-source-code-reading-10/\">https://www.pingcap.com/blog-cn/tikv-source-code-reading-10/</a></p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/83956911f45d368d8b13299e7701a470a35.jpg\" alt=\"\"></p> \n</div>',NULL,'2020-02-09 15:05:24',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226401916444049408',NULL,NULL,' 原型设计：Axure 8.0正式版发布 附下载地址和汉化包   ','<div class=\"content\" id=\"articleContent\">\n  导读：Axure是一个专业的快速原型设计工具。Axure（发音：Ack-sure），代表美国Axure公司；RP则是Rapid Prototyping（快速原型）的缩写。期待已久的Axure 8.0正式版，终于如期而至，今天小编妹妹第一时间收集了MAC和windows版安装包以及Axure8.0汉化包下载地址给大家，产品汪、运营喵、设 计湿、交互蛙....还不赶紧下载？ \n <br> \n <br> 一、Axure 8.0正式版介绍： \n <br> Axure是美国Axure Software Solution公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或Web网站的线框图、 流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。 \n <br> Axure已被一些大公司采用。Axure RP的使用者主要包括商业分析师、信息架构师、可用性专家、产品经理、IT咨询师、用户体验设计师、交互设计师、界面设计师等，另外，架构师、程序开发工程师也在使用Axure。 \n <br> \n <br> 二、Axure 8.0正式版下载地址： \n <br> 1、Windows版本下载地址：http://pan.baidu.com/s/1hrUWpnQ 提取密码: jdxd \n <br> 2、MAC版本下载地址：http://pan.baidu.com/s/1hrUWpnQ 提取密码: jdxd \n <br> \n <br> \n <div> \n  <img src=\"http://static.oschina.net/uploads/img/201605/09214215_WCAp.png\" alt=\"\" height=\"328\" width=\"517\"> \n  <br> \n </div> \n <br> 三、汉化方法 \n <br> 首先退出正在运行中的 Axure (如果您正在使用). \n <br> 将汉化包.rar 文件解压, 得到 lang 文件夹,&nbsp; 然后将整个lang文件夹复制到 Axure 安装目录. \n <br> \n <br> ■ 如果您使用的为 Windows版： \n <br> ① 将&nbsp; lang 文件夹复制到类似 \n <br> c:\\Program Files (x86)\\Axure\\Axure RP Pro 8.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (32位Windows) 或 \n <br> c:\\Program Files\\Axure\\Axure RP Pro 8.0&nbsp;&nbsp; (64位&nbsp; Windows) 目录中; \n <br> ② 启动 Axure 即可看到简体中文界面,&nbsp; 说明已成功汉化,如果仍为英文则一定是汉化文件位置不正确. \n <br> \n <br> ■ 如果您使用的为 MAC 版： \n <br> ① 在 应用程序 文件夹里找到Axure RP Pro 8.app程序，然后右键选择“显示包内容”，然后依次打开Contents/Resources文件夹; \n <br> ②&nbsp; 将 lang 文件夹复制到这个目录下即可; \n <br> ③ 启动 Axure 即可看到简体中文界面, 说明已成功汉化,如果仍为英文则一定是汉化文件位置不正确. \n <br> \n <br> 四、Axure 8.0正式版其他： \n <br> 1、高保真原型对于客户最终决定投资和提交代码之前进行用户测试是非常有帮助的。对于高保真原型建立，Axure RP 8.0将有一些新的功能，使原型更丰富（还纠结神马？赶紧下载体验）。 \n <br> 2、Axure RP 8将让您应用多个动画，并同一时间运行一个小部件，如褪色，同时移动。您还可以动态旋转部件和设置部件形状大小。当设置动态面板的状态时，翻转动画可以同时被应用。 \n <br> 此外，Axure RP 8改进了一些细微而且有用的交互事件。例如，将有两个新的事件 – OnSelected和OnUnselected。这些事件无需添加条件的OnSelectionChanged事件。另外，边界可以在移动动作简化到创 建自定义滑块的过程中设置。中继器的使用在7.0以后开始流行，并且越来越升级，可以支持不同大小的尺寸。 \n <br> \n <p> 3、更多的功能就等你下载体验了，总之，Axure8.0是个重大的升级，带来太多实用功能了。 </p> \n <p> 转自：<a target=\"_blank\" href=\"http://www.adobezcm.com/axurerp/958.html\" rel=\"nofollow\">http://www.adobezcm.com/axurerp/958.html</a>（Adobe注册码） </p> \n</div>',NULL,'2020-02-09 15:06:17',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226402138696024064',NULL,NULL,' TiKV 源码解析系列文章（四）Prometheus（下）  ','<div class=\"content\" id=\"articleContent\"> \n <p><strong>作者： Breezewish</strong></p> \n <blockquote> \n  <p>本文为 TiKV 源码解析系列的第四篇，接上篇继续为大家介绍 <a href=\"https://github.com/pingcap/rust-prometheus\">rust-prometheus</a>。<a href=\"https://www.pingcap.com/blog-cn/tikv-source-code-reading-3/\">上篇</a> 主要介绍了基础知识以及最基本的几个指标的内部工作机制，本篇会进一步介绍更多高级功能的实现原理。</p> \n </blockquote> \n <p>与上篇一样，以下内部实现都基于本文发布时最新的 rust-prometheus 0.5 版本代码，目前我们正在开发 1.0 版本，API 设计上会进行一些简化，实现上出于效率考虑也会和这里讲解的略微有一些出入，因此请读者注意甄别。</p> \n <h2>指标向量（Metric Vector）</h2> \n <p>Metric Vector 用于支持带 Label 的指标。由于各种指标都可以带上 Label，因此 Metric Vector 本身实现为了一种泛型结构体，<a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html\"><code>Counter</code></a>、<a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html\"><code>Gauge</code></a> 和 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html\"><code>Histogram</code></a> 在这之上实现了 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/type.CounterVec.html\"><code>CounterVec</code></a>、<a href=\"https://docs.rs/prometheus/0.5.0/prometheus/type.GaugeVec.html\"><code>GaugeVec</code></a> 和 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/type.HistogramVec.html\"><code>HistogramVec</code></a>。Metric Vector 主要实现位于 <a href=\"https://github.com/pingcap/rust-prometheus/blob/89ca69913691d9d1609c78cc043fca9c3faa1a78/src/vec.rs\">src/vec.rs</a>。</p> \n <p>以 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/type.HistogramVec.html\"><code>HistogramVec</code></a> 为例，调用 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.MetricVec.html#method.with_label_values\"><code>HistogramVec::with_label_values</code></a> 可获得一个 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html\"><code>Histogram</code></a> 实例，而 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/type.HistogramVec.html\"><code>HistogramVec</code></a> 定义为：</p> \n <pre><code class=\"language-rust\">pub type HistogramVec = MetricVec&lt;HistogramVecBuilder&gt;;\n\npub struct MetricVec&lt;T: MetricVecBuilder&gt; {\n   pub(crate) v: Arc&lt;MetricVecCore&lt;T&gt;&gt;,\n}\n\nimpl&lt;T: MetricVecBuilder&gt; MetricVec&lt;T&gt; {\n   pub fn with_label_values(&amp;self, vals: &amp;[&amp;str]) -&gt; T::M {\n       self.get_metric_with_label_values(vals).unwrap()\n   }\n}\n</code></pre> \n <p>因此 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.MetricVec.html#method.with_label_values\"><code>HistogramVec::with_label_values</code></a> 的核心逻辑其实在 <code>MetricVecCore::get_metric_with_label_values</code>。这么做的原因是为了让 <code>MetricVec</code> 是一个线程安全、可以被全局共享但又不会在共享的时候具有很大开销的结构，因此将内部逻辑实现在 <code>MetricVecCore</code>，外层（即在 <code>MetricVec</code>）套一个 <code>Arc&lt;T&gt;</code> 后再提供给用户。进一步可以观察 <code>MetricVecCore</code> 的实现，其核心逻辑如下：</p> \n <pre><code class=\"language-rust\">pub trait MetricVecBuilder: Send + Sync + Clone {\n   type M: Metric;\n   type P: Describer + Sync + Send + Clone;\n\n   fn build(&amp;self, &amp;Self::P, &amp;[&amp;str]) -&gt; Result&lt;Self::M&gt;;\n}\n\npub(crate) struct MetricVecCore&lt;T: MetricVecBuilder&gt; {\n   pub children: RwLock&lt;HashMap&lt;u64, T::M&gt;&gt;,\n   // Some fields are omitted.\n}\n\nimpl&lt;T: MetricVecBuilder&gt; MetricVecCore&lt;T&gt; {\n   // Some functions are omitted.\n\n   pub fn get_metric_with_label_values(&amp;self, vals: &amp;[&amp;str]) -&gt; Result&lt;T::M&gt; {\n       let h = self.hash_label_values(vals)?;\n\n       if let Some(metric) = self.children.read().get(&amp;h).cloned() {\n           return Ok(metric);\n       }\n\n       self.get_or_create_metric(h, vals)\n   }\n\n   pub(crate) fn hash_label_values(&amp;self, vals: &amp;[&amp;str]) -&gt; Result&lt;u64&gt; {\n       if vals.len() != self.desc.variable_labels.len() {\n           return Err(Error::InconsistentCardinality(\n               self.desc.variable_labels.len(),\n               vals.len(),\n           ));\n       }\n\n       let mut h = FnvHasher::default();\n       for val in vals {\n           h.write(val.as_bytes());\n       }\n\n       Ok(h.finish())\n   }\n\n   fn get_or_create_metric(&amp;self, hash: u64, label_values: &amp;[&amp;str]) -&gt; Result&lt;T::M&gt; {\n       let mut children = self.children.write();\n       // Check exist first.\n       if let Some(metric) = children.get(&amp;hash).cloned() {\n           return Ok(metric);\n       }\n\n       let metric = self.new_metric.build(&amp;self.opts, label_values)?;\n       children.insert(hash, metric.clone());\n       Ok(metric)\n   }\n}\n</code></pre> \n <p>现在看代码就很简单了，它首先会依据所有 Label Values 构造一个 Hash，接下来用这个 Hash 在 <code>RwLock&lt;HashMap&lt;u64, T::M&gt;&gt;</code> 中查找，如果找到了，说明给定的这个 Label Values 之前已经出现过、相应的 Metric 指标结构体已经初始化过，因此直接返回对应的实例；如果不存在，则要利用给定的 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/trait.MetricVecBuilder.html\"><code>MetricVecBuilder</code></a> 构造新的指标加入哈希表，并返回这个新的指标。</p> \n <p>由上述代码可见，为了在线程安全的条件下实现 Metric Vector 各个 Label Values 具有独立的时间序列，Metric Vector 内部采用了 <code>RwLock</code> 进行同步，也就是说 <code>with_label_values()</code> 及类似函数内部是具有锁的。这在多线程环境下会有一定的效率影响，不过因为大部分情况下都是读锁，因此影响不大。当然，还可以发现其实给定 Label Values 之后调用 <code>with_label_values()</code> 得到的指标实例是可以被缓存起来的，只访问缓存起来的这个指标实例是不会有任何同步开销的，也绕开了计算哈希值等比较占 CPU 的操作。基于这个思想，就有了 Static Metrics，读者可以在本文的后半部分了解 Static Metrics 的详细情况。</p> \n <p>另外读者也可以发现，Label Values 的取值应当是一个有限的、封闭的小集合，不应该是一个开放的或取值空间很大的集合，因为每一个值都会对应一个内存中指标实例，并且不会被释放。例如 HTTP Method 是一个很好的 Label，因为它只可能是 GET / POST / PUT / DELETE 等；而 Client Address 则很多情况下并不适合作为 Label，因为它是一个开放的集合，或者有非常巨大的取值空间，如果将它作为 Label 很可能会有容易 OOM 的风险。这个风险在 <a href=\"https://prometheus.io/docs/practices/naming/#labels\">Prometheus 官方文档</a>中也明确指出了。</p> \n <h2>整型指标（Integer Metric）</h2> \n <p>在讲解 Counter / Gauge 的实现时我们提到，<a href=\"https://github.com/pingcap/rust-prometheus\">rust-prometheus</a> 使用 CAS 操作实现 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/type.AtomicF64.html\"><code>AtomicF64</code></a> 中的原子递增和递减，如果改用 atomic fetch-and-add 操作则一般可以取得更高效率。考虑到大部分情况下指标都可以是整数而不需要是小数，例如对于简单的次数计数器来说它只可能是整数，因此 <a href=\"https://github.com/pingcap/rust-prometheus\">rust-prometheus</a> 额外地提供了整型指标，允许用户自由地选择，针对整数指标情况提供更高的效率。</p> \n <p>为了增强代码的复用，<a href=\"https://github.com/pingcap/rust-prometheus\">rust-prometheus</a> 实际上采用了泛型来实现 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html\"><code>Counter</code></a> 和 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html\"><code>Gauge</code></a>。通过对不同的 Atomic（如 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/type.AtomicF64.html\"><code>AtomicF64</code></a>、<a href=\"https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html\"><code>AtomicI64</code></a>）进行泛化，就可以采用同一份代码实现整数的指标和（传统的）浮点数指标。</p> \n <p><a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/trait.Atomic.html\"><code>Atomic</code></a> trait 定义如下（<a href=\"https://github.com/pingcap/rust-prometheus/blob/89ca69913691d9d1609c78cc043fca9c3faa1a78/src/atomic64/mod.rs\">src/atomic64/mod.rs</a>）：</p> \n <pre><code class=\"language-rust\">pub trait Atomic: Send + Sync {\n   /// The numeric type associated with this atomic.\n   type T: Number;\n   /// Create a new atomic value.\n   fn new(val: Self::T) -&gt; Self;\n   /// Set the value to the provided value.\n   fn set(&amp;self, val: Self::T);\n   /// Get the value.\n   fn get(&amp;self) -&gt; Self::T;\n   /// Increment the value by a given amount.\n   fn inc_by(&amp;self, delta: Self::T);\n   /// Decrement the value by a given amount.\n   fn dec_by(&amp;self, delta: Self::T);\n}\n</code></pre> \n <p>原生的 <a href=\"https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU64.html\"><code>AtomicU64</code></a>、<a href=\"https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html\"><code>AtomicI64</code></a> 及我们自行实现的 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/type.AtomicF64.html\"><code>AtomicF64</code></a> 都实现了 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/trait.Atomic.html\"><code>Atomic</code></a> trait。进而，<a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html\"><code>Counter</code></a> 和 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericGauge.html\"><code>Gauge</code></a> 都可以利用上 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/trait.Atomic.html\"><code>Atomic</code></a> trait：</p> \n <pre><code class=\"language-rust\">pub struct Value&lt;P: Atomic&gt; {\n   pub val: P,\n   // Some fields are omitted.\n}\n\npub struct GenericCounter&lt;P: Atomic&gt; {\n   v: Arc&lt;Value&lt;P&gt;&gt;,\n}\n\npub type Counter = GenericCounter&lt;AtomicF64&gt;;\npub type IntCounter = GenericCounter&lt;AtomicI64&gt;;\n</code></pre> \n <h2>本地指标（Local Metrics）</h2> \n <p>由前面这些源码解析可以知道，指标内部的实现是原子变量，用于支持线程安全的并发更新，但这在需要频繁更新指标的场景下相比简单地更新本地变量仍然具有显著的开销（大约有 10 倍的差距）。为了进一步优化、支持高效率的指标更新操作，<a href=\"https://github.com/pingcap/rust-prometheus\">rust-prometheus</a> 提供了 Local Metrics 功能。</p> \n <p>rust-prometheus 中 Counter 和 Histogram 指标支持 <code>local()</code> 函数，该函数会返回一个该指标的本地实例。本地实例是一个非线程安全的实例，不能多个线程共享。例如，<a href=\"https://docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html#method.local\"><code>Histogram::local()</code></a> 会返回 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/local/struct.LocalHistogram.html\"><code>LocalHistogram</code></a>。由于 Local Metrics 使用是本地变量，开销极小，因此可以放心地频繁更新 Local Metrics。用户只需定期调用 Local Metrics 的 <code>flush()</code> 函数将其数据定期同步到全局指标即可。一般来说 Prometheus 收集数据的间隔是 15s 到 1 分钟左右（由用户自行配置），因此即使是以 1s 为间隔进行 <code>flush()</code> 精度也足够了。</p> \n <p>普通的全局指标使用流程如下图所示，多个线程直接利用原子操作更新全局指标：</p> \n <p><img src=\"https://upload-images.jianshu.io/upload_images/542677-4988249c80094124.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"normal_metrics\"></p> \n <p>本地指标使用流程如下图所示，每个要用到该指标的线程都保存一份本地指标。更新本地指标操作开销很小，可以在频繁的操作中使用。随后，只需再定期将这个本地指标 flush 到全局指标，就能使得指标的更新操作真正生效。</p> \n <p><img src=\"https://upload-images.jianshu.io/upload_images/542677-76c3720e430298ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"local_metrics\"></p> \n <p>TiKV 中大量运用了本地指标提升性能。例如，<a href=\"https://github.com/tikv/tikv/blob/56c1c6c2fbf6e357e0778b81f41343c52c91fddf/src/util/futurepool.rs\">TiKV 的线程池</a>一般都提供 <a href=\"https://github.com/tikv/tikv/blob/56c1c6c2fbf6e357e0778b81f41343c52c91fddf/src/util/futurepool.rs#L284\"><code>Context</code></a> 变量，<code>Context</code> 中存储了本地指标。线程池上运行的任务都能访问到一个和当前 worker thread 绑定的 <code>Context</code>，因此它们都可以安全地更新 <code>Context</code> 中的这些本地指标。最后，线程池一般提供 <a href=\"https://github.com/tikv/tikv/blob/56c1c6c2fbf6e357e0778b81f41343c52c91fddf/src/util/futurepool.rs#L50\"><code>tick()</code></a> 函数，允许以一定间隔触发任务，<a href=\"https://github.com/tikv/tikv/blob/56c1c6c2fbf6e357e0778b81f41343c52c91fddf/src/coprocessor/readpool_context.rs#L50\">在 <code>tick()</code> 中 TiKV 会对这些 <code>Context</code> 中的本地指标进行 <code>flush()</code></a>。</p> \n <h3>Local Counter</h3> \n <p><a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html\"><code>Counter</code></a> 的本地指标 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericLocalCounter.html\"><code>LocalCounter</code></a> 实现很简单，它是一个包含了计数器的结构体，该结构体提供了与 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericCounter.html\"><code>Counter</code></a> 一致的接口方便用户使用。该结构体额外提供了 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/core/struct.GenericLocalCounter.html#method.flush\"><code>flush()</code></a>，将保存的计数器的值作为增量值更新到全局指标：</p> \n <pre><code class=\"language-rust\">pub struct GenericLocalCounter&lt;P: Atomic&gt; {\n   counter: GenericCounter&lt;P&gt;,\n   val: P::T,\n}\n\npub type LocalCounter = GenericLocalCounter&lt;AtomicF64&gt;;\npub type LocalIntCounter = GenericLocalCounter&lt;AtomicI64&gt;;\n\nimpl&lt;P: Atomic&gt; GenericLocalCounter&lt;P&gt; {\n   // Some functions are omitted.\n\n   pub fn flush(&amp;mut self) {\n       if self.val == P::T::from_i64(0) {\n           return;\n       }\n       self.counter.inc_by(self.val);\n       self.val = P::T::from_i64(0);\n   }\n}\n</code></pre> \n <h3>Local Histogram</h3> \n <p>由于 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html\"><code>Histogram</code></a> 本质也是对各种计数器进行累加操作，因此 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/local/struct.LocalHistogram.html\"><code>LocalHistogram</code></a> 的实现也很类似，例如 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/local/struct.LocalHistogram.html#method.observe\"><code>observe(x)</code></a> 的实现与 <a href=\"https://docs.rs/prometheus/0.5.0/prometheus/struct.Histogram.html\"><code>Histogram</code></a> 如出一辙，除了它不是原子操作；<a href=\"https://docs.rs/prometheus/0.5.0/prometheus/local/struct.LocalHistogram.html#method.flush\"><code>flush()</code></a> 也是将所有值累加到全局指标上去：</p> \n <pre><code class=\"language-rust\">pub struct LocalHistogramCore {\n   histogram: Histogram,\n   counts: Vec&lt;u64&gt;,\n   count: u64,\n   sum: f64,\n}\n\nimpl LocalHistogramCore {\n   // Some functions are omitted.\n\n   pub fn observe(&amp;mut self, v: f64) {\n       // Try find the bucket.\n       let mut iter = self\n           .histogram\n           .core\n           .upper_bounds\n           .iter()\n           .enumerate()\n           .filter(|&amp;(_, f)| v &lt;= *f);\n       if let Some((i, _)) = iter.next() {\n           self.counts[i] += 1;\n       }\n\n       self.count += 1;\n       self.sum += v;\n   }\n\n   pub fn flush(&amp;mut self) {\n       // No cached metric, return.\n       if self.count == 0 {\n           return;\n       }\n       {\n           let h = &amp;self.histogram;\n           for (i, v) in self.counts.iter().enumerate() {\n               if *v &gt; 0 {\n                   h.core.counts[i].inc_by(*v);\n               }\n           }\n           h.core.count.inc_by(self.count);\n           h.core.sum.inc_by(self.sum);\n       }\n       self.clear();\n   }\n}\n</code></pre> \n <h2>静态指标（Static Metrics）</h2> \n <p>之前解释过，对于 Metric Vector 来说，由于每一个 Label Values 取值都是独立的指标实例，因此为了线程安全实现上采用了 HashMap + RwLock。为了提升效率，可以将 <code>with_label_values</code> 访问获得的指标保存下来，以后直接访问。另外使用姿势正确的话，Label Values 取值是一个有限的、确定的、小的集合，甚至大多数情况下在编译期就知道取值内容（例如 HTTP Method）。综上，我们可以直接写代码将各种已知的 Label Values 提前保存下来，之后可以以静态的方式访问，这就是静态指标。</p> \n <p>以 TiKV 为例，有 Contributor 为 TiKV 提过这个 PR：<a href=\"https://github.com/tikv/tikv/pull/2765\">#2765 server: precreate some labal metrics</a>。这个 PR 改进了 TiKV 中统计各种 gRPC 接口消息次数的指标，由于 gRPC 接口是固定的、已知的，因此可以提前将它们缓存起来：</p> \n <pre><code class=\"language-rust\">struct Metrics {\n   kv_get: Histogram,\n   kv_scan: Histogram,\n   kv_prewrite: Histogram,\n   kv_commit: Histogram,\n   // ...\n}\n\nimpl Metrics {\n   fn new() -&gt; Metrics {\n       Metrics {\n           kv_get: GRPC_MSG_HISTOGRAM_VEC.with_label_values(&amp;[\"kv_get\"]),\n           kv_scan: GRPC_MSG_HISTOGRAM_VEC.with_label_values(&amp;[\"kv_scan\"]),\n           kv_prewrite: GRPC_MSG_HISTOGRAM_VEC.with_label_values(&amp;[\"kv_prewrite\"]),\n           kv_commit: GRPC_MSG_HISTOGRAM_VEC.with_label_values(&amp;[\"kv_commit\"]),\n           // ...\n       }\n   }\n}\n</code></pre> \n <p>使用的时候也很简单，直接访问即可：</p> \n <pre><code class=\"language-diff\">@@ -102,10 +155,8 @@ fn make_callback&lt;T: Debug + Send + \'static&gt;() -&gt; (Box&lt;FnBox(T) + Send&gt;, oneshot:\n\nimpl&lt;T: RaftStoreRouter + \'static&gt; tikvpb_grpc::Tikv for Service&lt;T&gt; {\n    fn kv_get(&amp;self, ctx: RpcContext, mut req: GetRequest, sink: UnarySink&lt;GetResponse&gt;) {\n-        let label = \"kv_get\";\n-        let timer = GRPC_MSG_HISTOGRAM_VEC\n-            .with_label_values(&amp;[label])\n-            .start_coarse_timer();\n+        const LABEL: &amp;str = \"kv_get\";\n+        let timer = self.metrics.kv_get.start_coarse_timer();\n\n        let (cb, future) = make_callback();\n        let res = self.storage.async_get(\n</code></pre> \n <p>这样一个简单的优化可以为 TiKV 提升 7% 的 Raw Get 效率，可以说是很超值了（主要原因是 Raw Get 本身开销极小，因此在指标上花费的时间就显得有一些显著了）。但这个优化方案其实还有一些问题：</p> \n <ol> \n  <li> <p>代码繁琐，有大量重复的、或满足某些 pattern 的代码；</p> </li> \n  <li> <p>如果还有另一个 Label 维度，那么需要维护的字段数量就会急剧膨胀（因为每一种值的组合都需要分配一个字段）。</p> </li> \n </ol> \n <p>为了解决以上两个问题，<a href=\"https://github.com/pingcap/rust-prometheus\">rust-prometheus</a> 提供了 <a href=\"https://github.com/pingcap/rust-prometheus/tree/master/static-metric\">Static Metric 宏</a>。例如对于刚才的 TiKV 改进 PR #2765 来说，使用 Static Metric 宏可以简化为：</p> \n <pre><code class=\"language-rust\">make_static_metric! {\n   pub struct GrpcMsgHistogram: Histogram {\n       \"type\" =&gt; {\n           kv_get,\n           kv_scan,\n           kv_prewrite,\n           kv_commit,\n           // ...\n       },\n   }\n}\n\nlet metrics = GrpcMsgHistogram::from(GRPC_MSG_HISTOGRAM_VEC);\n\n// Usage:\nmetrics.kv_get.start_coarse_timer();\n</code></pre> \n <p>可以看到，使用宏之后，需要维护的繁琐的代码量大大减少了。这个宏也能正常地支持多个 Label 同时存在的情况。</p> \n <p>限于篇幅，这里就不具体讲解这个宏是如何写的了，感兴趣的同学可以观看我司同学最近在 FOSDEM 2019 上的技术分享 <a href=\"https://fosdem.org/2019/schedule/event/rust_prometheus/\">视频</a>（进度条 19:54 开始介绍 Static Metrics）和 <a href=\"https://fosdem.org/2019/schedule/event/rust_prometheus/attachments/slides/3301/export/events/attachments/rust_prometheus/slides/3301/Introducing_Rust_Prometheus.pdf\">Slide</a>，里面详细地介绍了如何从零开始写出一个这样的宏（的简化版本）。</p> \n <p><img src=\"http://upload-images.jianshu.io/upload_images/542677-21caeb79834fadd8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p> \n</div>',NULL,'2020-02-09 15:07:10',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226402359685513216',NULL,NULL,' Mac OS下安装Axure RP 8.0.0.3312 中文破解版  ','<div class=\"content\" id=\"articleContent\"> \n <p>Mac下一款快速原型设计工具——Axure RP，有了它可以大大提高你的工作效率。此次带来的是Axure RP 8.0.0.3312 版本。</p> \n <span id=\"OSC_h2_1\"></span> \n <h2>介绍</h2> \n <p>Axure RP 能帮助网站需求设计者，快捷而简便的创建基于网站构架图的带注释页面示 意图、操作流程图、以及交互设计，并可自动生成用于演示的网页文件和规格文件，以提供演示与开发。</p> \n <p>Axure RP是美国Axure Software Solution公司旗舰产品，是一个专业的快速原型设计工具，让负责定义需求和规格、设计功能和界面的专家能够快速创建应用软件或Web网站的线框图、流程图、原型和规格说明文档。作为专业的原型设计工具，它能快速、高效的创建原型，同时支持多人协作设计和版本控制管理。</p> \n <span id=\"OSC_h2_2\"></span> \n <h2>安装</h2> \n <p>1.打开dmg镜像，将“Axure RP 8.app”拖入应用程序中；</p> \n <p>2.打开应用程序中的“Axure RP 8.app”，点击“Enter license”（红色方框处）弹出注册框；</p> \n <p>3.打开“SN.txt”，将对应序列号填入注册框中；</p> \n <p>4.解压汉化包zip文件，根据里面的说明完成汉化。</p> \n <blockquote> \n  <p>操作系统版本要求：OS X 10.7 或更高。</p> \n </blockquote> \n <span id=\"OSC_h2_3\"></span> \n <h2>资源</h2> \n <p>链接:<a href=\"https://link.jianshu.com?t=https%3A%2F%2Fpan.baidu.com%2Fs%2F1htE7GCO\" target=\"_blank\" rel=\"nofollow\">https://pan.baidu.com/s/1htE7GCO</a><br> 密码:ffbr</p> \n <p><br> <br> 作者：RebeccaYan<br> 链接：https://www.jianshu.com/p/6bbddb0b201d<br> 來源：简书<br> 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p> \n</div>',NULL,'2020-02-09 15:08:03',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226402586773520384',NULL,NULL,' 设置交互要多久？最快只需三秒！  ','<div class=\"content\" id=\"articleContent\"> \n <p>原型设计分为两种，一种是静态的线框图，我们一般叫wireframing；另一种是动态的原型，一般叫作prototyping。目前在prototyping设计中涉及到的交互主要分为三种：页链接、交互状态和组件之间的交互。而动态原型的设计工具中比较常见的能够包括这三种交互设置功能的也有很多，比如：Axure、Justinmind、Mockplus和Proto.io等等，种类之多，数不胜数。但是，这些工具无一例外，都在宣传自己的过程中说自己是快捷迅速的。我们平时说的Axure，全名叫做Axure RP，而RP代表的意思恰恰就是Rapid Prototyping（快速设计原型）；Mockplus也说自己是更快更简单的原型设计工具。既然都说自己是快速简单，我们今天就来比较实际操作一下，你们到底有多快。</p> \n <p>页链接设置：速度平分秋色，可视化体现差异</p> \n <p>在Axure所有的交互设置中，页面链接是最简单的一种了，只需要点击右侧属性面板中的创建链接，并在下拉菜单中选中需要跳转的页面就可以了。但是Axure在这一过程中有一个明显的不足，就是对于可视化的缺失。如果在这个项目中各个页面的名称比较相近，那么这样使很发生链接错的情况的。</p> \n <p>而Justinmind应该是也体会到了Axure的这一问题，它采用的是一种拖拽的方式来实现页链接的设置。但是这似乎并没有真正的解决可视化的问题。因为，这个表示拖拽的图标实在太小了。</p> \n <p><img alt=\"\" height=\"400\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/e7d8c31d-fa32-4fc4-ae63-2dafb55a7375.jpg\" width=\"600\"></p> \n <p>如果说Axure和Justinmind比较相似，那么Proto.io和Mockplus也应该是一见如故了。两者都采用了拖拽链接点的方式来进行页链接设置的操作，而且这个拖拽的过程是有明显的链接线显示的。这就大大提高了可视化，从而降低了操作的难度。更加可贵的是，Mockplus中组件的链接点在停留在页面上的时候还会显示该页面的缩略图，这使得错误链接的可能性降到了最低。</p> \n <p><img alt=\"\" height=\"400\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/02ddf76f-e048-4457-b9fe-26a55ec7d1ae.png\" width=\"600\"></p> \n <p>组件交互设置：速度差异开始变得明显</p> \n <p>这里的设置中，四款工具的在交互设置上的速度差别就体现出来一些了。Axure在这里采用的方法是点击添加用例，然后弹出一个设置的面板，在面板中选择对应的命令，交互动作，和动效。Justinmind还是察觉到了Axure这里设置的不方便，但是，就像页链接的设置一样，Justinmind也还是没有拿出更好的解决办法。设置中Justinmind沿用了Axure的模式，只是在选择的过程中采用了下拉菜单。虽然在选择目标时使用了可视化的窗口，但并没有从根本上解决操作繁琐的问题。</p> \n <p><img alt=\"\" height=\"400\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/c5148605-d635-4d4d-aacd-bbf71b86b713.png\" width=\"600\"></p> \n <p>反观两个年轻人，Mockplus和Proto.io在组件交互设置的模式上使用了更加简单快捷的拖拽，也就是在各种工具中流行的Drag-and-Drop。只是简单的对链接点的拖动就可以实现组件之间的交互。Mockplus的命令选择相对更加直接，Proto.io的交互命令可能还需要在进一步的进行调整。这种在交互设置上的拖拽模式和高度的可视化，使得操作中目标更加明确，动作更加清晰，Proto.io的组件大纲的功能也使得组件之间的关系更加有条理。Mockplus也在计划推出相应的功能，这里我们一起期待一下吧。</p> \n <p><img alt=\"\" height=\"400\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/0d160445-c268-4a57-9821-87ff7e6757a1.png\" width=\"600\"></p> \n <p>组件交互状态设置：Mockplus只需三秒。</p> \n <p>作为一款新兴的原型设计工具，Mockplus不断强调自己快速和敏捷。在大部分原型设计工具软件没有为组件的交互状态单独设置功能选项的时候，Mockplus已经有了相对完善的组件交互状态设置的体系。主要的操作体现在属性面板中，这个闪电一样的标志就是交互状态设置的按钮，在弹出的面板中，可以设置鼠标经过和鼠标落下两种状态。而并不是像Axure、Justinmind或者Proto.io那样把交互状态作为一种组件之间的交互来设置。这个功能看似简单，但是它从这一个方向推动着原型设计向着更简单、更快速靠拢。像这样改变颜色的交互状态设置，三秒足够了！</p> \n <p><img alt=\"\" height=\"400\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/095b14b0-7864-4e11-87e9-a9ff52f81391.png\" width=\"600\"></p> \n <p>我们不可否认，Axure和Justinmind在功能的全面性上确实占有优势，但是我们也一样能够像Mockplus这种新兴的力量的崛起。随着行业发展，大家对原型设计工具需求和要求不断提高，希望这样的新力量会带给我们更多的惊喜。</p> \n</div>',NULL,'2020-02-09 15:08:57',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226402808811585536',NULL,NULL,' Spring MVC温故而知新 – 从零开始  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h2_1\"></span> \n <h2>Spring MVC简介</h2> \n <p>Spring MVC是一款基于MVC架构模式的轻量级Web框架，目的是将Web开发模块化，对整体架构进行解耦。</p> \n <p>Spring MVC有一下优点：</p> \n <p>作为Spring框架的一部分，拥有Spring的优点（IOC,AOP等）</p> \n <p>支持灵活的URL到页面控制器的映射</p> \n <p>提供灵活的数据验证、格式化、数据绑定机制</p> \n <p>支持RESTful风格</p> \n <span id=\"OSC_h2_2\"></span> \n <h2>Spring MVC请求流程</h2> \n <p>Spring MVC框架的整体请求流程如下：</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180518000218660-450095568.png\"></p> \n <p>&nbsp;</p> \n <p>上图中涉及到Spring MVC的几个功能组件：</p> \n <p><strong>前端控制器(DispatcherServlet)</strong>：接收用户请求并返回请求结果。它的作用相当于一个转发器或中央处理器，控制整个执行流程，对各逐渐进行调度降低组件之间的耦合。</p> \n <p><strong>处理器映射器(HandlerMapping)</strong>：根据用户请求的URL，通过注解或者XML配置，查找相应的处理器Handler</p> \n <p><strong>处理器适配(HandlerAdapter)</strong>：根据映射器查找出的Handler，完成调用处理器中的方法</p> \n <p><strong>处理器(Handler)</strong>：请求处理的具体逻辑，返回数据和视图信息</p> \n <p><strong>视图解析器(View Resolver)</strong>：解析具体视图，通过ModelAndView对象中的View信息，将逻辑视图名解析成真正的视图View</p> \n <p>&nbsp;请求流程具体步骤详解：</p> \n <p>1：用户发起请求，请求会被前端控制器(DispatcherServlet)拦截</p> \n <p>2：前端控制器(DispatcherServlet)请求处理器映射器(HandlerMapping)查找Handler</p> \n <p>3：处理器映射器(HandlerMapping)根据配置找到相应Handler（可以更具注解或者XML配置），可能包含多个Interceptor拦截器，返回给前端控制器</p> \n <p>4：前端控制器(DispatcherServlet)请求处理器适配器(HandlerAdapter)去执行相应的Handler</p> \n <p>5：适配器交由对应Handler处理器执行</p> \n <p>6: &nbsp;Handler处理器执行完成后返回ModelAndView对象给处理器适配器</p> \n <p>7：处理器适配器接受Handler处理器的返回结果，并将该结果返回给前端控制器(DispatcherServlet)</p> \n <p>8：前端控制器(DispatcherServlet)接收处理器适配器返回的数据和视图信息，请求视图解析器，解析对应的视图</p> \n <p>9：视图解析器根据View信息匹配的相应的视图结果，反回给前端控制器</p> \n <p>10:前端控制器接收具体视图，进行视图渲染，将Model数据填充到View视图中，生成最终视图</p> \n <p>11：前端控制器向用户返回结果</p> \n <span id=\"OSC_h2_3\"></span> \n <h2>从零开始搭建demo</h2> \n <span id=\"OSC_h4_4\"></span> \n <h4>&nbsp; 创建工程:</h4> \n <p>Eclipse下新建一个动态Web项目</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517234848194-267825716.png\"></p> \n <p>工程默认目录结构：</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517234859671-1326525459.png\"></p> \n <span id=\"OSC_h4_5\"></span> \n <h4>添加jar包依赖</h4> \n <p>WebContent &gt; WEB-INF &gt; lib 文件夹下导入相应的jar包，其中核心的jar包是spring-webmvc-5.0.0.RELEASE.jar，其他是几个主要是spring用于管理上下文和beande 包、jstl标签库和一个用于打印日志的log包：</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517234939619-1967526227.png\"></p> \n <span id=\"OSC_h4_6\"></span> \n <h4>在web.xml中配置前端控制器</h4> \n <p>&nbsp;前端控制器相当于Spring MVC的专有servlet,用于拦截所有符合条件的请求，交由框架做后续处理</p> \n <pre><code class=\"language-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n        xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" \n        xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" \n        id=\"WebApp_ID\" \n        version=\"3.1\"&gt;\n        \n  &lt;!-- 配置前端控制器-DispatchServlet  --&gt;\n  &lt;servlet&gt;\n  &lt;servlet-name&gt;springMvcNext&lt;/servlet-name&gt;\n  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n\n  &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+\"-servlet.xml\" --&gt;\n  &lt;init-param&gt;\n          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;\n  &lt;/init-param&gt;\n  &lt;/servlet&gt;\n  \n  &lt;servlet-mapping&gt;\n  &lt;servlet-name&gt;springMvcNext&lt;/servlet-name&gt;\n  &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!--根据url-pattern设定的规则拦截用户发来的请求 此处拦截所有请求，包括静态资源 -&gt;\n  &lt;/servlet-mapping&gt;\n \n&lt;/web-app&gt;</code></pre> \n <p>其中&lt;servlet-mapping&gt;标签中定义url匹配规则为符合*.action的形式，对应的servlet名为springMvcNext，而&lt;servlet&gt;配置的控制器为org.springframework.web.servlet.DispatchServlet，该控制器为当前SpringMVC项目的前端控制器，&lt;init-param&gt;标签为当前控制器依赖的参数，两个参数分别代表上下文参数和参数加载路径。</p> \n <p>关于classpath:代表web项目编译后编译后的输出路径</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235200982-952791777.png\"></p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235218782-921649858.png\"></p> \n <span id=\"OSC_h4_7\"></span> \n <h4>配置spring MVC配置</h4> \n <p>在java源代码更目录下添加applicationContext.xml文件</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235251846-792865026.png\"></p> \n <p>具体内容：</p> \n <pre><code class=\"language-java\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;!-- 包扫描器  标签将用于激活Spring MVC注释扫描功能，允许使用@Controller和@RequestMapping等注释。--&gt;\n    &lt;context:component-scan base-package=\"com.sl.controller\" /&gt;\n    \n    &lt;!-- 注解驱动 --&gt;\n    &lt;mvc:annotation-driven /&gt;\n    \n    &lt;!-- 配置视图解析器 --&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"  id=\"internalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"/WEB-INF/view/\" /&gt;\n        &lt;property name=\"suffix\" value=\".jsp\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre> \n <span id=\"OSC_h4_8\"></span> \n <h4>&nbsp; 添加控制器Controller与视图View</h4> \n <p>&nbsp;<img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235340897-770943482.png\">&nbsp;</p> \n <p>Src目录下添加包com.sl.controller，添加控制器代码如下:</p> \n <pre><code class=\"language-java\">package com.sl.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\npublic class HelloWorldController {\n    \n    @RequestMapping(\"/index\")  //处理URL路径中以/index开头的所有请求： 包括 /index/* 和 /index.html\n    public ModelAndView helloWorld() {\n\n        String message = \"Hello Spring MVC\";\n        return new ModelAndView(\"index\", \"message\", message);\n    }\n}</code></pre> \n <p>在WEB-INF/view中添加视图文件index.jsp</p> \n <pre><code class=\"language-java\">&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Spring MVC &lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    ${message}\n&lt;/body&gt;\n&lt;/html&gt;</code></pre> \n <p>运行结果：</p> \n <p><img alt=\"\" src=\"https://images2018.cnblogs.com/blog/577318/201805/577318-20180517235503837-1937594215.png\"></p> \n</div>',NULL,'2020-02-09 15:09:50',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226403029994012672',NULL,NULL,' 10个最新优秀手机应用界面设计实例  ','<div class=\"content\" id=\"articleContent\"> \n <p>优秀的手机端应用界面设计不仅能让用户眼前一亮，同时也能为UX/UI&nbsp;设计师完成iOS或Android手机应用界面设计带来全新的设计灵感。这也就解释了为什么设计师们会花费很多时间搜寻各种设计素材和作品的原因。所以，为方便设计师使用，这里为大家整理了10款最新优秀手机端应用设计作品，也希望对广大UX/UI&nbsp;设计师朋友有所帮助：</p> \n <p>&nbsp;</p> \n <p><strong>1).&nbsp;<a href=\"https://www.behance.net/gallery/59021155/YONOMP3-mobile-app\" target=\"_blank\" rel=\"nofollow\">YONO.MP3 mobile app</a>&nbsp;-&nbsp;音乐软件</strong></p> \n <p>*设计师：Anton Shmatko, Green Shark Studio, Pavel Khenkin</p> \n <p>*软件介绍：</p> \n <p>YONO.MP3是一款即可欣赏音乐, 也可收听广播节目, 了解最新时讯和趣事的手机端音乐软件。它会是你闲暇时搜索和分享歌曲，歌手和专辑的理想工具。</p> \n <p>*亮点:</p> \n <p>该款软件采用了一个极具特色的配色方案&nbsp;— 所有界面整体使用黑红两种颜色的对比， 经典而不失大气。 而局部渐变色的使用,&nbsp;也让其功能和按钮更加突出，极具层次感。而且,&nbsp;软件图片,&nbsp;按钮和图标的层级叠加,&nbsp;也使整个界面更加的时尚柔和。总之，软件界面设计整体简洁漂亮而不失易用性。</p> \n <p>&nbsp;<img alt=\"\" height=\"532\" src=\"http://img.pmcaff.com/Fgd8enalW47vtL-G0GS-m-Dxf8dW-picture\" width=\"901\"></p> \n <p><strong>2).&nbsp;</strong><a href=\"https://dribbble.com/shots/3997043-Watering-Tracker-App\" target=\"_blank\" rel=\"nofollow\"><strong>Watering Tracker App</strong></a><strong>&nbsp;-&nbsp;生活类软件</strong></p> \n <p>*设计师：Tubik</p> \n <p>*软件介绍：</p> \n <p>Watering Tracker app,&nbsp;顾名思义，就是一款可以追踪盆栽或植物的水分情况，及时提醒用户浇水的生活类手机应用。</p> \n <p>*亮点:</p> \n <p>首先，这种能够监测植物水分情况，通知用户浇水的创意，新颖且有趣。其次，界面背景和局部添加的绿色植物图片使整个界面更加的直观舒适，带给用户好心情。&nbsp;当然，作为植物监测的工具，同时也设置了显示各株植物水分，湿度，光照之类细节信息的功能区，即点即可了解到植物的具体生长情况，简单易操作。而且，配色方面，黑色背景搭配白色和绿色图片及按钮，符合整个植物主题的同时，也更易于用户接受和使用。</p> \n <p><img alt=\"\" height=\"457\" src=\"http://img.pmcaff.com/Ftj_ydRmxMeOUtBgnEkR7ZOT13ep-picture\" width=\"901\"></p> \n <p>&nbsp;</p> \n <p><strong>3).&nbsp;</strong><a href=\"https://dribbble.com/shots/4002107-Listen\" target=\"_blank\" rel=\"nofollow\"><strong>Listen</strong></a><strong>&nbsp;-&nbsp;音乐软件</strong></p> \n <p>*设计师：CD UXT</p> \n <p>*软件介绍：</p> \n <p>Listen是一款致力于为喜爱不同音乐风格的用户提供独特且愉悦体验的音乐软件。整个界面设计简洁清晰，用户可以简单的通过不同频道（例如最新歌曲，电台，主体和专辑等）和不同场景（例如驾车，运动，工作和约会等）快速的搜寻到最喜爱的歌曲。而且，软件还特别为用户提供了根据不同心情播放不同音乐列表的功能，更具个性。总之，喜欢闲暇时沉浸在自己的音乐世界的你，它会是你最佳的选择。</p> \n <p>*亮点:</p> \n <p>软件整体采用经典的蓝色背景搭配白色字体和同色系图片，更加柔和舒适。一系列插画风格&nbsp;的场景和频道对应图片，也使整个界面设计更加美观有趣。结合明亮阴影的图标和按钮让软件对应功能更加凸显的同时，&nbsp;更能易于用户识别使用。&nbsp;针对不同部件添加的灵活交互，也能够使用户具有更加流畅且愉悦的体验。总之，它是一款以用户愉悦体验为基础而设计的软件原型（<a href=\"http://www.mockplus.cn/?hmsr=wen\" target=\"_blank\" rel=\"nofollow\">Mockplus</a>），值得尝试。（<a href=\"https://www.mockplus.cn/ux2017/show/AVmsj\" target=\"_blank\" rel=\"nofollow\">点击这里查看原型详情</a>）</p> \n <p>&nbsp;<img alt=\"\" height=\"600\" src=\"http://img.pmcaff.com/Fgs5xrLBawqJNWSAC1HHr8iu2HvZ-picture\" width=\"800\"></p> \n <p><strong>4).&nbsp;</strong><a href=\"https://dribbble.com/shots/3969334-Coffee-Ordering-App-Concept\" target=\"_blank\" rel=\"nofollow\"><strong>NightOwl Coffee</strong></a><strong>&nbsp;-&nbsp;咖啡预定软件</strong></p> \n <p>*设计师：Queble Solutions</p> \n <p>*软件介绍：</p> \n <p>NightOwl Coffee是一款能够帮助用户根据自己的需要快速订购各式咖啡的手机应用软件。</p> \n <p>*亮点:</p> \n <p>软件整体采用了独具特设的插画风：主页添加的由明亮颜色和各种几何元素呈现的卡通咖啡机，可爱且切合主题。纯色的背景搭配上灰色插画以及黄色图标和按钮，使整个软件界面更加干净整洁，易于用户使用。</p> \n <p>&nbsp;<img alt=\"\" height=\"628\" src=\"http://img.pmcaff.com/FozwUnjAxGYeB99PDSpvT4BJQ05d-picture\" width=\"900\"></p> \n <p><strong>5).&nbsp;</strong><a href=\"https://dribbble.com/shots/3985481-Roomframes-app\" target=\"_blank\" rel=\"nofollow\"><strong>Roomframes app</strong></a><strong>&nbsp;-&nbsp;管理型软件</strong></p> \n <p>*设计师：Adrain Rudzik</p> \n <p>*软件介绍：</p> \n <p>Roomframe app是一款适用于iOS手机端的应用软件，能够帮助用户记录并珍藏他们所旅行过的地方的相关记忆，尤其是他们旅行中所居住过的房间的珍贵记忆。所以，从这方面来讲，它是一款生活管理型手机应用。</p> \n <p>*亮点:</p> \n <p>软件多处使用了框架设计，方便用户根据不同的旅店，工作区和相关新增地点，添加对应的日期，图片和描述。其简单的白色背景，使用户信息更加明显，也易于用户随时回顾或与家人朋友分享这些难忘的回忆。</p> \n <p><img alt=\"\" height=\"599\" src=\"http://img.pmcaff.com/Ft9DHKKtLNniSERKCrEMPbiPUw25-picture\" width=\"900\"></p> \n <p>&nbsp;</p> \n <p><strong>6).&nbsp;</strong><a href=\"https://dribbble.com/shots/4018136-iOS-App-Slide-Car\" target=\"_blank\" rel=\"nofollow\"><strong>iOS App Slide Car</strong></a><strong>&nbsp;-&nbsp;生活类软件</strong></p> \n <p>*设计师：Melany Roa</p> \n <p>*软件介绍：</p> \n <p>iOS App Slider Car是一款专门针对iOS手机研发的应用软件，能够帮助用户分类搜索各式汽车信息，并实现在线交易的一种手机端应用。同时，它也是一款能够帮助用户结交不同汽车爱好者的社交工具。</p> \n <p>*亮点:</p> \n <p>简单纯色的背景，使用户专注于汽车图片，价格，描述和所有者等信息。搜索界面添加各种搜索参数，用户简单点击即可实现汽车信息搜索。总之，整个界面简单，整洁而实用。</p> \n <p><img alt=\"\" height=\"600\" src=\"http://img.pmcaff.com/Fr1YTRE6YzyBUwpQOJHt-KtVPVt3-picture\" width=\"800\"></p> \n <p>&nbsp;</p> \n <p><strong>7).&nbsp;</strong><a href=\"https://www.behance.net/gallery/59625729/UI-Design-for-Karoline-shop-app\" target=\"_blank\" rel=\"nofollow\"><strong>Karoline</strong></a><strong>&nbsp;-&nbsp;购物软件</strong></p> \n <p>*设计师：Varduhi Adami</p> \n <p>*软件介绍：</p> \n <p>Karoline是一款手机端服装购物软件，提供了各类服装的详细信息和购买渠道。</p> \n <p>*亮点:</p> \n <p>软件整体的粉色系配色，柔和甜美，对女性购买者极具吸引力。所有界面以服装图片为主，更易于用户根据喜好挑选。而且，添加的简单且易识别的图标和按钮，方便用户搜索和查询相关服装细节。软件界面丰富，例如主页，我的账号，我的订单，我的购物车，要请朋友，设置，购买等，能够满足用户购买时各方面的需求。所以，如果你有通过手机在线购买服装的打算，它会是不是错的尝试。</p> \n <p><img alt=\"\" height=\"1400\" src=\"http://img.pmcaff.com/FmWTukJrYIJoLqndulPTF4Ihiqe4-picture\" width=\"1400\"></p> \n <p><strong>8).</strong><a href=\"https://www.behance.net/gallery/58833071/Space\" target=\"_blank\" rel=\"nofollow\"><strong>Space</strong></a><strong>&nbsp;-&nbsp;管理类软件</strong>&nbsp;</p> \n <p>*设计师：Doeun Shin</p> \n <p>*软件介绍：</p> \n <p>Space是一款能够帮助用户更加有效的管理日常生活的手机端应用。主要提供了两项特色服务：早上，自动结合用户的日常习惯，提供有用的日程管理信息和建议，例如交通和天气情况等； 晚上，通过自动分析用户语音日记，提供符合用户心情的主体和提示音等等。</p> \n <p>*亮点:</p> \n <p>该软件以插画风为基础，添加了各式动画按钮及图片，直观生动。蓝色主题，漂亮舒适，无论早上还是晚上使用，用户都不会反感。而且，软件本身添加多样的功能性界面，例如语音日记，心情日历，日常服务，节日简介等等，简单全面。总之是一款极具吸引力的管理软件。</p> \n <p>&nbsp;<img alt=\"\" height=\"723\" src=\"http://img.pmcaff.com/FrXR8JS0xS0i24gwUjMu8_955zTI-picture\" width=\"1200\"></p> \n <p>&nbsp;</p> \n <p><strong>9).</strong><a href=\"https://www.behance.net/gallery/59667409/QuickBee\" target=\"_blank\" rel=\"nofollow\"><strong>QuickBee</strong></a><strong>&nbsp;-&nbsp;广告类软件</strong></p> \n <p>*设计师：Monish Mohanan</p> \n <p>*软件介绍：</p> \n <p>QuickBee是一款广告分类管理软件，提供了生活中各个方面的信息，例如汽车，房地产，求职和教育等风方面面信息。使用者只需创建账号，即可搜寻所需生活信息，了解流行趋势，浏览各类特色广告。</p> \n <p>*亮点:</p> \n <p>软件设计简洁，颜色搭配极佳。彩色按钮呈现多样的生活分类，整洁美观。各式框架呈现流行趋势和特色广告，简洁有序。矢量图标简单易识别。添加多种界面，满足用户各方面的需求。</p> \n <p>&nbsp;<img alt=\"\" height=\"705\" src=\"http://img.pmcaff.com/FlFVPrTN9o-OFZCvQdIZRaix2B_a-picture\" width=\"885\"></p> \n <p><strong>10).</strong><a href=\"https://dribbble.com/shots/3998130-crypto-wallet\" target=\"_blank\" rel=\"nofollow\"><strong>Wallet</strong></a><strong>&nbsp;</strong><strong>-&nbsp;理财类软件</strong></p> \n <p>*设计师:&nbsp;<a href=\"https://dribbble.com/uixninja\" target=\"_blank\" rel=\"nofollow\">uixNinja</a></p> \n <p>*软件介绍：</p> \n <p>Wallet一款能够帮助使用者理财的移动端软件。</p> \n <p>*亮点:</p> \n <p>软件使用黑色，红色和紫色三种颜色的对比和渐变，极具特色，漂亮时尚。简易图标和多色几何图形，是软件界面更加简洁使用，令人印象深刻。</p> \n <p><img alt=\"\" height=\"619\" src=\"http://img.pmcaff.com/FulwoXJCInG-STCm314D0AJZBAIc-picture\" width=\"901\"></p> \n <p>&nbsp;</p> \n <p><strong>结语</strong></p> \n <p>这些就是我们所搜集的10款最新的优秀手机端软件UI设计作品。 希望他们不仅能给你新的设计带来灵感，同时也能帮助你把握和预计2018年手机应用UI设计的发展趋势。</p> \n</div>',NULL,'2020-02-09 15:10:42',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226403253172928512',NULL,NULL,' 在设计了上百个弹框之后，这些是我的心得  ','<div class=\"content\" id=\"articleContent\"> \n <p>最近2年一直在做WebApp相关项目，设计过上百个弹框，其中总结了一些心得，将透过以下文章介绍弹框在Web上的各种应用技巧及表现。</p> \n <span id=\"OSC_h2_1\"></span> \n <h2>什么是弹框？</h2> \n <p><strong>弹框是一种交互方式，用作提醒，做决定或者解决某个任务。弹框一般包含一个蒙版，一个主体及一个关闭入口，常见于网页及移动端。</strong>其好处是让用户更聚焦，且不用离开当前页面，更快更容易完成任务。由于弹框与当下流行的卡片式设计在表现形式上十分接近，同时弹框也逐渐承载了更多功能性需求，不再是简单的内容堆砌，因此弹框设计正在被越来越多设计师关注。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777debe921ec.png?imageMogr2/format/jpg/quality/80\"></p> \n <span id=\"OSC_h2_2\"></span> \n <h2>弹框尺寸怎么定？</h2> \n <p>在真正着手设计一个弹框时，第一个遇到的问题就是弹框的尺寸到底要定多大。市面上各种各样尺寸的屏幕分辨率，如果你希望以一个尺寸适配所有屏幕分辨率，那可以参考以下数据。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777debfe9def.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>2016年5月中国市场主流电脑分辨率统计Top 5 (资料来源自百度统计)</p> \n <p>从上图得知市面上最小的屏幕是1024×768，因此只要保证在这个尺寸内放得下, 其他尺寸也肯定没有问题。弹框的宽度一般不会太宽，1000px通常是足够的。高度的话，以Windows为例，去掉系统底部功能条的高度及浏览器的高度后，可以得出：</p> \n <blockquote> \n  <p><strong>768px-约60~100px(浏览器高度)-40px(系统底部工具栏高度)=约620px</strong></p> \n </blockquote> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dec1bee02.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>弹框高度控制在620px以内，可以避免在小屏幕下滚动一点点才能看全整个弹框的尴尬情况。假设弹框本身有滚动条，页面因为超出一屏又有一个全局滚动条，那整个滚动体验就会变得很差。因此从体验角度及开发成本来看，我们一般会把弹框控制在620px高以内，而根据经验所得，这个尺寸内的弹框占了90%场景。</p> \n <p>由于屏幕的尺寸愈来愈大，有时候为了在大屏幕下有更好的视觉表现，对于一些较复杂的弹框，可以选择做2种尺寸适配。拿以下2个例子为例：</p> \n <blockquote> \n  <p>Marvel的新建项目弹框中，在大屏幕下，弹框尺寸为640px(宽)x760px(高)<br> 在小屏幕下，选项及Icon则会缩小，弹框尺寸变成了640px(宽)x620px(高)</p> \n </blockquote> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dec35a0de.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>InVision的升级弹框中，在大屏幕下，列表的行距比较宽松，弹框尺寸为1100px(宽)x800px(高)；<br> 在小屏幕下，列表的高度则减小，弹框尺寸为1100px(宽)x630px(高)。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dec491bd6.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>当然，也可以按屏幕尺寸拉伸面板的尺寸。这裡处理的方法很多，总而言之如果弹框尺寸做得大，就要想好兼容方案，相对设计及开发成本也会增加。</p> \n <span id=\"OSC_h2_3\"></span> \n <h2>弹框的使用场景</h2> \n <p>在设计时发现经常会遇到一种情况，到底是用弹框还是用页面来承载内容呢？如果了解到弹框的特性后，其实不难分辨什么时候使用那个表现手法更适合。</p> \n <p><strong>弹框特性：</strong></p> \n <blockquote> \n  <p><strong>较页面轻，可以更快回到之前的页面</strong></p> \n  <p><strong>相对独立，可以完全不影响页面的布局</strong></p> \n  <p><strong>适合解决简单，一次性的操作</strong></p> \n </blockquote> \n <p>以下列出了一些较适合使用弹框的场景及案例：</p> \n <span id=\"OSC_h3_4\"></span> \n <h3>1、新手引导</h3> \n <p>第一感觉是非常重要的。Google+及Carbonmade的新手引导采用了弹框，配上漂亮的插图。这种处理手法美观，不影响页面布局，卡片式的表现手法还能贯穿网页端及移动端的一致体验。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dec609e82.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>Google Photos的新手引导更结合了微动画，效果非常惊艳，让人过目不忘。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dec9736ce.gif\"></p> \n <span id=\"OSC_h3_5\"></span> \n <h3>2、选择器</h3> \n <p>选择器的特点是用一个内滚区域来承载一个很长的页面，而该内滚区域的高度是可以根据浏览器的高度拉伸的。其好处是除了能放下很长的页面，同时能保留一些操作一直停留在屏幕上。这裡可以选择性的为弹框设置一个最大及最小高度，但要注意的是必须把背景锁定，否则出现2条滚动条的体验是很糟糕的。以QQ公众平台的图文选择器为例：</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777ded214429.gif\"></p> \n <p>Flickr的图片选择器。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777ded48d1d4.png?imageMogr2/format/jpg/quality/80\"></p> \n <span id=\"OSC_h3_6\"></span> \n <h3>3、任务</h3> \n <p>有时候某些任务只是一些简单的操作，并不特地需要一个页面来表现，弹框是一个很好的方法。</p> \n <p>Duolingo用插图和icon等视觉元素来丰富任务弹框的表现形式，减轻枯燥感。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777ded5edec6.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>Trello的任务弹框虽然信息较多，但好处是能快速切换到不同的任务，增加效率。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777ded7a0a36.png?imageMogr2/format/jpg/quality/80\"></p> \n <span id=\"OSC_h3_7\"></span> \n <h3>4、提示</h3> \n <p><strong>提示是最基础的弹框应用，设计时需记往保持统一性。</strong>视觉上的统一性：颜色、间距、文案风格等。交互的统一性：主要操作是左边还是右边按钮，关闭是点击蒙版还是点击叉叉。</p> \n <p>腾讯企点的提示弹框整理：</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777ded8b8cd7.png?imageMogr2/format/jpg/quality/80\"></p> \n <span id=\"OSC_h2_8\"></span> \n <h2>几个容易被忽视的弹框细节</h2> \n <span id=\"OSC_h3_9\"></span> \n <h3>1、背景锁定与滚动条引起的抖动问题</h3> \n <p>浏览网页时经常会发现弹框出现后，滚动鼠标时，蒙版下面的页面还是可以滚动的，其实这些滚动都是没必要的，因为弹框的原意就是要聚焦用户的注意力。</p> \n <p>因此我们要做的是——背景锁定（从技术角度其实是暂时性干掉滚动条）。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dedae5146.gif\"></p> \n <p>从前端同学扒出其技术原理如下：</p> \n <p>当Dialog弹框出现的时候，根元素overflow：hidden.</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777e1770caae.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>此时，由于页面滚动条从有到无，页面会晃动，这样糟糕的体验显然是不能容忍了，于是，对&lt;body&gt;元素进行处理，右侧增加一个滚动条宽度（假设宽度是widthScrollbar）的透明边框。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777e177e0cfd.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>Dialog隐藏的时候再把滚动条放开。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777e1b284c14.gif\"></p> \n <span id=\"OSC_h3_10\"></span> \n <h3>2、避免弹框上再弹出弹框</h3> \n <p>要尽量避免在弹框上再弹一层弹框，2层蒙版会让用户觉得负担很重。可以改用轻量弹框或重新把交互梳理。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dedd8b700.gif\"></p> \n <span id=\"OSC_h3_11\"></span> \n <h3>3、蒙版增强品牌感</h3> \n <p>过去我们对蒙版颜色可能没有仔细关注过，也许颜色不是纯黑#000，就是纯白#fff。其实蒙版的颜色及透明度可以再深入搭配的，例如产品是蓝色调 性的可以在黑色中混入一点蓝色，产品是轻盈的可以用白色或淡灰色，或者尝试用没那么深的颜色搭配高一点透明度等等，根据产品的调性设计出一个适合产品气质 的蒙版。</p> \n <p>Tumblr的蒙版颜色採用了它的品牌色rgba(54,70,93,95)：</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dedebf09d.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>Twitch的蒙版颜色在黑色中混入了一点紫色rgba(32,28,43,9)，与它的品牌色相符：</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777e226b7a53.png?imageMogr2/format/jpg/quality/80\"></p> \n <span id=\"OSC_h2_12\"></span> \n <h2>對弹框的其他思考</h2> \n <span id=\"OSC_h3_13\"></span> \n <h3>未来的趋势</h3> \n <p>移动在影响著人们生活，也同时引领著设计趋势，这些年产品都在追求多终端的一致性，早已衍生出自适应网页设计(Responsive Web Design)的布局解决方案，因此网页设计也日趋移动化。可以想像将会有一大波移动上的体验会搬到网页设计上，如弹框中包含多个层级，透过左上角返回的 交互体验，更灵动及细腻的动画效果等。</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dee2949e9.gif\"></p> \n <p>视觉表现方面，之前也提到过，将会有更多产品会为了在大屏幕下有更好的视觉效果做出针对性的设计。而随著产品愈来愈追求简洁，UI也变得愈来愈轻盈，甚至透明。弹框也许不再需要用一个框框去包住主体。市面上已经有不少产品使用这种手法，以整个屏幕来取代框框。</p> \n <p>这些也许是未来的一个趋势, 让我们拭目以待。</p> \n <p><a href=\"http://www.leiphone.com/tag/square\" target=\"_blank\" rel=\"nofollow\">Square</a>space的登录弹框：</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dee47b1c4.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>Evernote的修改标签弹框：</p> \n <p><img alt=\"在设计了上百个弹框之后，这些是我的心得\" src=\"http://static.leiphone.com/uploads/new/article/740_740/201607/5777dee5a074a.png?imageMogr2/format/jpg/quality/80\"></p> \n <p>&nbsp;</p> \n</div>',NULL,'2020-02-09 15:11:36',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226403480227381248',NULL,NULL,' 照虎画虎——简单WeUI模板UX设计学习  ','<div class=\"content\" id=\"articleContent\"> \n <p>艺术虽然分为独立的各个领域，但是总有相通之处。UI/UX设计也是一种艺术，就像美术一样，UI/UX的设计也需要大量的临摹其他优秀作品来提高自己的水平。</p> \n <p>不过俗话说：“照猫画虎”，如果你临摹的对象不合适，很有可能只得其形而不得其意。那么，到哪里去寻找合适的临摹素材，做到“照虎画虎”？其实很多知名软件的新动向，都值得我们去参考，比如微信小程序的设计工具：WeUI。</p> \n <p>首先我们需要找到WeUI的模板，其实想要找到这个，也并不是很难，在Mockplus的例子项目中，有大量的国内外的优秀App的模板，WeUI也在这其中。虽然这个模板中页面有点少，不过也可谓言简意赅，UX设计中需要的元素，这里都有涉及到。当然，你也可以到微信的公众开发平台上找到这个例子的全部文档。</p> \n <p>我们先在<a href=\"http://run.mockplus.cn/Tnr9w9TyUKjXeDeR/index.html\" target=\"_blank\" rel=\"nofollow\">这里</a>看一下效果。因为这里选取的只是几个具有代表性的页面，所以并不涉及页面间跳转的设置，各位看官还请在左侧的控制面板中自行切换页面。</p> \n <p>这个模板的重点是在第一个页面，下面打开这个模板，我们来具体看一下这个页面是如何设计的。</p> \n <p>基础的组件摆放就不多说了，主要看交互。首先来看上半个页面，中间黄色的区域其实是两个重合放置的“组”，这两个组分别对应两种情况：已完成和数据加载中。点击“成功提示”，出现“已完成”提示框，并在1.5秒之后自动消失。点击“加载中提示”，数据加载中的提示框产生相同的交互动作。好的，效果我们已经看到了，那么，问题来了：如何实现呢？</p> \n <p>这种效果弹窗并且自动消失的效果其实并不难，用“图片”、“形状”和“单行文字”来组成这个“已完成”，然后选中这些组件，单击右键打开菜单，选择“合并为组”，并且在右侧的属性面板中取消这个组的可见选项。</p> \n <p><img alt=\"\" height=\"300\" src=\"https://attachments.tower.im/tower/cfae6c084c1044328a900142dcbf8e61?version=auto&amp;filename=%E5%9B%BE1.jpg\" width=\"599\"></p> \n <p>接下来的交互设置：拖动“成功提示”到这个黄色的区域，选择“点击时” &gt; “显示/隐藏”的交互命令，然后打开下方的参数面板，选择“显示”。这样就实现点击显示“已完成”的效果。那么如果设置这个出现的组自动消失呢？其实很简单，上一步的操作稍加改动，就可以实现自动消失了。</p> \n <p><img alt=\"\" height=\"500\" src=\"https://attachments.tower.im/tower/63546dbdc2a7431d8fe6d49fa1768468?version=auto&amp;filename=%E5%9B%BE2.jpg\" width=\"600\"></p> \n <p>我们还是拖拽“成功提示”的这个链接点到“已完成”的区域，选择交互命令“点击时” &gt; \"显示/隐藏\"，在下方的参数面板中，设置需要做一些改动，这里我们选择“隐藏”，然后在“延迟”的选项中输入“1500”，相当于延迟了1500毫秒，也就是1.5秒。这样就可以在点击“成功提示”的1.5秒后使“已完成”自动消失了。</p> \n <p><img alt=\"\" height=\"150\" src=\"https://attachments.tower.im/tower/8d288611414846168e58662e67139c72?version=auto&amp;filename=%E5%9B%BE3.jpg\" width=\"600\"></p> \n <p>同样的方法，我们设置到“数据加载中”即可。</p> \n <p>嗯，就这样。我们来看这个页面的下半页。</p> \n <p>这里的组件，看上去好像都是一个，其实……它不是一个组件在战斗，看到这里是不是清楚了很多？</p> \n <p><img alt=\"\" height=\"350\" src=\"https://attachments.tower.im/tower/f56dc89c6b414164b5914d54aabe4676?version=auto&amp;filename=%E5%9B%BE4.jpg\" width=\"600\"></p> \n <p>然后就是交互的设置了，如果把这些绿色的矩形变成“活”的进度条呢？在这里，命令中的“调整尺寸”，在完成对每个形状分别的“调整尺寸”设置的过程中，一定要记得做两个调整，首先是“固定到”这里，要选择形状组件正确的成长方向。然后是“执行时长”，这个位置一定要调整，不然你的形状组件会在一瞬间就长大了，不能体现出较好的视觉效果。</p> \n <p><img alt=\"\" height=\"214\" src=\"https://attachments.tower.im/tower/637bf58f22dc4c5abf278369b4d90828?version=auto&amp;filename=%E5%9B%BE5.jpg\" width=\"600\"></p> \n <p>“上传”按钮这里只是一个简单的点击组件显示另一个不可见组件的交互设置，这里就不再多说了。</p> \n <p>第三页的交互其实和第一和上半部分的交互效果基本是相同的，只不过这里红色的图标设置过显示之后就不再设置隐藏，第二页和第四页主要是关注组件的样式，希望可以给大家提供一些参考。</p> \n <p>怎么样？这样一来，自动消失和进度条的交互命令是不是已经学会了呢？<a href=\"http://doc.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">例子项目</a>里还有很多的模板，下一次在向大家介绍其他有用的功能吧。</p> \n</div>',NULL,'2020-02-09 15:12:30',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226403702122840064',NULL,NULL,' 更上一层楼：国外30个优秀的UI/UX在线学习网站  ','<div class=\"content\" id=\"articleContent\"> \n <p>最近都在浏览Quora网站，这是一个能够很好的和其他设计师交流的网站，但几乎都是用英文交流，对于大部分中国人来说还是有困难的，可能大家也更愿意去知乎上找答案，都说知乎是中国版的Quora, 可想而知这个网站的活跃度是极高的。注册Quora有一段时间了，每次遇到问题时，我就会去网站上看看答案或者提交问题，别人也会来咨询你问题。这段时间看到许多人都在问“有哪些网站可以在线学习UI/UX”，我同样也很好奇，所以我开始寻找回答，然后整理出了以下30个在线学习UI/UX的网站，有的是免费的，还有些是需要收费的。英语好的小伙伴可以看看呢，希望可以帮助到你们，对于新的设计师来说，这是你不容错过的学习机会，“大牛们”也可以通过学习这些网站让你的技术更上一层楼。</p> \n <p><img alt=\"\" height=\"1058\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/82ec3166-b83d-4d5e-a089-94449eddbdcf.jpg\" width=\"1581\"></p> \n <p>1.&nbsp;<a href=\"https://hackdesign.org/\" rel=\"nofollow\">Hackdesign</a></p> \n <p>这个网站资源很丰富，邮箱注册后每周都会收到设计课程和设计大师的作品，根据你的水平来学习，没有任何虚假的设计。</p> \n <p>2.&nbsp;<a href=\"https://www.coursera.org/\" rel=\"nofollow\">Coursera</a></p> \n <p>Coursera除了可以学习编程和设计等课程，还可以学习语言和生活常识，很不错的网站，有兴趣的小伙伴可以看看呢。</p> \n <p>3.&nbsp;<a href=\"https://www.mypath.io/\" rel=\"nofollow\">My.path</a></p> \n <p>拥有上千个课程，文章等，想要学习UI/UX的千万别错过了，但是有的课程是要钱的，有的是免费的，自己选择咯。</p> \n <p>4.&nbsp;<a href=\"https://www.skillshare.com/\" rel=\"nofollow\">SKILLSHARE</a></p> \n <p>版面简洁清晰，想看谁就看谁，设计大牛手把手教你做好设计，而且还是免费的。</p> \n <p>5.&nbsp;<a href=\"http://gymnasium.aquent.com/\" rel=\"nofollow\">GYMNASIUM</a></p> \n <p>GYMNASIUM是专门学习设计和编程的网站，都是经验丰富的大牛教的课，重点是不要钱不要钱。</p> \n <p>6.&nbsp;<a href=\"http://www.ecorptrainings.com/index.php\" rel=\"nofollow\">ecorp trainings</a></p> \n <p>是专门提供在线培训、IT咨询等的一个网站。</p> \n <p>单单是设计的课程就多到让你学不过来了，赶紧加入吧。</p> \n <p>7.&nbsp;<a href=\"https://careerfoundry.com/en/courses/ui-design-course\" rel=\"nofollow\">CAREERFOUNDRY</a></p> \n <p>是不是觉得一个人学习很孤单，赶快加入CAREERFOUNDRY吧。这里的学生有2024名，指导员有230个，还能在六个月内帮你找到工作，可想而知当然不是免费的。</p> \n <p>8.&nbsp;<a href=\"https://www.lynda.com/\" rel=\"nofollow\">Lynda</a></p> \n <p>这个网站也是火到不行，课程有4000多个，涵盖了商业、科技等。都是一流的大牛教授的课程，英语好的小伙伴赶紧加入吧。</p> \n <p>9.&nbsp;<a href=\"http://www.phpkingdom.com/\" rel=\"nofollow\">PHPKINGDOM</a></p> \n <p>号称是最好的在线培训学习UI设计的网站，网站的宗旨是：耐心+不断练习=理想工作。但不是免费的。</p> \n <p>10.&nbsp;<a href=\"http://doc.mockplus.cn/\" rel=\"nofollow\">Mockplus Tutorial</a></p> \n <p><a href=\"https://www.mockplus.cn/\" rel=\"nofollow\">Mockplus</a>&nbsp;教程教你如何更好的使用工具完成设计。</p> \n <p><img alt=\"\" height=\"600\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/6634326f-12c1-4ade-9634-cc6895bb0042.jpg\" width=\"900\"></p> \n <p>11.&nbsp;<a href=\"https://www.udemy.com/\" rel=\"nofollow\">Udemy</a></p> \n <p>宗旨是“学无止境”，课程打折后的价格19美金，也有少数免费的。</p> \n <p>12.&nbsp;<a href=\"https://www.interaction-design.org/courses\" rel=\"nofollow\">IDF</a></p> \n <p>会员可享受免费的课程呢，不需要任何费用，赶快行动吧。</p> \n <p>13.&nbsp;<a href=\"https://teamtreehouse.com/\" rel=\"nofollow\">Treehouse</a></p> \n <p>这个网站的课程全面，不仅可以学习代码，还可以学习很多新的设计知识。</p> \n <p>14.&nbsp;<a href=\"http://www.uxdesignedge.com/\" rel=\"nofollow\">UX Design Edge</a></p> \n <p>通过高效的设计培训和咨询来帮助你达到最佳的用户体验。</p> \n <p>15.&nbsp;<a href=\"https://www.springboard.com/\" rel=\"nofollow\">Spingboard</a></p> \n <p>Spingboard的这些课程都是为UX/UI设计师量身打造的。</p> \n <p>16.&nbsp;<a href=\"https://novoed.com/\" rel=\"nofollow\">NovoEd</a></p> \n <p>NOVOEd 让你在线学习无压力，更有效。</p> \n <p>17.&nbsp;<a href=\"https://www.khanacademy.org/\" rel=\"nofollow\">KHAN ACADEMY</a></p> \n <p>网站的宗旨是“任何人在这个网站学习任何东西都是免费的。”</p> \n <p>18.<a href=\"http://academicearth.org/\" rel=\"nofollow\">ACADEMIC EARTH</a></p> \n <p>“任何人都值得一流的教育。”</p> \n <p>19.&nbsp;<a href=\"http://oli.cmu.edu/\" rel=\"nofollow\">Open Learning Initiative</a></p> \n <p>是由卡内基梅隆大学创立的，不仅仅可以在线学习，厉害的大牛们还可以当老师教别人。</p> \n <p>20.&nbsp;<a href=\"https://www.acamica.com/\" rel=\"nofollow\">ACAMICA</a></p> \n <p>由设计行业最顶级的设计师教授编程和设计，根据你的水平量身打造的，当然是要钱的了。</p> \n <p><img alt=\"\" height=\"710\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/12/0f233c5c-e849-4e39-ac8f-767b7416c7d8.jpg\" width=\"1024\"></p> \n <p>21.&nbsp;<a href=\"http://plusacumen.org/\" rel=\"nofollow\">+ACUMEN</a></p> \n <p>提供丰富的课程和高效的学习方法。</p> \n <p>22.&nbsp;<a href=\"https://www.apnacourse.com/\" rel=\"nofollow\">APNA COURSE</a></p> \n <p>所以的课程都是由十年以上经验的培训师、教授开设的，让你的设计更上一层楼。</p> \n <p>23.&nbsp;<a href=\"https://www.eventbrite.co.uk/e/ux-design-course-for-startups-app-developers-and-web-designers-tickets-26692199086\" rel=\"nofollow\">Eventbrite</a></p> \n <p>专为设计新人和APP以及网页设计师开设的在线课程。</p> \n <p>24.&nbsp;<a href=\"http://uxtraining.com/%20\" rel=\"nofollow\">UX TRAINING.com</a></p> \n <p>无论何时何地都可以学习UX的网站。</p> \n <p>25.&nbsp;<a href=\"http://www.extension.harvard.edu/\" rel=\"nofollow\">HARVARD Extension School</a></p> \n <p>哈佛大学就不用多介绍了，据说学习完后还可以获得哈佛证书。</p> \n <p>24.&nbsp;<a href=\"https://www.masterclass.com/\" rel=\"nofollow\">MASTERCLASS</a></p> \n <p>学习世界各地大师的设计课程，让你大开眼界。</p> \n <p>25.&nbsp;<a href=\"https://www.futurelearn.com/\" rel=\"nofollow\">Future Learn</a></p> \n <p>学习UX最好的在线网站。</p> \n <p>26.&nbsp;<a href=\"https://www.thebigknow.com/about\" rel=\"nofollow\">THE BIG KNOW</a></p> \n <p>图标设计和品牌设计。</p> \n <p>27.&nbsp;<a href=\"https://www.futurelearn.com/\" rel=\"nofollow\">iversity</a></p> \n <p>学习设计不费力的网站你值得拥有。</p> \n <p>30.&nbsp;<a href=\"https://byjus.com/\" rel=\"nofollow\">BYJU’S</a></p> \n <p>这个网站都是由印度最好的老师来教课的。</p> \n</div>',NULL,'2020-02-09 15:13:23',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226403924181876736',NULL,NULL,' 大型互联网系统架构是如何设计的？  ','<div class=\"content\" id=\"articleContent\"> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6a6a3341354e382e706e67.\" width=\"640\"></p> \n <p>接下来，我们将看看高阶的权衡和取舍:</p> \n <ul> \n  <li><strong>性能</strong>与<strong>可扩展性</strong></li> \n  <li><strong>延迟</strong>与<strong>吞吐量</strong></li> \n  <li><strong>可用性</strong>与<strong>一致性</strong></li> \n </ul> \n <p>记住<strong>每个方面都面临取舍和权衡</strong>。</p> \n <p>然后，我们将深入更具体的主题，如 DNS、CDN 和负载均衡器。</p> \n <span id=\"OSC_h2_1\"></span> \n <h2>1. 性能与可扩展性</h2> \n <p>如果服务<strong>性能</strong>的增长与资源的增加是成比例的，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。<a href=\"http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html\" rel=\"nofollow\">1</a></p> \n <p>另一个角度来看待性能与可扩展性:</p> \n <ul> \n  <li>如果你的系统有<strong>性能</strong>问题，对于单个用户来说是缓慢的。</li> \n  <li>如果你的系统有<strong>可扩展性</strong>问题，单个用户较快但在高负载下会变慢。</li> \n </ul> \n <span id=\"OSC_h2_2\"></span> \n <h2>2. 延迟与吞吐量</h2> \n <p><strong>延迟</strong>是执行操作或运算结果所花费的时间。</p> \n <p><strong>吞吐量</strong>是单位时间内（执行）此类操作或运算的数量。</p> \n <p>通常，你应该以<strong>可接受级延迟</strong>下<strong>最大化吞吐量</strong>为目标。</p> \n <span id=\"OSC_h2_3\"></span> \n <h2>3. 可用性与一致性</h2> \n <span id=\"OSC_h3_4\"></span> \n <h3>CAP 理论</h3> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f62674c4d4932752e706e67.\">&nbsp;</p> \n <p>在一个分布式计算系统中，只能同时满足下列的两点:</p> \n <ul> \n  <li><strong>一致性</strong>&nbsp;─ 每次访问都能获得最新数据但可能会收到错误响应</li> \n  <li><strong>可用性</strong>&nbsp;─ 每次访问都能收到非错响应，但不保证获取到最新数据</li> \n  <li><strong>分区容错性</strong>&nbsp;─ 在任意分区网络故障的情况下系统仍能继续运行</li> \n </ul> \n <p><strong>网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。</strong></p> \n <span id=\"OSC_h4_5\"></span> \n <h4>CP ─ 一致性和分区容错性</h4> \n <p>等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。</p> \n <span id=\"OSC_h4_6\"></span> \n <h4>AP ─ 可用性与分区容错性</h4> \n <p>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。</p> \n <p>如果业务需求允许最终一致性，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。</p> \n <span id=\"OSC_h2_7\"></span> \n <h2>4. 一致性模式</h2> \n <p>有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想&nbsp;CAP 理论中的一致性定义 ─ 每次访问都能获得最新数据但可能会收到错误响应</p> \n <span id=\"OSC_h3_8\"></span> \n <h3>弱一致性</h3> \n <p>在写入之后，访问可能看到，也可能看不到（写入数据）。尽力优化之让其能访问最新数据。</p> \n <p>这种方式可以 memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。打个比方，如果你在通话中丢失信号几秒钟时间，当重新连接时你是听不到这几秒钟所说的话的。</p> \n <span id=\"OSC_h3_9\"></span> \n <h3>最终一致性</h3> \n <p>在写入后，访问最终能看到写入数据（通常在数毫秒内）。数据被异步复制。</p> \n <p>DNS 和 email 等系统使用的是此种方式。最终一致性在高可用性系统中效果不错。</p> \n <span id=\"OSC_h3_10\"></span> \n <h3>强一致性</h3> \n <p>在写入后，访问立即可见。数据被同步复制。</p> \n <p>文件系统和关系型数据库（RDBMS）中使用的是此种方式。强一致性在需要记录的系统中运作良好。</p> \n <span id=\"OSC_h2_11\"></span> \n <h2>5. 可用性模式</h2> \n <p>有两种支持高可用性的模式:&nbsp;<strong>故障切换（fail-over）<strong>和</strong>复制（replication）</strong>。</p> \n <span id=\"OSC_h3_12\"></span> \n <h3>故障切换</h3> \n <span id=\"OSC_h4_13\"></span> \n <h4>工作到备用切换（Active-passive）</h4> \n <p>关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。</p> \n <p>宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。</p> \n <p>工作到备用的故障切换也被称为主从切换。</p> \n <span id=\"OSC_h4_14\"></span> \n <h4>双工作切换（Active-active）</h4> \n <p>在双工作切换中，双方都在管控流量，在它们之间分散负载。</p> \n <p>如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。</p> \n <p>双工作切换也可以称为主主切换。</p> \n <span id=\"OSC_h3_15\"></span> \n <h3>缺陷：故障切换</h3> \n <ul> \n  <li>故障切换需要添加额外硬件并增加复杂性。</li> \n  <li>如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。</li> \n </ul> \n <span id=\"OSC_h3_16\"></span> \n <h3>复制</h3> \n <span id=\"OSC_h4_17\"></span> \n <h4>主 ─ 从复制和主 ─ 主复制</h4> \n <p>这个主题进一步探讨了数据库部分:</p> \n <ul> \n  <li>主 ─ 从复制</li> \n  <li>主 ─ 主复制</li> \n </ul> \n <span id=\"OSC_h2_18\"></span> \n <h2>6. 域名系统</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f494f794c6a34692e6a7067.\">&nbsp;</p> \n <p>域名系统是把&nbsp;www.example.com&nbsp;等域名转换成 IP 地址。</p> \n <p>域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名） IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于存活时间 TTL。</p> \n <ul> \n  <li><strong>NS 记录（域名服务）</strong>&nbsp;─ 指定解析域名或子域名的 DNS 服务器。</li> \n  <li><strong>MX 记录（邮件交换）</strong>&nbsp;─ 指定接收信息的邮件服务器。</li> \n  <li><strong>A 记录（地址）</strong>&nbsp;─ 指定域名对应的 IP 地址记录。</li> \n  <li><strong>CNAME（规范）</strong>&nbsp;─ 一个域名映射到另一个域名或&nbsp;<code>CNAME</code>&nbsp;记录（ example.com 指向&nbsp;www.example.com&nbsp;）或映射到一个&nbsp;<code>A</code>&nbsp;记录。</li> \n </ul> \n <p>CloudFlare&nbsp;和&nbsp;Route 53&nbsp;等平台提供管理 DNS 的功能。某些 DNS 服务通过集中方式来路由流量:</p> \n <ul> \n  <li>加权轮询调度 \n   <ul> \n    <li>防止流量进入维护中的服务器</li> \n    <li>在不同大小集群间负载均衡</li> \n    <li>A/B 测试</li> \n   </ul> </li> \n  <li>基于延迟路由</li> \n  <li>基于地理位置路由</li> \n </ul> \n <span id=\"OSC_h3_19\"></span> \n <h3>缺陷:DNS</h3> \n <ul> \n  <li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。</li> \n  <li>虽然它们通常由政府，网络服务提供商和大公司管理，但 DNS 服务管理仍可能是复杂的。</li> \n  <li>DNS 服务最近遭受&nbsp;DDoS 攻击，阻止不知道 Twtter IP 地址的用户访问 Twiiter。</li> \n </ul> \n <span id=\"OSC_h2_20\"></span> \n <h2>7. 内容分发网络（CDN）</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f683954417547492e6a7067.\"></p> \n <p>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。</p> \n <p>将内容存储在 CDN 上可以从两个方面来提供性能:</p> \n <ul> \n  <li>从靠近用户的数据中心提供资源</li> \n  <li>通过 CDN 你的服务器不必真的处理请求</li> \n </ul> \n <span id=\"OSC_h3_21\"></span> \n <h3>CDN 推送（push）</h3> \n <p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p> \n <span id=\"OSC_h3_22\"></span> \n <h3>CDN 拉取（pull）</h3> \n <p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p> \n <p>存活时间（TTL）决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p> \n <p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p> \n <span id=\"OSC_h3_23\"></span> \n <h3>缺陷：CDN</h3> \n <ul> \n  <li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li> \n  <li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li> \n  <li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li> \n </ul> \n <span id=\"OSC_h2_24\"></span> \n <h2>8. 负载均衡器</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6838316e39694b2e706e67.\"></p> \n <p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p> \n <ul> \n  <li>防止请求进入不好的服务器</li> \n  <li>防止资源过载</li> \n  <li>帮助消除单一的故障点</li> \n </ul> \n <p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。 增加的好处包括:</p> \n <ul> \n  <li><strong>SSL 终结</strong>&nbsp;─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。 \n   <ul> \n    <li>不需要再每台服务器上安装&nbsp;X.509 证书。</li> \n   </ul> </li> \n  <li><strong>Session 留存</strong>&nbsp;─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。</li> \n </ul> \n <p>通常会设置采用工作 ─ 备用&nbsp;或&nbsp;双工作&nbsp;模式的多个负载均衡器，以免发生故障。</p> \n <p>负载均衡器能基于多种方式来路由流量:</p> \n <ul> \n  <li>随机</li> \n  <li>最少负载</li> \n  <li>Session/cookie</li> \n  <li>轮询调度或加权轮询调度算法</li> \n  <li>四层负载均衡</li> \n  <li>七层负载均衡</li> \n </ul> \n <span id=\"OSC_h3_25\"></span> \n <h3>四层负载均衡</h3> \n <p>四层负载均衡根据监看传输层的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行网络地址转换（NAT）来向上游服务器转发网络数据包。</p> \n <span id=\"OSC_h3_26\"></span> \n <h3>七层负载均衡器</h3> \n <p>七层负载均衡器根据监控应用层来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p> \n <p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p> \n <span id=\"OSC_h3_27\"></span> \n <h3>水平扩展</h3> \n <p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上<strong>垂直扩展</strong>更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p> \n <span id=\"OSC_h4_28\"></span> \n <h4>缺陷：水平扩展</h4> \n <ul> \n  <li>水平扩展引入了复杂度并涉及服务器复制 \n   <ul> \n    <li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li> \n    <li>session 可以集中存储在数据库或持久化缓存（Redis、Memcached）的数据存储区中。</li> \n   </ul> </li> \n  <li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li> \n </ul> \n <span id=\"OSC_h3_29\"></span> \n <h3>缺陷：负载均衡器</h3> \n <ul> \n  <li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li> \n  <li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li> \n  <li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li> \n </ul> \n <span id=\"OSC_h2_30\"></span> \n <h2>9. 反向代理（web 服务器）</h2> \n <p><a href=\"https://camo.githubusercontent.com/e88216d0999853426f72b28e41223f43977d22b7/687474703a2f2f692e696d6775722e636f6d2f6e3431417a66662e706e67\" target=\"_blank\" rel=\"nofollow\"><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6e3431417a66662e706e67.\"></a>&nbsp;</p> \n <p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p> \n <p>带来的好处包括：</p> \n <ul> \n  <li><strong>增加安全性</strong>&nbsp;- 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li> \n  <li><strong>提高可扩展性和灵活性</strong>&nbsp;- 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li> \n  <li><strong>本地终结 SSL 会话</strong>&nbsp;- 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。 \n   <ul> \n    <li>免除了在每个服务器上安装&nbsp;X.509&nbsp;证书的需要</li> \n   </ul> </li> \n  <li><strong>压缩</strong>&nbsp;- 压缩服务器响应</li> \n  <li><strong>缓存</strong>&nbsp;- 直接返回命中的缓存结果</li> \n  <li><strong>静态内容</strong>&nbsp;- 直接提供静态内容 \n   <ul> \n    <li>HTML/CSS/JS</li> \n    <li>图片</li> \n    <li>视频</li> \n    <li>等等</li> \n   </ul> </li> \n </ul> \n <span id=\"OSC_h3_31\"></span> \n <h3>负载均衡器与反向代理</h3> \n <ul> \n  <li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li> \n  <li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li> \n  <li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li> \n </ul> \n <span id=\"OSC_h3_32\"></span> \n <h3>不利之处：反向代理</h3> \n <ul> \n  <li>引入反向代理会增加系统的复杂度。</li> \n  <li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如故障转移）会进一步增加复杂度。</li> \n </ul> \n <span id=\"OSC_h2_33\"></span> \n <h2>10. 应用层</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f7942355359776d2e706e67.\"></p> \n <p>将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p> \n <p><strong>单一职责原则</strong>提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p> \n <p>应用层中的工作进程也有可以实现异步化。</p> \n <span id=\"OSC_h3_34\"></span> \n <h3>微服务</h3> \n <p>与此讨论相关的话题是&nbsp;微服务，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。1</p> \n <p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p> \n <span id=\"OSC_h3_35\"></span> \n <h3>服务发现</h3> \n <p>像&nbsp;Consul，Etcd&nbsp;和&nbsp;Zookeeper&nbsp;这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。Health checks&nbsp;可以帮助确认服务的完整性和是否经常使用一个&nbsp;HTTP&nbsp;路径。Consul 和 Etcd 都有一个内建的&nbsp;key-value 存储&nbsp;用来存储配置信息和其他的共享信息。</p> \n <span id=\"OSC_h3_36\"></span> \n <h3>不利之处：应用层</h3> \n <ul> \n  <li>添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。</li> \n  <li>微服务会增加部署和运营的复杂度。</li> \n </ul> \n <span id=\"OSC_h2_37\"></span> \n <h2>11. 数据库</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f586b6d3543587a2e706e67.\"></p> \n <span id=\"OSC_h3_38\"></span> \n <h3>关系型数据库管理系统（RDBMS）</h3> \n <p>像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p> \n <blockquote> \n  <p>校对注：这里作者 SQL 可能指的是 MySQL</p> \n </blockquote> \n <p><strong>ACID</strong>&nbsp;用来描述关系型数据库事务的特性。</p> \n <ul> \n  <li><strong>原子性</strong>&nbsp;- 每个事务内部所有操作要么全部完成，要么全部不完成。</li> \n  <li><strong>一致性</strong>&nbsp;- 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li> \n  <li><strong>隔离性</strong>&nbsp;- 并发执行事务的结果与顺序执行事务的结果相同。</li> \n  <li><strong>持久性</strong>&nbsp;- 事务提交后，对系统的影响是永久的。</li> \n </ul> \n <p>关系型数据库扩展包括许多技术：<strong>主从复制</strong>、<strong>主主复制</strong>、<strong>联合</strong>、<strong>分片</strong>、<strong>非规范化</strong>和&nbsp;<strong>SQL 调优</strong>。</p> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f4339696f47746e2e706e67.\"></p> \n <span id=\"OSC_h4_39\"></span> \n <h4>主从复制</h4> \n <p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p> \n <p>不利之处：主从复制</p> \n <ul> \n  <li>将从库提升为主库需要额外的逻辑。</li> \n  <li>参考不利之处：复制中，主从复制和主主复制<strong>共同</strong>的问题。</li> \n </ul> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6b7241484c47672e706e67.\"></p> \n <span id=\"OSC_h4_40\"></span> \n <h4>主主复制</h4> \n <p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p> \n <p>不利之处： 主主复制</p> \n <ul> \n  <li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li> \n  <li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li> \n  <li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li> \n  <li>参考不利之处：复制中，主从复制和主主复制<strong>共同</strong>的问题。</li> \n </ul> \n <p>不利之处：复制</p> \n <ul> \n  <li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li> \n  <li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li> \n  <li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li> \n  <li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li> \n  <li>复制意味着更多的硬件和额外的复杂度。</li> \n </ul> \n <span id=\"OSC_h4_41\"></span> \n <h4>联合</h4> \n <p><a href=\"https://camo.githubusercontent.com/6eb6570a8b6b4e1d52e3d7cc07e7959ea5dac75f/687474703a2f2f692e696d6775722e636f6d2f553371563333652e706e67\" target=\"_blank\" rel=\"nofollow\"><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f553371563333652e706e67.\"></a>&nbsp;</p> \n <p>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：<strong>论坛</strong>、<strong>用户</strong>和<strong>产品</strong>，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p> \n <p>不利之处：联合</p> \n <ul> \n  <li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li> \n  <li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li> \n  <li>用&nbsp;server link&nbsp;从两个库联结数据更复杂。</li> \n  <li>联合需要更多的硬件和额外的复杂度。</li> \n </ul> \n <span id=\"OSC_h4_42\"></span> \n <h4>分片</h4> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f775538783549642e706e67.\">&nbsp;</p> \n <p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p> \n <p>类似联合的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p> \n <p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p> \n <p>不利之处：分片</p> \n <ul> \n  <li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li> \n  <li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。 \n   <ul> \n    <li>再平衡会引入额外的复杂度。基于一致性哈希的分片算法可以减少这种情况。</li> \n   </ul> </li> \n  <li>联结多个分片的数据操作更复杂。</li> \n  <li>分片需要更多的硬件和额外的复杂度。</li> \n </ul> \n <span id=\"OSC_h4_43\"></span> \n <h4>非规范化</h4> \n <p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如&nbsp;PostgreSQL&nbsp;和 Oracle 支持物化视图，可以处理冗余信息存储和保证冗余副本一致。</p> \n <p>当数据使用诸如联合和分片等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p> \n <p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p> \n <p>不利之处：非规范化</p> \n <ul> \n  <li>数据会冗余。</li> \n  <li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li> \n  <li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li> \n </ul> \n <span id=\"OSC_h4_44\"></span> \n <h4>SQL 调优</h4> \n <p>SQL 调优是一个范围很广的话题，有很多相关的书可以作为参考。</p> \n <p>利用<strong>基准测试</strong>和<strong>性能分析</strong>来模拟和发现系统瓶颈很重要。</p> \n <ul> \n  <li><strong>基准测试</strong>&nbsp;- 用&nbsp;ab&nbsp;等工具模拟高负载情况。</li> \n  <li><strong>性能分析</strong>&nbsp;- 通过启用如慢查询日志等工具来辅助追踪性能问题。</li> \n </ul> \n <p>基准测试和性能分析可能会指引你到以下优化方案。</p> \n <p>改进模式</p> \n <ul> \n  <li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li> \n  <li>使用&nbsp;<code>CHAR</code>&nbsp;类型存储固定长度的字段，不要用&nbsp;<code>VARCHAR</code>。 \n   <ul> \n    <li><code>CHAR</code>&nbsp;在快速、随机访问时效率很高。如果使用&nbsp;<code>VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li> \n   </ul> </li> \n  <li>使用&nbsp;<code>TEXT</code>&nbsp;类型存储大块的文本，例如博客正文。<code>TEXT</code>&nbsp;还允许布尔搜索。使用&nbsp;<code>TEXT</code>&nbsp;字段需要在磁盘上存储一个用于定位文本块的指针。</li> \n  <li>使用&nbsp;<code>INT</code>&nbsp;类型存储高达 2^32 或 40 亿的较大数字。</li> \n  <li>使用&nbsp;<code>DECIMAL</code>&nbsp;类型存储货币可以避免浮点数表示错误。</li> \n  <li>避免使用&nbsp;<code>BLOBS</code>&nbsp;存储对象，存储存放对象的位置。</li> \n  <li><code>VARCHAR(255)</code>&nbsp;是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li> \n  <li>在适用场景中设置&nbsp;<code>NOT NULL</code>&nbsp;约束来提高搜索性能。</li> \n </ul> \n <p>使用正确的索引</p> \n <ul> \n  <li>你正查询（<code>SELECT</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>JOIN</code>）的列如果用了索引会更快。</li> \n  <li>索引通常表示为自平衡的&nbsp;B 树，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li> \n  <li>设置索引，会将数据存在内存中，占用了更多内存空间。</li> \n  <li>写入操作会变慢，因为索引需要被更新。</li> \n  <li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li> \n </ul> \n <p>避免高成本的联结操作</p> \n <ul> \n  <li>有性能需要，可以进行非规范化。</li> \n </ul> \n <p>分割数据表</p> \n <ul> \n  <li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li> \n </ul> \n <p>调优查询缓存</p> \n <ul> \n  <li>在某些情况下，查询缓存可能会导致性能问题。</li> \n </ul> \n <span id=\"OSC_h3_45\"></span> \n <h3>NoSQL</h3> \n <p>NoSQL 是<strong>键-值数据库</strong>、<strong>文档型数据库</strong>、<strong>列型数据库</strong>或<strong>图数据库</strong>的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持最终一致。</p> \n <p><strong>BASE</strong>&nbsp;通常被用于描述 NoSQL 数据库的特性。相比&nbsp;CAP 理论，BASE 强调可用性超过一致性。</p> \n <ul> \n  <li><strong>基本可用</strong>&nbsp;- 系统保证可用性。</li> \n  <li><strong>软状态</strong>&nbsp;- 即使没有输入，系统状态也可能随着时间变化。</li> \n  <li><strong>最终一致性</strong>&nbsp;- 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li> \n </ul> \n <p>除了在&nbsp;SQL 还是 NoSQL&nbsp;之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下&nbsp;<strong>键-值存储</strong>、<strong>文档型存储</strong>、<strong>列型存储</strong>和<strong>图存储</strong>数据库。</p> \n <span id=\"OSC_h4_46\"></span> \n <h4>键-值存储</h4> \n <blockquote> \n  <p>抽象模型：哈希表</p> \n </blockquote> \n <p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按字典顺序维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p> \n <p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p> \n <p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p> \n <span id=\"OSC_h4_47\"></span> \n <h4>文档类型存储</h4> \n <blockquote> \n  <p>抽象模型：将文档作为值的键-值存储</p> \n </blockquote> \n <p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p> \n <p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p> \n <p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p> \n <p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p> \n <span id=\"OSC_h4_48\"></span> \n <h4>列型存储</h4> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6e3136694f476b2e706e67.\">&nbsp;</p> \n <blockquote> \n  <p>抽象模型：嵌套的&nbsp;<code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code>&nbsp;映射</p> \n </blockquote> \n <p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p> \n <p>Google 发布了第一个列型存储数据库&nbsp;Bigtable，它影响了 Hadoop 生态系统中活跃的开源数据库&nbsp;HBase&nbsp;和 Facebook 的&nbsp;Cassandra。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p> \n <p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p> \n <span id=\"OSC_h4_49\"></span> \n <h4>图数据库</h4> \n <p><a href=\"https://camo.githubusercontent.com/bf6508b65e98a7210d9861515833afa0d9434436/687474703a2f2f692e696d6775722e636f6d2f664e636c3635672e706e67\" target=\"_blank\" rel=\"nofollow\"><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f664e636c3635672e706e67.\"></a>&nbsp;</p> \n <blockquote> \n  <p>抽象模型： 图</p> \n </blockquote> \n <p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p> \n <p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过&nbsp;REST API&nbsp;访问。</p> \n <span id=\"OSC_h3_50\"></span> \n <h3>SQL 还是 NoSQL</h3> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f775847714735662e706e67.\">&nbsp;</p> \n <p>选取&nbsp;<strong>SQL</strong>&nbsp;的原因:</p> \n <ul> \n  <li>结构化数据</li> \n  <li>严格的模式</li> \n  <li>关系型数据</li> \n  <li>需要复杂的联结操作</li> \n  <li>事务</li> \n  <li>清晰的扩展模式</li> \n  <li>既有资源更丰富：开发者、社区、代码库、工具等</li> \n  <li>通过索引进行查询非常快</li> \n </ul> \n <p>选取&nbsp;<strong>NoSQL</strong>&nbsp;的原因：</p> \n <ul> \n  <li>半结构化数据</li> \n  <li>动态或灵活的模式</li> \n  <li>非关系型数据</li> \n  <li>不需要复杂的联结操作</li> \n  <li>存储 TB （甚至 PB）级别的数据</li> \n  <li>高数据密集的工作负载</li> \n  <li>IOPS 高吞吐量</li> \n </ul> \n <p>适合 NoSQL 的示例数据：</p> \n <ul> \n  <li>埋点数据和日志数据</li> \n  <li>排行榜或者得分数据</li> \n  <li>临时数据，如购物车</li> \n  <li>频繁访问的（“热”）表</li> \n  <li>元数据／查找表</li> \n </ul> \n <span id=\"OSC_h2_51\"></span> \n <h2>12. 缓存</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f51367a32344c612e706e67.\"></p> \n <p>缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。</p> \n <p>数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。</p> \n <span id=\"OSC_h3_52\"></span> \n <h3>客户端缓存</h3> \n <p>缓存可以位于客户端（操作系统或者浏览器），服务端或者不同的缓存层。</p> \n <span id=\"OSC_h3_53\"></span> \n <h3>CDN 缓存</h3> \n <p>CDN&nbsp;也被视为一种缓存。</p> \n <span id=\"OSC_h3_54\"></span> \n <h3>Web 服务器缓存</h3> \n <p>反向代理和缓存（比如&nbsp;Varnish）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。</p> \n <span id=\"OSC_h3_55\"></span> \n <h3>数据库缓存</h3> \n <p>数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p> \n <span id=\"OSC_h3_56\"></span> \n <h3>应用缓存</h3> \n <p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如&nbsp;least recently used (LRU)&nbsp;的缓存无效算法可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p> \n <p>Redis 有下列附加功能：</p> \n <ul> \n  <li>持久性选项</li> \n  <li>内置数据结构比如有序集合和列表</li> \n </ul> \n <p>有多个缓存级别，分为两大类：<strong>数据库查询</strong>和<strong>对象</strong>：</p> \n <ul> \n  <li>行级别</li> \n  <li>查询级别</li> \n  <li>完整的可序列化对象</li> \n  <li>完全渲染的 HTML</li> \n </ul> \n <p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p> \n <span id=\"OSC_h3_57\"></span> \n <h3>数据库查询级别的缓存</h3> \n <p>当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：</p> \n <ul> \n  <li>很难用复杂的查询删除已缓存结果。</li> \n  <li>如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。</li> \n </ul> \n <span id=\"OSC_h3_58\"></span> \n <h3>对象级别的缓存</h3> \n <p>将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：</p> \n <ul> \n  <li>如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。</li> \n  <li>允许异步处理：workers 通过使用最新的缓存对象来组装对象。</li> \n </ul> \n <p>建议缓存的内容：</p> \n <ul> \n  <li>用户会话</li> \n  <li>完全渲染的 Web 页面</li> \n  <li>活动流</li> \n  <li>用户图数据</li> \n </ul> \n <span id=\"OSC_h3_59\"></span> \n <h3>何时更新缓存</h3> \n <p>由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。</p> \n <span id=\"OSC_h4_60\"></span> \n <h4>缓存模式</h4> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f4f4e6a4f52716b2e706e67.\"></p> \n <p>应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：</p> \n <ul> \n  <li>在缓存中查找记录，如果所需数据不在缓存中</li> \n  <li>从数据库中加载所需内容</li> \n  <li>将查找到的结果存储到缓存中</li> \n  <li>返回所需内容</li> \n </ul> \n <pre><code>def get_user(self, user_id):\r\n    user = cache.get(\"user.{0}\", user_id)\r\n    if user is None:\r\n        user = db.query(\"SELECT * FROM users WHERE user_id = {0}\", user_id)\r\n        if user is not None:\r\n            key = \"user.{0}\".format(user_id)\r\n            cache.set(key, json.dumps(user))\r\n    return user\r\n</code></pre> \n <p>Memcached&nbsp;通常用这种方式使用。</p> \n <p>添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。</p> \n <p>缓存的缺点：</p> \n <ul> \n  <li>请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。</li> \n  <li>如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置 � TTL 强制更新缓存或者直写模式来缓解这种情况。</li> \n  <li>当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。</li> \n </ul> \n <span id=\"OSC_h4_61\"></span> \n <h4>直写模式</h4> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f3076426330684e2e706e67.\">&nbsp;</p> \n <p>应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p> \n <ul> \n  <li>应用向缓存中添加/更新数据</li> \n  <li>缓存同步地写入数据存储</li> \n  <li>返回所需内容</li> \n </ul> \n <p>应用代码：</p> \n <pre><code>set_user(12345, {\"foo\":\"bar\"})\r\n</code></pre> \n <p>缓存代码：</p> \n <pre><code>def set_user(user_id, values):\r\n    user = db.query(\"UPDATE Users WHERE id = {0}\", user_id, values)\r\n    cache.set(user_id, user)\r\n</code></pre> \n <p>由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。</p> \n <p>直写模式的缺点：</p> \n <ul> \n  <li>由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。</li> \n  <li>写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。</li> \n </ul> \n <span id=\"OSC_h4_62\"></span> \n <h4>回写模式</h4> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f72675372766a472e706e67.\">&nbsp;</p> \n <p>在回写模式中，应用执行以下操作：</p> \n <ul> \n  <li>在缓存中增加或者更新条目</li> \n  <li>异步写入数据，提高写入性能。</li> \n </ul> \n <p>回写模式的缺点：</p> \n <ul> \n  <li>缓存可能在其内容成功存储之前丢失数据。</li> \n  <li>执行直写模式比缓存或者回写模式更复杂。</li> \n </ul> \n <span id=\"OSC_h4_63\"></span> \n <h4>刷新</h4> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6b78746a7167452e706e67.\"></p> \n <p>你可以将缓存配置成在到期之前自动刷新最近访问过的内容。</p> \n <p>如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。</p> \n <p>刷新的缺点：</p> \n <ul> \n  <li>不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。</li> \n </ul> \n <span id=\"OSC_h3_64\"></span> \n <h3>缓存的缺点：</h3> \n <ul> \n  <li>需要保持缓存和真实数据源之间的一致性，比如数据库根据缓存无效。</li> \n  <li>需要改变应用程序比如增加 Redis 或者 memcached。</li> \n  <li>无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。</li> \n </ul> \n <span id=\"OSC_h2_65\"></span> \n <h2>13. 异步</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f353447597353782e706e67.\"></p> \n <p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。</p> \n <span id=\"OSC_h3_66\"></span> \n <h3>消息队列</h3> \n <p>消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：</p> \n <ul> \n  <li>应用程序将作业发布到队列，然后通知用户作业状态</li> \n  <li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成</li> \n </ul> \n <p>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</p> \n <p><strong>Redis</strong>&nbsp;是一个令人满意的简单的消息代理，但是消息有可能会丢失。</p> \n <p><strong>RabbitMQ</strong>&nbsp;很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。</p> \n <p><strong>Amazon SQS</strong>&nbsp;是被托管的，但可能具有高延迟，并且消息可能会被传送两次。</p> \n <span id=\"OSC_h3_67\"></span> \n <h3>任务队列</h3> \n <p>任务队列接收任务及其相关数据，运行它们，然后传递其结果。 它们可以支持调度，并可用于在后台运行计算密集型作业。</p> \n <p><strong>Celery</strong>&nbsp;支持调度，主要是用 Python 开发的。</p> \n <span id=\"OSC_h3_68\"></span> \n <h3>背压</h3> \n <p>如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。背压可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是指数退避。</p> \n <span id=\"OSC_h3_69\"></span> \n <h3>异步的缺点：</h3> \n <ul> \n  <li>简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。</li> \n </ul> \n <span id=\"OSC_h2_70\"></span> \n <h2>14. 通讯</h2> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f354b656f6351732e6a7067.\">&nbsp;</p> \n <span id=\"OSC_h3_71\"></span> \n <h3>超文本传输协议（HTTP）</h3> \n <p>HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。</p> \n <p>一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：</p> \n <table> \n  <tbody> \n   <tr> \n    <th>动词</th> \n    <th>描述</th> \n    <th>*幂等</th> \n    <th>安全性</th> \n    <th>可缓存</th> \n   </tr> \n  </tbody> \n  <tbody> \n   <tr> \n    <td>GET</td> \n    <td>读取资源</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n   <tr> \n    <td>POST</td> \n    <td>创建资源或触发处理数据的进程</td> \n    <td>No</td> \n    <td>No</td> \n    <td>Yes，如果回应包含刷新信息</td> \n   </tr> \n   <tr> \n    <td>PUT</td> \n    <td>创建或替换资源</td> \n    <td>Yes</td> \n    <td>No</td> \n    <td>No</td> \n   </tr> \n   <tr> \n    <td>PATCH</td> \n    <td>部分更新资源</td> \n    <td>No</td> \n    <td>No</td> \n    <td>Yes，如果回应包含刷新信息</td> \n   </tr> \n   <tr> \n    <td>DELETE</td> \n    <td>删除资源</td> \n    <td>Yes</td> \n    <td>No</td> \n    <td>No</td> \n   </tr> \n  </tbody> \n </table> \n <p><strong>多次执行不会产生不同的结果</strong>。</p> \n <p>HTTP 是依赖于较低级协议（如&nbsp;<strong>TCP</strong>&nbsp;和&nbsp;<strong>UDP</strong>）的应用层协议。</p> \n <span id=\"OSC_h3_72\"></span> \n <h3>传输控制协议（TCP）</h3> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f4a6441736476472e6a7067.\">&nbsp;<br> &nbsp;</p> \n <p>TCP 是通过&nbsp;IP 网络的面向连接的协议。 使用握手建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：</p> \n <ul> \n  <li>每个数据包的序列号和校验码。</li> \n  <li>确认包和自动重传</li> \n </ul> \n <p>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行流量控制和拥塞控制。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</p> \n <p>为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个&nbsp;memcached&nbsp;服务器。连接池&nbsp;可以帮助除了在适用的情况下切换到 UDP。</p> \n <p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p> \n <p>以下情况使用 TCP 代替 UDP：</p> \n <ul> \n  <li>你需要数据完好无损。</li> \n  <li>你想对网络吞吐量自动进行最佳评估。</li> \n </ul> \n <span id=\"OSC_h3_73\"></span> \n <h3>用户数据报协议（UDP）</h3> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f797a44724a74412e6a7067.\">&nbsp;</p> \n <p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p> \n <p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对&nbsp;DHCP&nbsp;很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p> \n <p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p> \n <p>以下情况使用 UDP 代替 TCP：</p> \n <ul> \n  <li>你需要低延迟</li> \n  <li>相对于数据丢失更糟的是数据延迟</li> \n  <li>你想实现自己的错误校正方法</li> \n </ul> \n <span id=\"OSC_h3_74\"></span> \n <h3>远程过程调用协议（RPC）</h3> \n <p><img src=\"https://oscimg.oschina.net/oscnet/687474703a2f2f692e696d6775722e636f6d2f6946344d6b62352e706e67.\">&nbsp;</p> \n <p>在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括&nbsp;Protobuf、Thrift&nbsp;和&nbsp;Avro。</p> \n <p>RPC 是一个“请求-响应”协议：</p> \n <ul> \n  <li><strong>客户端程序</strong>&nbsp;── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。</li> \n  <li><strong>客户端 stub 程序</strong>&nbsp;── 将请求过程的 id 和参数打包进请求信息中。</li> \n  <li><strong>客户端通信模块</strong>&nbsp;── 将信息从客户端发送至服务端。</li> \n  <li><strong>服务端通信模块</strong>&nbsp;── 将接受的包传给服务端存根程序。</li> \n  <li><strong>服务端 stub 程序</strong>&nbsp;── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。</li> \n </ul> \n <p>RPC 调用示例：</p> \n <pre><code>GET /someoperation?data=anId\r\n\r\nPOST /anotheroperation\r\n{\r\n  \"data\":\"anId\";\r\n  \"anotherdata\": \"another value\"\r\n}\r\n</code></pre> \n <p>RPC 专注于暴露方法。RPC 通常用于处理内部通讯的性能问题，这样你可以手动处理本地调用以更好的适应你的情况。</p> \n <p>当以下情况时选择本地库（也就是 SDK）：</p> \n <ul> \n  <li>你知道你的目标平台。</li> \n  <li>你想控制如何访问你的“逻辑”。</li> \n  <li>你想对发生在你的库中的错误进行控制。</li> \n  <li>性能和终端用户体验是你最关心的事。</li> \n </ul> \n <p>遵循&nbsp;<strong>REST</strong>&nbsp;的 HTTP API 往往更适用于公共 API。</p> \n <span id=\"OSC_h4_75\"></span> \n <h4>缺点：RPC</h4> \n <ul> \n  <li>RPC 客户端与服务实现捆绑地很紧密。</li> \n  <li>一个新的 API 必须在每一个操作或者用例中定义。</li> \n  <li>RPC 很难调试。</li> \n  <li>你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在&nbsp;Squid&nbsp;这样的缓存服务器上确保&nbsp;RPC 被正确缓存的话可能需要一些额外的努力了。</li> \n </ul> \n <span id=\"OSC_h3_76\"></span> \n <h3>表述性状态转移（REST）</h3> \n <p>REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。</p> \n <p>RESTful 接口有四条规则：</p> \n <ul> \n  <li><strong>标志资源（HTTP 里的 URI）</strong>&nbsp;── 无论什么操作都使用同一个 URI。</li> \n  <li><strong>表示的改变（HTTP 的动作）</strong>&nbsp;── 使用动作, headers 和 body。</li> \n  <li><strong>可自我描述的错误信息（HTTP 中的 status code）</strong>&nbsp;── 使用状态码，不要重新造轮子。</li> \n  <li><strong>HATEOAS（HTTP 中的 HTML 接口）</strong>&nbsp;── 你的 web 服务器应该能够通过浏览器访问。</li> \n </ul> \n <p>REST 请求的例子：</p> \n <pre><code>GET /someresources/anId\r\n\r\nPUT /someresources/anId\r\n{\"anotherdata\": \"another value\"}\r\n</code></pre> \n <p>REST 关注于暴露数据。它减少了客户端／服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，通过 header 来表述并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。</p> \n <span id=\"OSC_h4_77\"></span> \n <h4>缺点：REST</h4> \n <ul> \n  <li>由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。</li> \n  <li>REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。</li> \n  <li>为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。</li> \n  <li>随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。</li> \n </ul> \n <span id=\"OSC_h3_78\"></span> \n <h3>RPC 与 REST 比较</h3> \n <table> \n  <tbody> \n   <tr> \n    <th>操作</th> \n    <th>RPC</th> \n    <th>REST</th> \n   </tr> \n  </tbody> \n  <tbody> \n   <tr> \n    <td>注册</td> \n    <td><strong>POST</strong>&nbsp;/signup</td> \n    <td><strong>POST</strong>&nbsp;/persons</td> \n   </tr> \n   <tr> \n    <td>注销</td> \n    <td><strong>POST</strong>&nbsp;/resign<br> {<br> \"personid\": \"1234\"<br> }</td> \n    <td><strong>DELETE</strong>&nbsp;/persons/1234</td> \n   </tr> \n   <tr> \n    <td>读取用户信息</td> \n    <td><strong>GET</strong>&nbsp;/readPerson?personid=1234</td> \n    <td><strong>GET</strong>&nbsp;/persons/1234</td> \n   </tr> \n   <tr> \n    <td>读取用户物品列表</td> \n    <td><strong>GET</strong>&nbsp;/readUsersItemsList?personid=1234</td> \n    <td><strong>GET</strong>&nbsp;/persons/1234/items</td> \n   </tr> \n   <tr> \n    <td>向用户物品列表添加一项</td> \n    <td><strong>POST</strong>&nbsp;/addItemToUsersItemsList<br> {<br> \"personid\": \"1234\";<br> \"itemid\": \"456\"<br> }</td> \n    <td><strong>POST</strong>&nbsp;/persons/1234/items<br> {<br> \"itemid\": \"456\"<br> }</td> \n   </tr> \n   <tr> \n    <td>更新一个物品</td> \n    <td><strong>POST</strong>&nbsp;/modifyItem<br> {<br> \"itemid\": \"456\";<br> \"key\": \"value\"<br> }</td> \n    <td><strong>PUT</strong>&nbsp;/items/456<br> {<br> \"key\": \"value\"<br> }</td> \n   </tr> \n   <tr> \n    <td>删除一个物品</td> \n    <td><strong>POST</strong>&nbsp;/removeItem<br> {<br> \"itemid\": \"456\"<br> }</td> \n    <td><strong>DELETE</strong>&nbsp;/items/456</td> \n   </tr> \n  </tbody> \n </table> \n <span id=\"OSC_h2_79\"></span> \n <h2>15. 安全</h2> \n <p>这一部分需要更多内容。一起来吧！</p> \n <p>安全是一个宽泛的话题。除非你有相当的经验、安全方面背景或者正在申请的职位要求安全知识，你不需要了解安全基础知识以外的内容：</p> \n <ul> \n  <li>在运输和等待过程中加密</li> \n  <li>对所有的用户输入和从用户那里发来的参数进行处理以防止&nbsp;XSS&nbsp;和&nbsp;SQL 注入。</li> \n  <li>使用参数化的查询来防止 SQL 注入。</li> \n  <li>使用最小权限原则。</li> \n </ul> \n <span id=\"OSC_h2_80\"></span> \n <h2>16. 附录</h2> \n <p>一些时候你会被要求做出保守估计。比如，你可能需要估计从磁盘中生成 100 张图片的缩略图需要的时间或者一个数据结构需要多少的内存。<strong>2 的次方表</strong>和<strong>每个开发者都需要知道的一些时间数据</strong>（译注：OSChina 上有这篇文章的译文）都是一些很方便的参考资料。</p> \n <span id=\"OSC_h3_81\"></span> \n <h3>2 的次方表</h3> \n <pre><code>Power           Exact Value         Approx Value        Bytes\r\n---------------------------------------------------------------\r\n7                             128\r\n8                             256\r\n10                           1024   1 thousand           1 KB\r\n16                         65,536                       64 KB\r\n20                      1,048,576   1 million            1 MB\r\n30                  1,073,741,824   1 billion            1 GB\r\n32                  4,294,967,296                        4 GB\r\n40              1,099,511,627,776   1 trillion           1 TB\r\n</code></pre> \n <span id=\"OSC_h4_82\"></span> \n <h4>&nbsp;</h4> \n <span id=\"OSC_h3_83\"></span> \n <h3>每个程序员都应该知道的延迟数</h3> \n <pre><code>Latency Comparison Numbers\r\n--------------------------\r\nL1 cache reference                           0.5 ns\r\nBranch mispredict                            5   ns\r\nL2 cache reference                           7   ns                      14x L1 cache\r\nMutex lock/unlock                          100   ns\r\nMain memory reference                      100   ns                      20x L2 cache, 200x L1 cache\r\nCompress 1K bytes with Zippy            10,000   ns       10 us\r\nSend 1 KB bytes over 1 Gbps network     10,000   ns       10 us\r\nRead 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD\r\nRead 1 MB sequentially from memory     250,000   ns      250 us\r\nRound trip within same datacenter      500,000   ns      500 us\r\nRead 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory\r\nDisk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip\r\nRead 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD\r\nRead 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD\r\nSend packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms\r\n\r\nNotes\r\n-----\r\n1 ns = 10^-9 seconds\r\n1 us = 10^-6 seconds = 1,000 ns\r\n1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns\r\n</code></pre> \n <p>基于上述数字的指标：</p> \n <ul> \n  <li>从磁盘以 30 MB/s 的速度顺序读取</li> \n  <li>以 100 MB/s 从 1 Gbps 的以太网顺序读取</li> \n  <li>从 SSD 以 1 GB/s 的速度读取</li> \n  <li>以 4 GB/s 的速度从主存读取</li> \n  <li>每秒能绕地球 6-7 圈</li> \n  <li>数据中心内每秒有 2,000 次往返</li> \n </ul> \n <span id=\"OSC_h4_84\"></span> \n <h4>延迟数可视化</h4> \n <p><img alt=\"\" height=\"512\" src=\"https://oscimg.oschina.net/oscnet/cfafa321f69846eff8a4801ee20828db456.jpg\" width=\"1024\"><img alt=\"\" height=\"391\" src=\"https://oscimg.oschina.net/oscnet/668b118f78c259f40f2a3aa57baf1f3ae4f.jpg\" width=\"1330\"></p> \n</div>',NULL,'2020-02-09 15:14:16',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226404145804705792',NULL,NULL,' 整理了20个最全的设计师学习网站，推荐收藏！  ','<div class=\"content\" id=\"articleContent\"> \n <p>设计师都喜欢浏览一些设计网站，那么什么样的网站是对我们平时的工作学习有一定的帮助的呢？今天小编给大家整理了20个设计网站，用途不同，觉得有用的小伙伴可以收藏学习。</p> \n <div> \n  <div> \n   <img src=\"http://p1.pstatp.com/origin/dfic-imagehandler/721d2f27-6bfc-4b5c-8da6-13f805f10e6d\"> \n   <div> \n    <div> \n     <div>\n       &nbsp; \n     </div> \n    </div> \n   </div> \n  </div> \n </div> \n <p><strong>设计的网站推荐：</strong></p> \n <p>1， dribbble-追波</p> \n <p>比较潮流的设计内容查看。</p> \n <p>2， Behance</p> \n <p>国外的站酷。内容优质全面</p> \n <p>3.站酷</p> \n <p>国内设计师平台，每天必看。</p> \n <p>4.UI中国</p> \n <p>国内UI交流平台</p> \n <p>5.</p> \n <p>有很多非常棒的高清创意视频</p> \n <p>6.</p> \n <p>UI素材搜索引擎，提供大量的PSD源文件免费下载</p> \n <p>7.找字网</p> \n <p>找字网提供大量的中英文字体</p> \n <p>8.网页设计师联盟</p> \n <p>国内专业网页设计人才基地</p> \n <p>9.优设网</p> \n <p>一线设计师，总监干货分享。</p> \n <p>10.花瓣</p> \n <p>Huabanpro.com 你想要的花瓣回来了</p> \n <p>11.C4D之家</p> \n <p>12.。直线教程网</p> \n <p>视频学习网</p> \n <p>13.千图网</p> \n <p>素材下载</p> \n <p>14.包图网</p> \n <p>15.92素材网</p> \n <p>16.JVshi</p> \n <p>正版素材</p> \n <p>17.映速社区</p> \n <p>很好的教学平台</p> \n <p>18.doyoudo</p> \n <p>小莫老师不容错过</p> \n <p>19.盒子UI</p> \n <p>20.FONTS</p> \n <p>全球最大的字体提供者</p> \n</div>',NULL,'2020-02-09 15:15:09',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226404368165732352',NULL,NULL,' 京东Java架构师讲解购物车的原理及Java实现   ','<div class=\"content\" id=\"articleContent\"> \n <p><strong>今天来写一下关于购物车的东西, 这里首先抛出四个问题:</strong></p> \n <p>1）用户没登陆用户名和密码,添加商品, 关闭浏览器再打开后&nbsp;<strong>不登录<strong>用户名和密码</strong></strong>　问：购物车商品还在吗？&nbsp;</p> \n <p>2）用户登陆了用户名密码,添加商品,关闭浏览器再打开后&nbsp;<strong>不登录<strong>用户名和密码</strong></strong>　问:购物车商品还在吗？&nbsp;&nbsp;&nbsp;</p> \n <p>3）用户登陆了用户名密码,添加商品, 关闭浏览器,然后再打开,<strong>登陆用户名和密码</strong>&nbsp;&nbsp;问:购物车商品还在吗？</p> \n <p>4）用户登陆了用户名密码,添加商品,&nbsp;关闭浏览器 外地老家打开浏览器 &nbsp;<strong>登陆用户名和密码</strong>&nbsp;问：购物车商品还在吗？</p> \n <p>上面四个问题都是以京东为模板, 那么大家猜猜结果是什么呢？</p> \n <p>１）在</p> \n <p>２）不在了</p> \n <p>３）在</p> \n <p>４）在<br> <br> 如果你能够猜到答案, 那么说明你真的很棒, 那么关于这四点是怎么实现的呢?　（如果有不认可的小伙伴可以用京东实验一下）</p> \n <p>下面我们就来讲解下购物车的原理,最后再来说下具体的code实现.</p> \n <p>1)用户没有登录, 添加商品, 此时的商品是被添加到了浏览器的Cookie中, 所以当再次访问时(不登录),商品仍然在Cookie中, 所以购物车中的商品还是存在的.</p> \n <p>2)用户登录了,添加商品, 此时会将Cookie中和用户选择的商品都添加到购物车中, 然后删除Cookie中的商品. 所以当用户再次访问(不登录),此时Cookie中的购物车商品已经被删除了, 所以此时购物车中的商品不在了.</p> \n <p>3)用户登录, 添加商品,此时商品被添加到数据库做了持久化存储, 再次打开登录用户名和密码, 该用户选择的商品肯定还是存在的, 所以购物车中的商品还是存在的.</p> \n <p>4)理由3)</p> \n <p><strong>这里再说下 没登录 保存商品到Cookie的优点以及保存到Session和数据库的对比:</strong></p> \n <p>1：Cookie： 优点： 保存用户浏览器（不用浪费我们公司的服务器） 缺点：Cookie禁用，不提供保存</p> \n <p>2：Session：（Redis ： 浪费大量服务器内存：实现、禁用Cookie） &nbsp;速度很快</p> \n <p>3：数据库（Mysql、Redis、SOlr） &nbsp;能持久化的就数据库 &nbsp;速度太慢</p> \n <p><strong>那么我今天要讲的就是:</strong></p> \n <ul> \n  <li> <p>用户没登陆：购物车添加到Cookie中</p> </li> \n  <li> <p>用户登陆： 保存购物车到Redis中 &nbsp;（不用数据库）</p> </li> \n </ul> \n <p><strong>整体的思路图解:</strong></p> \n <p><img src=\"https://static.oschina.net/uploads/img/201805/17095718_cRH9.png\"></p> \n <p><strong>接下来就是代码实例来实现 购物车的功能了:</strong></p> \n <p><strong>首先我们看下购物车和购物项两个JavaBean的设计:</strong></p> \n <p>购物车: buyerCart.java</p> \n <pre><code class=\"language-java\">1&nbsp;public&nbsp;class&nbsp;BuyerCart&nbsp;implements&nbsp;Serializable{\n2&nbsp;\n3&nbsp;&nbsp; &nbsp;&nbsp;/**\n4 &nbsp; &nbsp; &nbsp;* 购物车\n5 &nbsp; &nbsp; &nbsp;*/\n6&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID =&nbsp;1L;\n7&nbsp;&nbsp; &nbsp;&nbsp;\n8&nbsp;&nbsp; &nbsp;&nbsp;//商品结果集\n9&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;List&lt;BuyerItem&gt; items =&nbsp;new&nbsp;ArrayList&lt;BuyerItem&gt;();\n10&nbsp;&nbsp; &nbsp;&nbsp;\n11&nbsp;&nbsp; &nbsp;&nbsp;//添加购物项到购物车\n12&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;addItem(BuyerItem item){\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//判断是否包含同款\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(items.contains(item)) {\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//追加数量\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(BuyerItem buyerItem : items) {\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(buyerItem.equals(item)) {\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setAmount(item.getAmount() + buyerItem.getAmount());\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n20&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n21&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }else&nbsp;{\n22&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items.add(item);\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n24&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n25&nbsp;&nbsp; &nbsp; }\n26&nbsp;\n27&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;List&lt;BuyerItem&gt;&nbsp;getItems()&nbsp;{\n28&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;items;\n29&nbsp;&nbsp; &nbsp; }\n30&nbsp;\n31&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;setItems(List&lt;BuyerItem&gt; items)&nbsp;{\n32&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.items = items;\n33&nbsp;&nbsp; &nbsp; }\n34&nbsp;&nbsp; &nbsp;&nbsp;\n35&nbsp;&nbsp; &nbsp;&nbsp;\n36&nbsp;&nbsp; &nbsp;&nbsp;//小计\n37&nbsp;&nbsp; &nbsp;&nbsp;//商品数量\n38&nbsp;&nbsp; &nbsp;&nbsp;@JsonIgnore\n39&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Integer&nbsp;getProductAmount(){\n40&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Integer result =&nbsp;0;\n41&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算\n42&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(BuyerItem buyerItem : items) {\n43&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += buyerItem.getAmount();\n44&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n45&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;result;\n46&nbsp;&nbsp; &nbsp; }\n47&nbsp;&nbsp; &nbsp;&nbsp;\n48&nbsp;&nbsp; &nbsp;&nbsp;//商品金额\n49&nbsp;&nbsp; &nbsp;&nbsp;@JsonIgnore\n50&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Float&nbsp;getProductPrice(){\n51&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Float result =&nbsp;0f;\n52&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算\n53&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(BuyerItem buyerItem : items) {\n54&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += buyerItem.getAmount()*buyerItem.getSku().getPrice();\n55&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n56&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;result;\n57&nbsp;&nbsp; &nbsp; }\n58&nbsp;&nbsp; &nbsp;&nbsp;\n59&nbsp;&nbsp; &nbsp;&nbsp;//运费\n60&nbsp;&nbsp; &nbsp;&nbsp;@JsonIgnore\n61&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Float&nbsp;getFee(){\n62&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Float result =&nbsp;0f;\n63&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算\n64&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(getProductPrice() &lt;&nbsp;79) {\n65&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result =&nbsp;5f;\n66&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n67&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n68&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;result;\n69&nbsp;&nbsp; &nbsp; }\n70&nbsp;&nbsp; &nbsp;&nbsp;\n71&nbsp;&nbsp; &nbsp;&nbsp;//总价\n72&nbsp;&nbsp; &nbsp;&nbsp;@JsonIgnore\n73&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Float&nbsp;getTotalPrice(){\n74&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getProductPrice() + getFee();\n75&nbsp;&nbsp; &nbsp; }\n76&nbsp;&nbsp; &nbsp;&nbsp;\n77&nbsp;}</code></pre> \n <p>这里使用了@JsonIgonre注解是因为下面需要将BuyerCart 转换成Json格式, 而这几个字段只有get 方法, 所以不能转换, 需要使用忽略Json.</p> \n <p>下面是购物项: buyerItem.java</p> \n <pre><code class=\"language-java\">1&nbsp;public&nbsp;class&nbsp;BuyerItem&nbsp;implements&nbsp;Serializable{\n2&nbsp;\n3&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID =&nbsp;1L;\n4&nbsp;\n5&nbsp;&nbsp; &nbsp;&nbsp;//SKu对象\n6&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;Sku sku;\n7&nbsp;&nbsp; &nbsp;&nbsp;\n8&nbsp;&nbsp; &nbsp;&nbsp;//是否有货\n9&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;Boolean isHave =&nbsp;true;\n10&nbsp;&nbsp; &nbsp;&nbsp;\n11&nbsp;&nbsp; &nbsp;&nbsp;//购买的数量\n12&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;Integer amount =&nbsp;1;\n13&nbsp;\n14&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Sku&nbsp;getSku()&nbsp;{\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;sku;\n16&nbsp;&nbsp; &nbsp; }\n17&nbsp;\n18&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;setSku(Sku sku)&nbsp;{\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.sku = sku;\n20&nbsp;&nbsp; &nbsp; }\n21&nbsp;\n22&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Boolean&nbsp;getIsHave()&nbsp;{\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;isHave;\n24&nbsp;&nbsp; &nbsp; }\n25&nbsp;\n26&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;setIsHave(Boolean isHave)&nbsp;{\n27&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.isHave = isHave;\n28&nbsp;&nbsp; &nbsp; }\n29&nbsp;\n30&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Integer&nbsp;getAmount()&nbsp;{\n31&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;amount;\n32&nbsp;&nbsp; &nbsp; }\n33&nbsp;\n34&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;setAmount(Integer amount)&nbsp;{\n35&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.amount = amount;\n36&nbsp;&nbsp; &nbsp; }\n37&nbsp;\n38&nbsp;&nbsp; &nbsp;&nbsp;@Override\n39&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;{\n40&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;int&nbsp;prime =&nbsp;31;\n41&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;int&nbsp;result =&nbsp;1;\n42&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; result = prime * result + ((sku ==&nbsp;null) ?&nbsp;0&nbsp;: sku.hashCode());\n43&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;result;\n44&nbsp;&nbsp; &nbsp; }\n45&nbsp;\n46&nbsp;&nbsp; &nbsp;&nbsp;@Override\n47&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object obj)&nbsp;{\n48&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(this&nbsp;== obj)&nbsp;//比较地址\n49&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;true;\n50&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(obj ==&nbsp;null)\n51&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;\n52&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(getClass() != obj.getClass())\n53&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;\n54&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; BuyerItem other = (BuyerItem) obj;\n55&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(sku ==&nbsp;null) {\n56&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(other.sku !=&nbsp;null)\n57&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;\n58&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(!sku.getId().equals(other.sku.getId()))\n59&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;\n60&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;true;\n61&nbsp;&nbsp; &nbsp; }\n62&nbsp;}</code></pre> \n <span id=\"OSC_h2_1\"></span> \n <h2><span style=\"color:#FF0000\">1、将商品加入购物车中</span></h2> \n <p><img src=\"https://static.oschina.net/uploads/img/201805/17100742_MPBo.png\"></p> \n <pre><code class=\"language-java\">1&nbsp;//加入购物车\n2&nbsp;function&nbsp;&nbsp;addCart(){\n3&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;// &nbsp;+ skuId\n4&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;window.location.href=\"/shopping/buyerCart?skuId=\"+skuId+\"&amp;amount=\"+$(\"#buy-num\").val();\n5&nbsp;}</code></pre> \n <p>这里传入的参数是skuId(库存表的主键, 库存表保存的商品id,颜色,尺码,库存等信息), 购买数量amount.</p> \n <p><strong>接着我们来看Controller是如何来处理的:</strong></p> \n <pre><code class=\"language-java\">1&nbsp;//加入购物车\n2&nbsp;&nbsp; &nbsp;&nbsp;@RequestMapping(value=\"/shopping/buyerCart\")\n3&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;&lt;T&gt;&nbsp;String&nbsp;buyerCart(Long skuId, Integer amount, HttpServletRequest request,\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response)&nbsp;throws&nbsp;JsonParseException, JsonMappingException, IOException{\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将对象转换成json字符串/json字符串转成对象\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ObjectMapper om =&nbsp;new&nbsp;ObjectMapper();\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; om.setSerializationInclusion(Include.NON_NULL);\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; BuyerCart buyerCart =&nbsp;null;\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1,获取Cookie中的购物车\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Cookie[] cookies = request.getCookies();\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= cookies &amp;&amp; cookies.length &gt;&nbsp;0) {\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Cookie cookie : cookies) {\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Constants.BUYER_CART.equals(cookie.getName())) {\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//购物车 对象 与json字符串互转\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart = om.readValue(cookie.getValue(), BuyerCart.class);\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n20&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n21&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n22&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2,Cookie中没有购物车, 创建购物车对象\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;== buyerCart) {\n24&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart =&nbsp;new&nbsp;BuyerCart();\n25&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n26&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n27&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3, 将当前款商品追加到购物车\n28&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= skuId &amp;&amp;&nbsp;null&nbsp;!= amount) {\n29&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sku sku =&nbsp;new&nbsp;Sku();\n30&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku.setId(skuId);\n31&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BuyerItem buyerItem =&nbsp;new&nbsp;BuyerItem();\n32&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setSku(sku);\n33&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//设置数量\n34&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setAmount(amount);\n35&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//添加购物项到购物车\n36&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart.addItem(buyerItem);\n37&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n38&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n39&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//排序 &nbsp;倒序\n40&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; List&lt;BuyerItem&gt; items = buyerCart.getItems();\n41&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Collections.sort(items,&nbsp;new&nbsp;Comparator&lt;BuyerItem&gt;() {\n42&nbsp;\n43&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;@Override\n44&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;public&nbsp;int&nbsp;compare(BuyerItem o1, BuyerItem o2)&nbsp;{\n45&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;-1;\n46&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n47&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n48&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; });\n49&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n50&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//前三点 登录和非登录做的是一样的操作, 在第四点需要判断\n51&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; String username = sessionProviderService.getAttributterForUsername(RequestUtils.getCSessionId(request, response));\n52&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= username) {\n53&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//登录了\n54&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4, 将购物车追加到Redis中\n55&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cartService.insertBuyerCartToRedis(buyerCart, username);\n56&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//5, 清空Cookie 设置存活时间为0, 立马销毁\n57&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cookie cookie =&nbsp;new&nbsp;Cookie(Constants.BUYER_CART,&nbsp;null);\n58&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setPath(\"/\");\n59&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setMaxAge(-0);\n60&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.addCookie(cookie);\n61&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }else&nbsp;{\n62&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//未登录\n63&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4, 保存购物车到Cookie中\n64&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将对象转换成json格式\n65&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Writer w =&nbsp;new&nbsp;StringWriter();\n66&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; om.writeValue(w, buyerCart);\n67&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cookie cookie =&nbsp;new&nbsp;Cookie(Constants.BUYER_CART, w.toString());\n68&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//设置path是可以共享cookie\n69&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setPath(\"/\");\n70&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//设置Cookie过期时间: -1 表示关闭浏览器失效 &nbsp;0: 立即失效 &nbsp;&gt;0: 单位是秒, 多少秒后失效\n71&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setMaxAge(24*60*60);\n72&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//5,Cookie写会浏览器\n73&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.addCookie(cookie);\n74&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n75&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n76&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//6, 重定向\n77&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;\"redirect:/shopping/toCart\";\n78&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>这里设计一个知识点:&nbsp;将对象转换成json字符串/json字符串转成对象</p> \n <p>我们在这里先写一个小的Demo来演示json和对象之间的互转, 这里使用到了springmvc中的ObjectMapper类.</p> \n <pre><code class=\"language-java\">1&nbsp;public&nbsp;class&nbsp;TestJson&nbsp;{\n2&nbsp;\n3&nbsp;&nbsp; &nbsp; @Test\n4&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;testAdd() throws Exception&nbsp;{\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; TestTb testTb =&nbsp;new&nbsp;TestTb();\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; testTb.setName(\"范冰冰\");\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ObjectMapper om =&nbsp;new&nbsp;ObjectMapper();\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; om.setSerializationInclusion(Include.NON_NULL);\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将对象转换成json字符串\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Writer wr =&nbsp;new&nbsp;StringWriter();\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; om.writeValue(wr, testTb);\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(wr.toString());\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//转回对象\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; TestTb r = om.readValue(wr.toString(), TestTb.class);\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(r.toString());\n17&nbsp;&nbsp; &nbsp; }\n18&nbsp;&nbsp; &nbsp;&nbsp;\n19&nbsp;}</code></pre> \n <p>执行结果:&nbsp;</p> \n <p><img src=\"https://static.oschina.net/uploads/img/201805/17095718_SSYc.png\"></p> \n <p>这里我们使用了Include.NON_NULL, 如果TestTb 中属性为null 的就不给转换成Json, 从对象--&gt;Json字符串&nbsp;&nbsp;用的是&nbsp;objectMapper.writeValue(). 从Json字符串--&gt;对象使用的是objectMapper.readValue().<br> 回归上面我们项目中的代码, 只有未登录 添加商品时才会将此商品添加到Cookie中.</p> \n <pre><code class=\"language-java\">1&nbsp;//未登录\n2&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4, 保存购物车到Cookie中\n3&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将对象转换成json格式\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Writer w =&nbsp;new&nbsp;StringWriter();\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; om.writeValue(w, buyerCart);\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cookie cookie =&nbsp;new&nbsp;Cookie(Constants.BUYER_CART, w.toString());\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//设置path是可以共享cookie\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setPath(\"/\");\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//设置Cookie过期时间: -1 表示关闭浏览器失效 &nbsp;0: 立即失效 &nbsp;&gt;0: 单位是秒, 多少秒后失效\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setMaxAge(24*60*60);\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//5,Cookie写会浏览器\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.addCookie(cookie);</code></pre> \n <p>我们debug 可以看到:</p> \n <p><img src=\"https://static.oschina.net/uploads/img/201805/17095718_nSww.png\"></p> \n <p>这里已经将对象购物车对象buyerCart转换成了Json格式.</p> \n <p>将商品添加到购物车, 不管是登录还是未登录, 都要先取出Cookie中的购物车, 然后将当前选择的商品追加到购物车中.</p> \n <p>然后登录的话 &nbsp;就把Cookie中的购物车清空, 并将购物车的内容添加到Redis中做持久化保存.</p> \n <p>如果未登录, 将选择的商品追加到Cookie中.</p> \n <p>将购物车追加到Redis中的代码:insertBuyerCartToRedis(这里面包含了判断添加的是否是同款)</p> \n <pre><code class=\"language-java\">1&nbsp;//保存购物车到Redis中\n2&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;void&nbsp;insertBuyerCartToRedis(BuyerCart buyerCart,&nbsp;String&nbsp;username){\n3&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; List&lt;BuyerItem&gt; items = buyerCart.getItems();\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(items.size() &gt;&nbsp;0) {\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//redis中保存的是skuId 为key , amount 为value的Map集合\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String,&nbsp;String&gt; hash =&nbsp;new&nbsp;HashMap&lt;String,&nbsp;String&gt;();\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(BuyerItem item : items) {\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//判断是否有同款\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(jedis.hexists(\"buyerCart:\"+username,&nbsp;String.valueOf(item.getSku().getId()))) {\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jedis.hincrBy(\"buyerCart:\"+username,&nbsp;String.valueOf(item.getSku().getId()), item.getAmount());\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }else&nbsp;{\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash.put(String.valueOf(item.getSku().getId()),&nbsp;String.valueOf(item.getAmount()));\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(hash.size() &gt;&nbsp;0) {\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jedis.hmset(\"buyerCart:\"+username, hash);\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n20&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>判断用户是否登录:&nbsp;String username =</p> \n <p>sessionProviderService.getAttributterForUsername(RequestUtils.getCSessionId(request, response));</p> \n <pre><code class=\"language-java\">1&nbsp;public&nbsp;class&nbsp;RequestUtils&nbsp;{\n2&nbsp;\n3&nbsp;&nbsp; &nbsp;&nbsp;//获取CSessionID\n4&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;static&nbsp;String&nbsp;getCSessionId(HttpServletRequest request, HttpServletResponse response){\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1, 从Request中取Cookie\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Cookie[] cookies = request.getCookies();\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2, 从Cookie数据中遍历查找, 并取CSessionID\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= cookies &amp;&amp; cookies.length &gt;&nbsp;0) {\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Cookie cookie : cookies) {\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(\"CSESSIONID\".equals(cookie.getName())) {\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//有, 直接返回\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;cookie.getValue();\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//没有, 创建一个CSessionId, 并且放到Cookie再返回浏览器.返回新的CSessionID\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; String csessionid = UUID.randomUUID().toString().replaceAll(\"-\",&nbsp;\"\");\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//并且放到Cookie中\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Cookie cookie =&nbsp;new&nbsp;Cookie(\"CSESSIONID\", csessionid);\n20&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//cookie &nbsp;每次都带来, 设置路径\n21&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; cookie.setPath(\"/\");\n22&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//0:关闭浏览器 &nbsp;销毁cookie. 0:立即消失. &nbsp;&gt;0 存活时间,秒\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; cookie.setMaxAge(-1);\n24&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n25&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;csessionid;\n26&nbsp;&nbsp; &nbsp; }\n27&nbsp;}</code></pre> \n <p>&nbsp;</p> \n <pre><code class=\"language-java\">1&nbsp;//获取\n2&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;String&nbsp;getAttributterForUsername(String jessionId){\n3&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; String&nbsp;value&nbsp;= jedis.get(jessionId +&nbsp;\":USER_NAME\");\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if(null&nbsp;!=&nbsp;value){\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//计算session过期时间是 用户最后一次请求开始计时.\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jedis.expire(jessionId +&nbsp;\":USER_NAME\",&nbsp;60*exp);\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;value;\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;\n10&nbsp;&nbsp; &nbsp; }</code></pre> \n <span id=\"OSC_h2_2\"></span> \n <h2><span style=\"color:#FF0000\"><strong>2、购物车展示页面</strong></span></h2> \n <p><strong>最后 重定向到购物车展示页:&nbsp;return \"redirect:/shopping/toCart\"; 这里进入结算页有两种方式:</strong></p> \n <p><strong>1) 在商品详情页 点击加入购物车.</strong></p> \n <p><strong>2) 直接点击购物车按钮 进入购物车结算页.</strong></p> \n <p>下面来看下结算页的代码:</p> \n <pre><code class=\"language-java\">1&nbsp;@Autowired\n2&nbsp;&nbsp; &nbsp;&nbsp;private&nbsp;CartService cartService;\n3&nbsp;&nbsp; &nbsp;&nbsp;//去购物车结算, 这里有两个地方可以直达: 1,在商品详情页 中点击加入购物车按钮 &nbsp;2, 直接点击购物车按钮\n4&nbsp;&nbsp; &nbsp;&nbsp;@RequestMapping(value=\"/shopping/toCart\")\n5&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;String&nbsp;toCart(Model model, HttpServletRequest request,\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response) throws JsonParseException, JsonMappingException, IOException{&nbsp;\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//将对象转换成json字符串/json字符串转成对象\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; ObjectMapper om =&nbsp;new&nbsp;ObjectMapper();\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; om.setSerializationInclusion(Include.NON_NULL);\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; BuyerCart buyerCart =&nbsp;null;\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1,获取Cookie中的购物车\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Cookie[] cookies = request.getCookies();\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= cookies &amp;&amp; cookies.length &gt;&nbsp;0) {\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Cookie cookie : cookies) {\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Constants.BUYER_CART.equals(cookie.getName())) {\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//购物车 对象 与json字符串互转\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart = om.readValue(cookie.getValue(), BuyerCart.class);\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;\n20&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n21&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n22&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n24&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//判断是否登录\n25&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;String&nbsp;username = sessionProviderService.getAttributterForUsername(RequestUtils.getCSessionId(request, response));\n26&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= username) {\n27&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//登录了\n28&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2, 购物车 有东西, 则将购物车的东西保存到Redis中\n29&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;== buyerCart) {\n30&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cartService.insertBuyerCartToRedis(buyerCart, username);\n31&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//清空Cookie 设置存活时间为0, 立马销毁\n32&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cookie cookie =&nbsp;new&nbsp;Cookie(Constants.BUYER_CART,&nbsp;null);\n33&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setPath(\"/\");\n34&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cookie.setMaxAge(-0);\n35&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.addCookie(cookie);\n36&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n37&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3, 取出Redis中的购物车\n38&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart = cartService.selectBuyerCartFromRedis(username);\n39&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n40&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n41&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n42&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//4, 没有 则创建购物车\n43&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;== buyerCart) {\n44&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart =&nbsp;new&nbsp;BuyerCart();\n45&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n46&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n47&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//5, 将购物车装满, 前面只是将skuId装进购物车, 这里还需要查出sku详情\n48&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; List&lt;BuyerItem&gt; items = buyerCart.getItems();\n49&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if(items.size() &gt;&nbsp;0){\n50&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//只有购物车中有购物项, 才可以将sku相关信息加入到购物项中\n51&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(BuyerItem buyerItem : items) {\n52&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setSku(cartService.selectSkuById(buyerItem.getSku().getId()));\n53&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n54&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n55&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n56&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//5,上面已经将购物车装满了, 这里直接回显页面\n57&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; model.addAttribute(\"buyerCart\", buyerCart);\n58&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n59&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//跳转购物页面\n60&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;\"cart\";\n61&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>这里 就是 购物车详情展示页面, 这里需要注意, 如果是同一件商品连续添加, 是需要合并的.</p> \n <p>购物车详情展示页面就包括两大块, 1) 商品详情 2)总计(商品总额,运费)</p> \n <p>其中1)商品详情又包括 商品尺码,商品颜色, 商品购买数量, 是否有货.</p> \n <p><img src=\"https://static.oschina.net/uploads/img/201805/17095718_Nw8n.png\"></p> \n <p>取出Redis中的购物车:&nbsp;buyerCart = cartService.selectBuyerCartFromRedis(username);</p> \n <pre><code class=\"language-java\">1&nbsp;&nbsp; &nbsp;&nbsp;//取出Redis中购物车\n2&nbsp;&nbsp; &nbsp; public BuyerCart selectBuyerCartFromRedis(String&nbsp;username){\n3&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; BuyerCart buyerCart =&nbsp;new&nbsp;BuyerCart();\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//获取所有商品, redis中保存的是skuId 为key , amount 为value的Map集合\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Map&lt;String,&nbsp;String&gt; hgetAll = jedis.hgetAll(\"buyerCart:\"+username);\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Set&lt;Entry&lt;String,&nbsp;String&gt;&gt; entrySet = hgetAll.entrySet();\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Entry&lt;String,&nbsp;String&gt; entry : entrySet) {\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//entry.getKey(): skuId\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sku sku =&nbsp;new&nbsp;Sku();\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku.setId(Long.parseLong(entry.getKey()));\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BuyerItem buyerItem =&nbsp;new&nbsp;BuyerItem();\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setSku(sku);\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//entry.getValue(): amount\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setAmount(Integer.parseInt(entry.getValue()));\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//添加到购物车中\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart.addItem(buyerItem);\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;buyerCart;\n20&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>将购物车装满, 前面只是将skuId装进购物车, 这里还需要查出sku详情:&nbsp;List&lt;BuyerItem&gt; items = buyerCart.getItems();<br> buyerItem.setSku(cartService.selectSkuById(buyerItem.getSku().getId()));</p> \n <pre><code class=\"language-java\">1&nbsp;//向购物车中的购物项 添加相应的数据, 通过skuId 查询sku对象, 颜色对象, 商品对象\n2&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;Sku&nbsp;selectSkuById(Long skuId){\n3&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Sku sku = skuDao.selectByPrimaryKey(skuId);\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//颜色\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; sku.setColor(colorDao.selectByPrimaryKey(sku.getColorId()));\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//添加商品信息\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; sku.setProduct(productDao.selectByPrimaryKey(sku.getProductId()));\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;sku;\n9&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>接着就返回\"cart.jsp\", 这个就是购物车详情展示页面了.</p> \n <span id=\"OSC_h2_3\"></span> \n <h2><span style=\"color:#FF0000\"><strong>3、去结算页面</strong></span></h2> \n <p>到了这里就说明用户必须要 登录, 而且购物车中必须要有商品.</p> \n <p>所以这里我么你需要利用springmvc的过滤功能, 用户点击结算的时候必须要先登录, 如果没有登录的话就提示用户需要登录.</p> \n <pre><code class=\"language-java\">1&nbsp;//去结算\n2&nbsp;&nbsp; &nbsp;&nbsp;@RequestMapping(value=\"/buyer/trueBuy\")\n3&nbsp;&nbsp; &nbsp;&nbsp;public&nbsp;String&nbsp;trueBuy(String[] skuIds, Model model, HttpServletRequest request, HttpServletResponse response){\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//1, 购物车必须有商品,&nbsp;\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//取出用户名 &nbsp;再取出购物车\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;String&nbsp;username = sessionProviderService.getAttributterForUsername(RequestUtils.getCSessionId(request, response));\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//取出所有购物车\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; BuyerCart buyerCart = cartService.selectBuyerCartFromRedisBySkuIds(skuIds, username);\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; List&lt;BuyerItem&gt; items = buyerCart.getItems();\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(items.size() &gt;&nbsp;0) {\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//购物车中有商品\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//判断所勾选的商品是否都有货, 如果有一件无货, 那么就刷新页面.\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Boolean&nbsp;flag =&nbsp;true;\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//2, 购物车中商品必须有库存 且购买大于库存数量时视为无货. 提示: 购物车原页面不动. 有货改为无货, 加红提醒.\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(BuyerItem buyerItem : items) {\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//装满购物车的购物项, 当前购物项只有skuId这一个东西, 我们还需要购物项的数量去判断是否有货\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setSku(cartService.selectSkuById(buyerItem.getSku().getId()));\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//校验库存\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(buyerItem.getAmount() &gt; buyerItem.getSku().getStock()) {\n20&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//无货\n21&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setIsHave(false);\n22&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag =&nbsp;false;\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n24&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!flag) {\n25&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//无货, 原页面不动, 有货改成无货, 刷新页面.\n26&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; model.addAttribute(\"buyerCart\", buyerCart);\n27&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;\"cart\";\n28&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n29&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n30&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }else&nbsp;{\n31&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//购物车没有商品\n32&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//没有商品: 1&gt;原购物车页面刷新(购物车页面提示没有商品)\n33&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;\"redirect:/shopping/toCart\";\n34&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n35&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n36&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n37&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//3, 正常进入下一个页面\n38&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;\"order\";\n39&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>取出 所指定的购物车, 因为我们结算之前在购物车详情页面会勾选 我们 需要购买的商品, 所以这里是根据所勾选的商品去结算的.<br> BuyerCart buyerCart = cartService.selectBuyerCartFromRedisBySkuIds(skuIds, username);</p> \n <p>从购物车中取出指定商品:</p> \n <pre><code class=\"language-java\">1&nbsp;//从购物车中取出指定商品\n2&nbsp;&nbsp; &nbsp; public BuyerCart selectBuyerCartFromRedisBySkuIds(String[] skuIds,&nbsp;String&nbsp;username){\n3&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; BuyerCart buyerCart =&nbsp;new&nbsp;BuyerCart();\n4&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//获取所有商品, redis中保存的是skuId 为key , amount 为value的Map集合\n5&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Map&lt;String,&nbsp;String&gt; hgetAll = jedis.hgetAll(\"buyerCart:\"+username);\n6&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(null&nbsp;!= hgetAll &amp;&amp; hgetAll.size() &gt;&nbsp;0) {\n7&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Set&lt;Entry&lt;String,&nbsp;String&gt;&gt; entrySet = hgetAll.entrySet();\n8&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Entry&lt;String,&nbsp;String&gt; entry : entrySet) {\n9&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(String&nbsp;skuId : skuIds) {\n10&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(skuId.equals(entry.getKey())) {\n11&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//entry.getKey(): skuId\n12&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sku sku =&nbsp;new&nbsp;Sku();\n13&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sku.setId(Long.parseLong(entry.getKey()));\n14&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BuyerItem buyerItem =&nbsp;new&nbsp;BuyerItem();\n15&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setSku(sku);\n16&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//entry.getValue(): amount\n17&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerItem.setAmount(Integer.parseInt(entry.getValue()));\n18&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//添加到购物车中\n19&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buyerCart.addItem(buyerItem);\n20&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n21&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n22&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n23&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; }\n24&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n25&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;buyerCart;\n26&nbsp;&nbsp; &nbsp; }</code></pre> \n <p>1) 当我们购买的商品只要有一件是无货的状态, 那么刷新购物车详情页面, 回显无货的商品状态.&nbsp;</p> \n <p>2)当购物车中午商品时, 刷新当前页面.</p> \n <p>购物车就这么多东西, 可能有讲解不到或者错误的地方, 欢迎大家指出来.如果对你有帮助的话也请点个赞支持一下,谢谢~</p> \n <p>我有一个微信公众号，经常会分享一些Java技术相关的干货；如果你喜欢我的分享，可以用微信搜索“Java团长”或者“javatuanzhang”关注。</p> \n</div>',NULL,'2020-02-09 15:16:02',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226404589318799360',NULL,NULL,' 国内外人气UX/UI/PD设计社区推荐，纯干货  ','<div class=\"content\" id=\"articleContent\"> \n <p>对于很多人尤其新手而言，要把握最新的设计动态及发展趋势，似乎不是一件轻松的事情。如果你也像我一样是个设计小白，而且正在担心自己设计的作品是否符合客户需求、烦恼找不到设计解决方案、得不到有效的用户反馈，那么你可以看看这里推荐的UX/UI/PD设计社区及论坛，也许可以得到一些启发。</p> \n <p>&nbsp;1.<a href=\"https://dribbble.com/\" target=\"_blank\" rel=\"nofollow\">&nbsp;Dribbble</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143208659?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>Dribbble是国外一个很出名的社区以及社交网络平台，它致力于帮助设计师建立团队和品牌。你可以从它的首页捕捉到当下流行的设计作品，但不是任何人都可以发布在线作品的。这里有很多网页设计师、平面达人、插画画家、印刷师以及logo设计师等，可以分享和评论他们的设计作品。</p> \n <p>2.<a href=\"http://www.mockplus.cn/s\" target=\"_blank\" rel=\"nofollow\">&nbsp;Mockplus&nbsp;Community</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143225284?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>作为原型设计工具中的后起之秀，Mockplus现如今也开放了在线社区，帮助有需要的用户以及感兴趣的小伙伴分享他们的设计资源和想法。同时，官方会定期更新不同主题的设计模板，供小伙伴们参阅。如果积极贡献话题，或者帮助解答问题的话，还可以得积分哦，不信你试试？</p> \n <p>3.&nbsp;<a href=\"http://community.uxmastery.com/\" target=\"_blank\" rel=\"nofollow\">UX&nbsp;Mastery&nbsp;Community</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143240237?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>这个社区的主要人群为UX设计师，并帮助他们更好地改善自己的设计方式。在这里，你可以寻求同行的专业设计建议，或者通过导师来获得职业相关的建议。</p> \n <p>4.&nbsp;<a href=\"http://www.uxdesigncommunity.com/\" target=\"_blank\" rel=\"nofollow\">UX&nbsp;Design&nbsp;Community</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143257710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>UX&nbsp;Design&nbsp;Community现在已经有600个UX设计师，它倡导大家一起交流、共同成长，是一个比较有活力而且有亲和力的社区。但是，你需要先去它的网站注册得到邀请后，才能加入哦。</p> \n <p>5.&nbsp;<a href=\"http://ux.stackexchange.com/\" target=\"_blank\" rel=\"nofollow\">User&nbsp;Experience&nbsp;Stack&nbsp;Exchange</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143312304?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>这也是一个关于用户体验设计的社区，这里有UX设计师、信息<a href=\"http://lib.csdn.net/base/16\" target=\"_blank\" rel=\"nofollow\">架构</a>师和人机交互设计师等，允许任何人提问或者解答问题。值得注意的是，它是Stack&nbsp;Exchange网站Q&amp;A板块的一个小板块。所有这里的问题都会被标记成不同的主题，比如“可用性”、“网站设计”、“交互设计”、“用户行为”等。</p> \n <p>6.&nbsp;<a href=\"http://www.webdesignerforum.co.uk/\" target=\"_blank\" rel=\"nofollow\">Web&nbsp;Designer&nbsp;Forum</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143332925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>这是一个英国的设计师论坛，目前有超过3000个成员。如果你想要单独与英国的设计达人切磋、交流一下的话，那么你可以进来试试看，有很多内容板块也是值得探索的。</p> \n <p>7.&nbsp;<a href=\"http://www.graphicdesignforum.com/forum/index.php?\" target=\"_blank\" rel=\"nofollow\">Graphic&nbsp;Design&nbsp;Forum&nbsp;(GDF)</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143349597?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>GDF可以说是国外最早、最大的平面设计论坛之一。它现在已经有超过2万的成员了，规模大而且活跃。里面有很多板块，比如：网页设计资源、网站开发、网站营销与业务、软件/硬件等等。</p> \n <p>8.&nbsp;<a href=\"https://www.sitepoint.com/community/c/design-ux\" target=\"_blank\" rel=\"nofollow\">Sitepoint&nbsp;Forum</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143405712?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>Sitepoint也是一个比较大型的社区，迄今为止有超过25万个成员了。在这里，你可以找到编程技巧、商业建议等各类所需要的资源。具体而言，你可以找到关于PHP、HTML、<a href=\"http://lib.csdn.net/base/18\" target=\"_blank\" rel=\"nofollow\">JavaScript</a>、CSS、市场营销、<a href=\"http://lib.csdn.net/base/14\" target=\"_blank\" rel=\"nofollow\">数据库</a>、UX设计和网站托管等内容。</p> \n <p>9.&nbsp;<a href=\"https://www.designernews.co/\" target=\"_blank\" rel=\"nofollow\">Designer&nbsp;News</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143424472?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>它创建于2012年，是一个讨论和分享设计行业有趣讯息的社区。作为一个全球社区，Designer&nbsp;News主要是由从事设计和技术工作的人以及对这些主题感兴趣的人所组成。这里的所有人都可以通过“投票”的方式，来鉴定哪些是内容优质的分享。</p> \n <p>10.&nbsp;<a href=\"https://news.ycombinator.com/\" target=\"_blank\" rel=\"nofollow\">Hacker&nbsp;News</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143438378?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>Hacker&nbsp;News基本上是一个专注于创业和计算机科学的社交新闻网站。它有点类似于早期的Reddit网站，但不同的是，这个网站不允许用户投“踩”票。在这里，任何话题都可以被分享和讨论。</p> \n <p>11.&nbsp;<a href=\"http://www.howdesign.com/forum/\" target=\"_blank\" rel=\"nofollow\">How&nbsp;Design</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143451535?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>这也是国外的一个人气社区，几乎每个人都曾听说或者使用过。这里有很多分类，比如“新闻”、“设计业务”、“互动”、“设计职业”、“在线学习”、“竞争对手”等。这是与各类设计师交流、碰撞出灵感火花的地方。</p> \n <p>12.&nbsp;<a href=\"http://www.designerstalk.com/forums/\" target=\"_blank\" rel=\"nofollow\">Designers&nbsp;Talk&nbsp;Forum</a></p> \n <p><img alt=\"\" src=\"http://img.blog.csdn.net/20161109143505916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\"></p> \n <p>这是一个很活跃的论坛，界面保持着简洁的设计，有大部分内容是关于编码、网页设计等。同时，它也有涉及平面设计及网页设计方面，现在邮25,000名成员。</p> \n <p>结束语</p> \n <p>线上社区无疑是与他人分享和交流想法、作品的很好的地方，也可以促进个人创造力。除了上面提到的社区，你在网上还可以找到很多，如有推荐，请留言分享，谢谢。</p> \n</div>',NULL,'2020-02-09 15:16:54',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226405031314554880',NULL,NULL,' UX的设计灵感从哪里来？——看看Megan Wilson的采访  ','<div class=\"content\" id=\"articleContent\"> \n <p><a href=\"http://ux.walkme.com/author/megan-wilson/\" target=\"_blank\" rel=\"nofollow\">Megan Wilson</a>是一位资深的用户体验师和UX Motel的专业编辑。同时她是ux.walkme.com网站UX专栏作家，在Facebook、领英有大量粉丝。和一般介绍性的文章不同，她喜欢用访谈的方式来发表UX方面的文章，这样的文章，有很好的现场感和可读性。这里，让我们来看看Megan Wilson关于UX设计灵感的访谈实录。</p> \n <p><strong>访谈对象：</strong><strong>Rita Feldman</strong></p> \n <p>文章：数码领域中的人类设计规则</p> \n <p>原文：<a href=\"http://ux.walkme.com/rules-human-design-digital-world-rita-feldman/\" target=\"_blank\" rel=\"nofollow\">http://ux.walkme.com/rules-human-design-digital-world-rita-feldman/</a></p> \n <p><img alt=\"\" height=\"268\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/45d40659-dd84-4eb5-9229-1590b2ccbf69.png\" width=\"260\"></p> \n <p><a href=\"http://ux.walkme.com/author/megan-wilson/\" rel=\"nofollow\">Megan Wilson</a>： 首先，我很高兴在能够在本次访谈中和一位非常优秀的UX设计师 – Rita Feldman进行一对一的采访。Rita主要专注于网页和视觉设计，以及前端Web开发。在自由设计方面，Rita具有丰富的经验，并且她对于创意以及细节拥有着超乎寻常的热情。</p> \n <p><strong>问：“请问Rita，你通常是如何寻找设计以及创新的灵感？”</strong></p> \n <p>答：“我目前订阅了几十个关于设计的优秀博客，并且坚持对他们更新的文章保持持续的关注。如果在时间和财务条件允许的情况下，我会尽可能多地参与到一些关于设计的会议或者讨论中去。我感谢在这个过程中进行经验分享的所有人，不论是成功或者失败，从他们那里我都能得到极大的灵感启发。</p> \n <p>最近我新增的一个爱好是探索新的移动应用程序，并评估每一个应用程序的设计和可用性。在这些程序的设计上，我们可以列举出成千上万的建议，方法或者趋势的见解，但是从设计层面来讲，最重要的是如何让用户使用你的软件时不会“迷路”。</p> \n <p>另外，我也通过寻找时尚界的设计和数字设计之间的类似之处来获得灵感。它们的相似之处在于都要时刻追寻最新的流行趋势，并且进行持续的转变。例如chanel.com，prada.com和dior.com这些流行品牌网站给我们提供了一个很好的例子—设计是如何从传统上延续至今，以及设计如何变成有选择性的使用最新的趋势。”</p> \n <p><strong>访谈对象：</strong><strong>Song Lau</strong></p> \n <p>文章：UX设计基础指导—来自Mockplus CEO老布</p> \n <p>原文：<a href=\"http://ux.walkme.com/essential-ux-design-tips-mockpluss-ceo-song-lau/\" rel=\"nofollow\">http://ux.walkme.com/essential-ux-design-tips-mockpluss-ceo-song-lau/</a></p> \n <p><img alt=\"\" height=\"260\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/86817b26-8de3-487b-9526-f8dd9a83014a.png\" width=\"260\"></p> \n <p>在UX设计领域，成为一个优秀的设计师需要足够的天赋以及许多重要的能力。我很有幸能够和Mockplus的创始人兼产品经理—老布，来一起探讨如何做好UX设计的关键因素。</p> \n <p>我很好奇，并希望了解这位原型设计专家—老布，是如何利用他丰富的设计知识和技能来帮助和带领公司走向成功。Mockplus是一家专注于原型设计工具研发的创业公司，他们主要为用户体验设计师，平面设计师，产品经理以及程序员而服务。他们的目标是提供物美价廉的更快、更简单的原型设计工具。</p> \n <p>我在和其他设计师进行交流的时候，大家谈到最多的就是关于创意，以及如何获取灵感。在这一点上，老布有着他独特的见解。当然，对于每个用户体验的设计师，创意的重要性无需多讲。这使得我对于独特见解格外期待。老布在本次采访的内容中分享了他的一些独特见解，以下是部分内容:</p> \n <p>“真的没有“灵感”这个东西，我也从不相信这个，我不相信在一个太阳很好的下午，你喝着一杯咖啡，灵感就来了。我的方式，就是反复地不厌其烦地去思考，穷尽所有的办法。这个过程中，我一般不太愿意和别人讨论，也更不喜欢去看别人怎么做的——这两个事情，往往可能是在我得到某个“灵感”之后或者之前。此外，如果要有好点子的产生，我觉得一定要求这个人不是线性思维的，而是发散的、多维思维的，而要具有多维的思维，和你平常的多方面的知识积累很有关系，这种多方面的知识，往往还是相互“不沾边”的，比如：艺术+技术，文学+开发，音乐+编程。当然，这些知识其实是有高度统一性的，这点，之后有机会再说。”</p> \n <p>&nbsp;</p> \n <p><strong>访谈对象：</strong><strong>Kai ByRoade</strong></p> \n <p>文章：走进Kai ByRoade的创意设计工作室</p> \n <p>原文：<a href=\"http://ux.walkme.com/step-kai-byroades-creative-design-studio/\" rel=\"nofollow\">http://ux.walkme.com/step-kai-byroades-creative-design-studio/</a></p> \n <p><img alt=\"\" height=\"260\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/dfc566d5-5812-4eda-b483-12bc5a155b33.png\" width=\"260\"></p> \n <p>我遇到过许多从事用户体验设计师这个职业的人，但是在独特创意上，他们中没有一个人能够比Kai ByRoade给我留下的印象深刻。Kai ByRoade作为一个产品的UI、UX设计师，以及前端开发，她拥有超过10年的经验，并且开发了大量创造性的智慧分享。</p> \n <p>要真正做到以用户为中心的设计必须拥有丰富的设计经验和技能，Kai ByRoade是其中的佼佼者。我很有幸能够采访到她，并且希望能够从采访中了解究竟是什么带给了她设计出独特的作品的灵感，同时讨论当前的设计字体，并获得一点灵感。</p> \n <p><strong>问：“究竟是什么为你的工作带来灵感？你采取哪些措施来保持动力？”&nbsp;</strong></p> \n <p>“我的灵感大部分来源于休憩时间，制作在线体验的最好的灵感是来自现实世界的经验。我会骑摩托车到新的地方，从每一个微时刻中学习。围绕你的房间快速转一圈， 去公园散散步，或者去书店沉下心来细读，都会教你一些东西。密切关注你从中的体验，以及有助于创造更好体验的一些因素。这里面的艺术哪些又能够复用到你的 产品体验设计中去呢？面对一个全页目录广告，你会看到的又是什么呢？一张醒目的背景图片加具吸引注意力的文字，就会让你注意到该条信息。</p> \n <p>你应该在网页、英雄风格（指运用大标题且与内容直接相关的超大背景图设计风格）及封面的形式中，也意识到这种设计模式。我们可以推测这就是为什么苹果公司将不同的拟物概念融入他们产品的原因。这样，人们就可以成功地与他们所知道的东西进行交互，而不必再学习新的操作行为了。所以我们的日常经验是创建在线体验的基础。”</p> \n</div>',NULL,'2020-02-09 15:18:40',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226405253423923200',NULL,NULL,' “手把手教你设计”—12个最佳手机APP界面设计教程  ','<div class=\"content\" id=\"articleContent\"> \n <p>UI/UX 设计确实是需要一定的经验和学识才能真正在这个行业立足，并不是所有想成为设计师的人最后都能如愿以偿。他需要对设计有基本的了解，清楚设计的基本原则。</p> \n <p>用户界面设计师和其他行业设计面临一样的挑战，那就是用户是怎么想他们产品的，是否功能易用？是否美观让人愉悦？所以，我们可以看出UI设计是关于平衡可用性和可视化的。</p> \n <p>这篇文章集合了12个最佳手机用户界面设计的教程，虽然教程偏向初学者，但我相信即使是很优秀的设计师仍然可以从中学到新的东西。</p> \n <p><strong>如何使用Photoshop来设计手机UI界面</strong></p> \n <p>1.&nbsp;<a href=\"http://davidmckinney.com/blog/2013/12/31/designing-iphone-apps-how-to-setup-photoshop\" target=\"_blank\" rel=\"nofollow\">How To Set Up Photoshop For UI Design</a></p> \n <p>如果你是Photoshop的新手，又在做UI设计，这个教程教你如何使用常用的Photoshop设置来达到更好的效果。本文是以iPhone为实例告诉你怎么在UI设计中使用Photoshop，完全是初学者的教程。</p> \n <p><img alt=\"\" height=\"636\" src=\"https://static.oschina.net/uploads/space/2018/0327/104454_HWb1_3519468.jpg\" width=\"960\">&nbsp;</p> \n <p>2.&nbsp;<a href=\"https://medialoot.com/blog/how-to-design-an-iphone-app-in-photoshop/\" target=\"_blank\" rel=\"nofollow\">How to Design an iPhone App in Photoshop</a></p> \n <p>这篇文章将为我们介绍使用Adobe Photoshop为iPhone设计一个简单的3页目录列表应用程序。并且将一步步地指导你完成这些步骤，还涵盖了使用Photoshop设计iPhone应用程序的所有基本原则。</p> \n <p><img alt=\"\" height=\"683\" src=\"https://static.oschina.net/uploads/space/2018/0327/104503_nUhY_3519468.png\" width=\"610\"></p> \n <p>3.&nbsp;<a href=\"https://webdesign.tutsplus.com/tutorials/design-an-app-landing-page-in-photoshop--cms-23716\" target=\"_blank\" rel=\"nofollow\">Design an App Landing Page in Photoshop</a></p> \n <p>在这个教程中，我们可以看到一个应用程序着陆页的详细设计过程。设计师使用Tuts + Android应用程序进行演示，强调其功能和优势，利用多个CTA来完善整个着陆页的设计。</p> \n <p><img alt=\"\" height=\"449\" src=\"https://static.oschina.net/uploads/space/2018/0327/104511_oYwc_3519468.jpg\" width=\"600\"></p> \n <span id=\"OSC_h1_1\"></span> \n <h1>4.&nbsp;<a href=\"https://www.youtube.com/watch?v=XhFUqdO0jz8\" target=\"_blank\" rel=\"nofollow\">How To Design a Mobile App Signup Screen in Adobe Photoshop</a></h1> \n <p>如果你想要设计一个像Facebook或者Instagram这样成功的登录界面设计，那么这个完全是你必看的基础教程，视频中教你如何选择颜色，设计按钮以及详细的步骤来展示登录界面的设计过程。视频虽然是四年前的，但是里面的设计依旧不过时。</p> \n <p>&nbsp;<img alt=\"\" height=\"396\" src=\"https://static.oschina.net/uploads/space/2018/0327/104520_fDsn_3519468.png\" width=\"824\"></p> \n <span id=\"OSC_h2_2\"></span> \n <h2><strong>如何使用Sketch来设计手机UI界面</strong></h2> \n <p>1.&nbsp;<a href=\"https://medium.com/ux-power-tools/a-step-by-step-guide-for-starting-a-new-app-design-project-in-sketch-469df0f24af8\" target=\"_blank\" rel=\"nofollow\">A Step-by-Step GUIde for Starting a New App Design Project in&nbsp;Sketch</a></p> \n <p>开始一个新的设计项目是很难的，无论你是自由设计师，还是在知名的产品公司工作，时常会感到迷茫。本文将一步步的教你如何使用Sketch开始一项新的APP设计项目。</p> \n <p><img alt=\"\" height=\"547\" src=\"https://static.oschina.net/uploads/space/2018/0327/104528_H5qh_3519468.gif\" width=\"960\"></p> \n <p>2.&nbsp;<a href=\"https://www.youtube.com/watch?v=CxQvB3Yq2gs\" target=\"_blank\" rel=\"nofollow\">Food App&nbsp;UI&nbsp;•&nbsp;Sketchapp Tutorial /&nbsp;Sketch&nbsp;4 Tutorial</a></p> \n <p>视频主要是介绍如何使用Sketch制作一个美食类APP 菜单栏UI设计，简单易懂。</p> \n <p><img alt=\"\" height=\"478\" src=\"https://static.oschina.net/uploads/space/2018/0327/104536_yIMH_3519468.jpg\" width=\"852\"></p> \n <p>3.&nbsp;<a href=\"https://www.youtube.com/watch?v=6SyFaRNVuUA\" target=\"_blank\" rel=\"nofollow\">Sketch&nbsp;3 for&nbsp;iOS&nbsp;App Design Step by Step</a></p> \n <p>Sketch&nbsp;3是一款优秀的矢量设计和图形程序，很适合用于设计iOS应用程序。在这个视频中，设计师使用Sketch&nbsp;3来设计一个iPhone&nbsp;APP用户界面。<a href=\"https://www.smashingmagazine.com/2017/11/designing-app-idea-sketch-xcode/\" target=\"_blank\" rel=\"nofollow\">From Idea To Reality: Designing An App With&nbsp;Sketch&nbsp;And Xcode</a><strong>&nbsp;</strong>这篇文章是进阶版的APP 设计教程，从理论到具体的例子讲解，非常受益。</p> \n <p><img alt=\"\" height=\"485\" src=\"https://static.oschina.net/uploads/space/2018/0327/104546_UQQY_3519468.png\" width=\"855\"></p> \n <span id=\"OSC_h1_3\"></span> \n <h1>4.&nbsp;<a href=\"https://www.youtube.com/watch?v=nSy1OcE5-Vk\" target=\"_blank\" rel=\"nofollow\">Sketch&nbsp;App Tutorial – Build a music app landing page in&nbsp;Sketch</a></h1> \n <p>Sketch 作为当下主流的设计工具，似乎有超越Photoshop的趋势。本视频介绍的是如何使用Sketch来制作一个音乐APP登录页设计，可以说是手把手的教程，每一步都非常的详细细致，非常适合初学者。</p> \n <p><img alt=\"\" height=\"478\" src=\"https://static.oschina.net/uploads/space/2018/0327/104554_uk1Y_3519468.png\" width=\"855\"></p> \n <p>看了前面的音乐类APP登录界面的教程， 你是否也想设计出一个属于自己的音乐APP呢？接下来我将介绍如何通过结合Sketch和原型设计工具设计一款音乐类的APP（Prototype an music app with prototyping tool）</p> \n <span id=\"OSC_h1_4\"></span> \n <h1><a href=\"https://run.mockplus.cn/aydDd/index.html\" target=\"_blank\" rel=\"nofollow\">TIMING</a></h1> \n <p>这款原型音乐类的APP在<a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\"><em><strong>Mockplus</strong></em></a>设计大赛中斩获头筹，设计师通过采用Sketch以及Mockplus的结合，做出了高保真原型。这个APP主要体现一种复古的视觉效果，磁带转动的效果是这次视觉上的设计重点。</p> \n <p>&nbsp;<img alt=\"\" height=\"538\" src=\"https://static.oschina.net/uploads/space/2018/0327/104603_Y2O9_3519468.jpg\" width=\"907\"></p> \n <span id=\"OSC_h2_5\"></span> \n <h2><strong>必读的手机界面UI设计好文</strong></h2> \n <span id=\"OSC_h1_6\"></span> \n <h1>1.&nbsp;<a href=\"https://www.creativebloq.com/mobile/10-principles-mobile-interface-design-4122910\" target=\"_blank\" rel=\"nofollow\">The 10 principles of mobile interface design</a></h1> \n <p>计算机和手机是人们日常工作和生活必备的通讯工具。但在许多方面，手机往往更加强大，手机更加的私人化，与我们的联系更紧密。鉴于移动手机和计算设备之间的许多差异，移动设计与桌面设计的设计大不相同。这篇文章详细的向我们介绍了移动界面设计的基本原则，帮助设计师们开发移动应用程序的独特力量。</p> \n <p>2.&nbsp;<a href=\"https://developer.apple.com/design/tips/\" target=\"_blank\" rel=\"nofollow\">UI&nbsp;Design Do’s and&nbsp;Don’ts</a></p> \n <p>iOS良好的优化了用户面设计，并提供给用户优质且具有吸引力的用户体验。在开始你的iOS设计之前，一定要清楚Apple官网的关于iOS常见的设计原则，来在增强手机应用的可用性和吸引力。更多关于优秀的iOS界面设计，请阅读<a href=\"https://developer.apple.com/ios/human-interface-guidelines/overview/themes/\" target=\"_blank\" rel=\"nofollow\">iOS人机界面指南</a>。&nbsp;</p> \n <span id=\"OSC_h1_7\"></span> \n <h1>3.&nbsp;<a href=\"https://blog.prototypr.io/how-to-use-colors-in-ui-design-16406ec06753\" target=\"_blank\" rel=\"nofollow\">How to use colors in&nbsp;UI&nbsp;Design</a></h1> \n <p>颜色可以说在UI设计中至关重要。用的好，那就成功了一半，用不好，可能导致整个应用失败。在你的配色方案中，最好只使用三种主色跳，使用的颜色越多。越难实现平衡。这篇文章不但提到基础的用色知识加上实例解释，还有常用的工具介绍。</p> \n <p><img alt=\"\" height=\"560\" src=\"https://static.oschina.net/uploads/space/2018/0327/104612_8nVr_3519468.png\" width=\"960\"></p> \n <span id=\"OSC_h1_8\"></span> \n <h1>4.&nbsp;<a href=\"https://www.mockplus.com/blog/post/best-app-ui-design\" target=\"_blank\" rel=\"nofollow\">10 Best APP&nbsp;UI&nbsp;Design for Your Inspiration</a></h1> \n <p>每位UI设计师都梦想着做出最出色的界面（UI）设计，&nbsp;能够脱颖而出的手机界面设计则少之又少。设计师们在设计UI界面时，往往会参考来自不同设计师的设计，这篇文章列出了2017年最出色的的10个手机应用界面设计范例，给设计师们谋福利。</p> \n <p>&nbsp;<img alt=\"\" height=\"600\" src=\"https://static.oschina.net/uploads/space/2018/0327/104630_blZ9_3519468.gif\" width=\"800\"></p> \n <p>总结</p> \n <p>移动设计不断地在发展，如果你想跟上这个时代，你需要不断阅读和观看高质量的教程或文章。在本文中，我收集12个最佳教程的示例来教初学者如何学习手机UI界面设计，希望你们能从中受益。</p> \n</div>',NULL,'2020-02-09 15:19:33',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226405476267294720',NULL,NULL,' 阿里云飞天技术汇之“阿里云在线直播技术与应用分享”主题沙龙  ','<div class=\"content\" id=\"articleContent\"> \n <p>1月19日下午14:00，由阿里云生态技术联盟成员——云顶云主办，阿里云协办的“阿里云在线直播技术与应用分享”主题沙龙在北京海淀区众海加速器成功举办。</p> \n <p>本次沙龙活动邀请了2位阿里云技术专家与1位阿里云MVP到现场分享在线直播技术，干货满满！来自国内几十多家企业代表参加了本次活动，同时感谢云栖Techday、大咖说、阿里云合作伙伴赋能平台的大力支持，活动现场阿里云专家跟大家一起进行分享、交流、探讨。</p> \n <p>本次沙龙北京作为主会场，天津作为分会场，同时云顶云官网、云栖社区、大咖说三方同步在线直播，线上直播同时观看人数高达2000+。</p> \n <p>下面我们一起来看一下当天的火爆现场。</p> \n <p>（一）北京主会场现场</p> \n <p><img alt=\"b3c66f5111282d406fe4373003cfba556aee3313\" src=\"https://yqfile.alicdn.com/b3c66f5111282d406fe4373003cfba556aee3313.jpeg\"></p> \n <p>大家都在认真倾听嘉宾分享</p> \n <p><img alt=\"fb117d9ce85c54bd9131169704e7e0ca307f34df\" src=\"https://yqfile.alicdn.com/fb117d9ce85c54bd9131169704e7e0ca307f34df.jpeg\"></p> \n <p>嘉宾主题演讲<br> <img alt=\"95812618c5596fe474cae38db567e5eaffdc1a8f\" src=\"https://yqfile.alicdn.com/95812618c5596fe474cae38db567e5eaffdc1a8f.jpeg\"></p> \n <p>阿里云专家现场一对一答疑</p> \n <p>（二）天津分会场（同步直播）</p> \n <p><img alt=\"b2f9d96917ced1bc4740f0eb2ee49b801e05c993\" src=\"https://yqfile.alicdn.com/b2f9d96917ced1bc4740f0eb2ee49b801e05c993.jpeg\"></p> \n <p><img alt=\"0af8475e9a8f43a6c1a6d75e510cfdcb62ae912e\" src=\"https://yqfile.alicdn.com/0af8475e9a8f43a6c1a6d75e510cfdcb62ae912e.jpeg\"></p> \n <p>&nbsp;</p> \n <p>（三）嘉宾分享&nbsp;&nbsp;干货满满</p> \n <p>快速搭建移动直播系统&nbsp;&nbsp;主讲人：阿里云资深产品经理&nbsp;&nbsp;弦望</p> \n <p>弦望老师深入浅出的为大家介绍了如何搭建移动直播平台，同时也分享了时下火热的在线直播答题的架构搭建以及如何设置推流sdk，干货满满!</p> \n <p><img alt=\"1cc9aacc23029d480393c5f3f8b1537c1a5432b1\" src=\"https://yqfile.alicdn.com/1cc9aacc23029d480393c5f3f8b1537c1a5432b1.jpeg\"></p> \n <p>阿里云资深产品经理&nbsp;&nbsp;弦望</p> \n <p><img alt=\"1a52f92f2a3b9133c90fbaeef52f9c5d6afef019\" height=\"436\" src=\"https://yqfile.alicdn.com/1a52f92f2a3b9133c90fbaeef52f9c5d6afef019.png\" width=\"800\"></p> \n <p>弦望老师分享阿里云直播技术架构</p> \n <p><img alt=\"88048af2a09bab08284e8f4c05f4699113564adb\" height=\"440\" src=\"https://yqfile.alicdn.com/88048af2a09bab08284e8f4c05f4699113564adb.png\" width=\"800\"></p> \n <p>弦望老师分享直播答题架构</p> \n <p>无延时P2P在互动直播中的应用&nbsp;&nbsp;主讲人：阿里云技术专家&nbsp;&nbsp;蒲世海</p> \n <p>蒲老师是阿里云边缘计算团队技术专家，主要负责PCDN产品的业务研发以及技术支持，对于无延时直播有着非常深的造诣，本次沙龙蒲老师为大家分享的是P2P无延时在直播的架构。</p> \n <p><img alt=\"e9ca7f18c3c3ae220182bddeaf4eb194850793ed\" src=\"https://yqfile.alicdn.com/e9ca7f18c3c3ae220182bddeaf4eb194850793ed.jpeg\"></p> \n <p>阿里云技术专家&nbsp;&nbsp;蒲世海</p> \n <p><img alt=\"a4f54c8102d04a31a2006a5c8e8461d2b35ce021\" height=\"437\" src=\"https://yqfile.alicdn.com/a4f54c8102d04a31a2006a5c8e8461d2b35ce021.png\" width=\"800\"></p> \n <p>蒲老师分享无延时直播架构方案</p> \n <p>阿里云直播系统的导播平台应用分享&nbsp;主讲人：阿里云MVP&nbsp;云顶云创始人&amp;CEO&nbsp;行云</p> \n <p>行云，云顶云创始人&amp;CEO，阿里云MVP，阿里云大学首位授权认证讲师，擅长领域：云解决方案、云安全等，行云老师多年的教学经验，本次沙龙为大家分享的是阿里云在线直播中导播平台的实例分享，此环节正是本场沙龙中大家最为关心的重点，通过行云老师的分享，让大家对直播系统中的导播平台有了更深层的了解。</p> \n <p><img alt=\"c5061b05ff657f60a0016f25e64065ea3cc285fa\" src=\"https://yqfile.alicdn.com/c5061b05ff657f60a0016f25e64065ea3cc285fa.jpeg\"></p> \n <p>&nbsp;</p> \n <p>阿里云MVP&nbsp;云顶云创始人&amp;CEO&nbsp;行云</p> \n <p><img alt=\"e09cbba11ac78dd3d622f85c8f58b56993338797\" height=\"449\" src=\"https://yqfile.alicdn.com/e09cbba11ac78dd3d622f85c8f58b56993338797.png\" width=\"800\"></p> \n <p>行云老师介绍导播台作用</p> \n <p><img alt=\"95812618c5596fe474cae38db567e5eaffdc1a8f\" src=\"https://yqfile.alicdn.com/95812618c5596fe474cae38db567e5eaffdc1a8f.jpeg\"></p> \n <p>行云老师介绍云导播平台</p> \n <p>（四）结束语</p> \n <p>感谢3位专家的精彩演讲，本次沙龙的火爆现场也从侧面反映了阿里云直播技术超高的关注度，以及中国各行各业对在线直播浓厚兴趣。</p> \n <p>阿里云生态联盟会以“飞天技术汇”沙龙和社区为载体，联动用户、合作伙伴和阿里云专家，建立技术交流平台九大生态技术先锋，立足全国六大城市，云顶云作为其中一家覆盖华北地区，以后我们会将自身的能力来输出，给更多对阿里云的产品和技术感兴趣的人赋能与支持，大家一起成长。</p> \n <p>阅读原文</p> \n <p><a href=\"http://click.aliyun.com/m/40937/\" target=\"_blank\" rel=\"nofollow\">http://click.aliyun.com/m/40937/</a></p> \n</div>',NULL,'2020-02-09 15:20:26',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226405699874029568',NULL,NULL,' 10个最新手机美食APP界面设计欣赏  ','<div class=\"content\" id=\"articleContent\"> \n <p><img alt=\"\" height=\"510\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=1&amp;sec=1439619614&amp;autorotate=1&amp;di=c79cdd21d05768ae5f79fa3184bd334a&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F1dc018254ed67383ad0fc9e11b4bc6bd.jpeg\" width=\"870\"></p> \n <p>移动软件时代，简单下载美食app，动动手指，滑动几下手机屏幕，即可足不出户，搜索，预定和购买各路美食。然而，对于作为手机app UI 界面设计师的你来说，最大的问题并不在于如何使用这些美食软件来方便生活，而是在于如何才能为各类餐厅，酒店，咖啡馆，水果以及饮料店设计出美观，舒适且简单易用的手机美食App，对吧？但是，已然为正在做的美食App UI设计方案冥思苦想数小时或数天，却任然毫无头绪？究竟如何才能获得灵感设计出让人眼前一亮的美食App呢?</p> \n <p>以下为大家介绍10个最新优质美食app UI 界面设计实例，希望能帮助你把握美食软件设计的特点和趋势的同时，获得灵感：</p> \n <p>1.NomNom</p> \n <p>NomNom是一款由澳大利亚设计师Marc-Antoine Roy设计的一款专业美观的菜谱软件。 界面漂亮整洁，时尚舒适。为吸引更多的美食爱好者使用此款软件，设计师添加了很多实用且拥有一定互动性的软件界面元素，以方便美食爱好者们自由搜寻，预览和学习所需菜谱，收藏和分享各类可口美食/食谱。</p> \n <p>例如，设计师贴心的给软件的每页导航栏都添加了搜索功能，方便软件用户随时随地简单快捷的搜索新菜谱，尝试制作各类美食。而且，其简单整洁的界面设计，易于用户更加方便的查看和预览各式菜谱材料，制作步骤和流程，简单易懂，直观清晰。</p> \n <p>此外，设计师为方便各类设计师，产品经理或客户更深层次地了解此款软件的特点和价值，还在其Behance介绍页面展示了软件原型图，这也成为设计师了解和学习这类美食软件界面设计的重要资料。</p> \n <p>总之，如果你是刚刚才涉足美食软件界面设计这一块的设计师，这款标准且典型的食谱软件，会是你了解这类软件UI设计相关特点，找寻灵感的不错范例。</p> \n <p><img alt=\"\" height=\"618\" src=\"http://pic.rmb.bdstatic.com/cd01fe4491fa3a937fc876ebd2f6fa26.gif\" width=\"600\"></p> \n <p>2.Kitchen Stories</p> \n <p>Kitchen Stories是一款实用且舒适的手机食谱软件。其界面利用网格模式，展示了许多制作精美且可口的美食，方便烹饪爱好者们简单地浏览这些推荐菜式，找寻到到他们喜爱的美食。当然，如果用户不想尝试推荐的各种菜式，也可直接打开软件设置的独立的搜索页面， 输入关键词或点击展示的菜品分类搜寻到心仪的美食/菜谱。</p> \n <p>而且，除了通过展示各种制作精美的图片吸引用户使用和搜索美食/食谱，设计师还特别添加了视频展示模块，方便美食爱好者们更加简单直观的学习和制作美食。</p> \n <p>总之，如果你刚巧也是希望设计一款实用且舒适的美食app, 你也可以尝试使用该款软件所使用的设计方式，例如直接添加独立的搜索页面，拓展搜索功能。或者直接添加美食制作的视频或音频模块，更加简易直观的展示各类美食。</p> \n <p><img alt=\"\" height=\"930\" src=\"http://pic.rmb.bdstatic.com/5ef680352f30d437584366887aa659c6.gif\" width=\"700\"></p> \n <p>3.Food Parlour</p> \n <p>Food Parlour是一款专为咖啡餐厅定制的特色手机美食软件。界面现代时尚，流畅易用。作为一款专业的餐厅在线美食App，除了具有一般美食app的特点，例如强大的搜索功能，精美的美食图片以及详尽的菜式/菜谱细节介绍等，该软件还结合餐厅特色服务，添加了其它对应功能，以吸引更多用户，提升餐厅营业额，比如在线预约，在线定位，菜单折扣详情，以及早餐/午餐/晚餐菜式推荐等。</p> \n <p>此外，其响应式界面设计，方便用户/客户使用各类移动设备简单快捷定制各式美食。</p> \n <p>其大气时尚的配色方案也是很值得效仿。</p> \n <p>总之，当你也需要为类似的餐厅，咖啡厅，水果店或酒店定制在线手机美食App时，不要忘记在其UI 设计中融入其行业特色，营业需求以及其本身的企业文化，风格或特色等因素，增加其独特性。</p> \n <p><img alt=\"\" height=\"486\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=0&amp;sec=1439619614&amp;autorotate=1&amp;di=1c4f976959f15913d69f6a8553c59711&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2Fb36863fd466c65a7a7940ac99f3e55d1.png\" width=\"870\"></p> \n <p>4.Weekend Dish</p> \n <p>Weekend Dish是一款界面整洁干净的实用型订餐软件。用户可以简单点击即可轻松在线定制各类套餐，咖啡，饮料以及甜品等美食。这款手机美食App最大的亮点在于主界面上点击即会弹出的环形导航设计。其每一环都根据点餐需求添加了各项参数，简单转动导航，用户就可轻松选择所需餐点，价格以及份量等，直观有趣。</p> \n <p>而且，其纯白色背景加餐点图片的搭配方式，简单整洁，易于用户更多的专注于软件本身所展示和推荐的美食，提升软件实用性。</p> \n <p>所以，在你的美食App界面设计方案中，也可适当的设计和添加一些类似该软件环形导航一类的特别元素，增加软件趣味性的同时，也能提升用户愉悦体验。</p> \n <p><img alt=\"\" height=\"600\" src=\"http://pic.rmb.bdstatic.com/3eeff9112b2c372b1007eedbb31437a8.gif\" width=\"800\"></p> \n <p>5.Tasty Burger App</p> \n <p>Tasty Burger App是一款时尚美观的汉堡订购软件。其简单文字说明加高清诱人汉堡图片的界面设计，方便用户根据各自需求订购各类传统或定制汉堡。其时尚的黑，白，黄的配色方案，与展示的汉堡图片相呼应的同时，也使整个软件主题突出，美观舒适。</p> \n <p>总之，在设计你的美食App时，也可以在其配色上多下功夫，使整个软件美观整洁，突出软件主题。</p> \n <p><img alt=\"\" height=\"396\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=0&amp;sec=1439619614&amp;autorotate=1&amp;di=b5c456e309637fec6369b3ec040a8376&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2Fb48fbeecd1a2ccae350573d88a3f6699.png\" width=\"870\"></p> \n <p>6.Healthy Food App</p> \n <p>Healthy Food App, 顾名思义，就是一款介绍和分享健康美食和食谱的手机App。同时，它也是一款以用户为中心的信息类美食软件。 其界面设计中添加的各类图形元素和相对应的配色方案，以非常直观且极具视觉效果的方式展示了各种健康菜式以及食谱，极具吸引力。</p> \n <p>而且，其响应式设计，也方便有兴趣的用户在不同的移动设备上轻松地下载和使用。</p> \n <p>此外，其界面之间添加的灵活且流畅的滑动设计，也能极大的提升用户体验。</p> \n <p>然而，就我而言，对于这款软件界面的欣赏和学习中，更多的关注的是其极具特色的主题选择。当今社会，快餐和垃圾食品随处可见，如何才能吃得更好，更健康，成为人们普遍关注的问题，而这款软件敏锐的抓住了用户的这一需求，选择了健康食品这一主题，是极具特色的。</p> \n <p>因此，在你的美食软件设计中，也可分析和把握不同需求和潮流，选择一个新颖且符合用户需求的主题，就已然成功了一半。</p> \n <p><img alt=\"\" height=\"600\" src=\"http://pic.rmb.bdstatic.com/f6aaa73ba6574d0844765c4be00c6f2a.gif\" width=\"800\"></p> \n <p>7.iOS App Food Menu</p> \n <p>严格来说，iOS App Food Menu并不是一款完整的美食App. 它只是设计师对于iOS移动端美食App菜单页面的界面和交互相关设计的展示。但也很有特色，值得大家学习。</p> \n <p>首先，其采用了一种特别醒目的标签式设计展示各类美食。然后每个主标签又使用手风琴式的设计，展开所包含的各类具体菜式，进一步点击即可了解菜式价格，配料，用户评论等相关详情，醒目直观，逻辑清晰流畅。</p> \n <p>而且，其快速敏锐的转化设计也极具特色。</p> \n <p>总之，在完成你的UI设计时，也可添加类似直观醒目的标签，树状或线性设计，更加炫酷的展示各类美食。 当然，添加灵活的转化和交互以及清晰流畅的逻辑，也能为你的UI 设计加分。</p> \n <p><img alt=\"\" height=\"809\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=0&amp;sec=1439619614&amp;autorotate=1&amp;di=fa745891112dea93229be078ae31723d&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F725dd857b4445f6d6bcba36eff1cc629.png\" width=\"373\"></p> \n <p>8.Box8 Food Ordering &amp; Delivery App</p> \n <p>Box8 Food Ordering &amp; Delivery App是一款由17Seven工作室设计的订餐软件。其界面利用各种网格设计将软件呈现得更美观的同时，还巧妙的使用侧边菜单栏设计，突出主页美食，也方便用户简单点击，跳转到其他页面。</p> \n <p>而且，其Behance介绍页面也展示了详细的原型图和UI流程图，非常实用。</p> \n <p>因此，在你的UI设计中，也可尝试使用侧边栏菜单设计，使界面风格多样的同时，也能更加集中的展示软件主打美食。</p> \n <p><img alt=\"\" height=\"515\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=1&amp;sec=1439619614&amp;autorotate=1&amp;di=cb8b11d67757cd0157a45b4bba63deb6&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F29e9adaebf3c5fb4d9ba20efb653bb49.jpeg\" width=\"870\"></p> \n <p>9.Morning Baker</p> \n <p>Morning Baker是一款简洁且充满文艺范的手机软件。用户可以轻松搜索各类早餐食谱，尝试自己在家烘焙面包， 制作西式早餐。软件采用了高清全屏大图配上部分简短文字介绍的方式，更加直观的展示餐点制作流程，所需工具以及材料。所以，它更适合一些将早餐作为艺术在“创作”的烹饪爱好者们。</p> \n <p>而在你的设计中，也可以学习这款软件的特色，选择一个特殊的切入点，例如特别的受众亦或是主题，来展示你的设计理念和想法。</p> \n <p><img alt=\"\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=0&amp;sec=1439619614&amp;autorotate=1&amp;di=af1f1b56e5202d1a52949f8fe44d4180&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2F5978b5d0ed4d732ade196f383130f238.png\"></p> \n <p>10.D-Drink App</p> \n <p>D-Drink App是一款简洁时尚的饮料订购软件。其界面采用粉色背景搭配各式白色图片与文字的方式，简单直观又不失时尚。而且，其极具人性化设计的加载页面，即粉色背景加各种诱人水果图片的设计，有效地转移用户注意力的同时，也能够让用户在无意识的状态下等待更长的时间，促进购买的最终达成。</p> \n <p>所以，在你的UI设计中，也可适当的添加一些人性化设计，增加其可用性。</p> \n <p><img alt=\"\" height=\"486\" src=\"http://timg01.bdimg.com/timg?pacompress&amp;imgtype=1&amp;sec=1439619614&amp;autorotate=1&amp;di=4d75151abc7ce003d0bf9049f6306c08&amp;quality=90&amp;size=b870_10000&amp;src=http%3A%2F%2Fpic.rmb.bdstatic.com%2Fd8abed64e2d3c66a383006ce1849411a.jpeg\" width=\"870\"></p> \n <p>以上就是我们所收集的10款最新优质手机端美食软件界面设计实例。希望你能欣赏的同时，吸收到一些能够应用到你的UI设计之中的实用因素。</p> \n <p>简单快速的原型工具助你设计出漂亮实用的美食软件</p> \n <p>浏览以上10款美食软件的最新界面设计之后，获得一些灵感，但任然未找到一款能够快速将你的想法转化成可视的原型图，并验证其可行性，实现设计快速迭代的原型工具？简单快速的<a href=\"http://www.mockplus.cn/?hmsr=wen\" target=\"_blank\" rel=\"nofollow\"><strong>Mockplus</strong></a>会是你的最佳选择。它拥有许多强大的功能助你设计出美观且独具特色的美食软件：</p> \n <p>1). 使用其快速格子功能批量添加美食图片</p> \n <p>为了吸引更多的软件用户，UI设计师经常在其界面设计中添加大量精致且诱人的美食图片。在Mockplus中，你可以轻松使用其快速格子功能，为你的美食软件简单快捷地批量添加图片。</p> \n <p><img alt=\"\" height=\"545\" src=\"http://pic.rmb.bdstatic.com/87d6d23847076aba91c178568fefc233.gif\" width=\"688\"></p> \n <p>2).利用其数据填充功能自动填充大量美食图片和说明</p> \n <p>逐个填充添加的所有美食图片以及文字说明也很费时费事？使用Mockplus， 你可以轻松地使用其数据填充功能，一键自动填充大量美食图片以及说明。</p> \n <p><img alt=\"\" height=\"598\" src=\"http://pic.rmb.bdstatic.com/1c77d76ae642ac50e782ef81c02a5507.gif\" width=\"1013\"></p> \n <p>3).添加各类美食图标丰富你的UI 设计</p> \n <p>为使软件界面更加简洁直观，设计师也时常会为其美食软件添加各式美食图标。而Mockplus封装了超过3000个图标的强大图标库，方便设计师轻松选择和编辑各类美食图标。</p> \n <p>4).简单拖拽快速添加转化和交互</p> \n <p>灵敏多样的交互和转化也是设计师增加软件实用性和吸引力的重要方式。而作为一款简单快速的原型工具，Mockplus允许设计师简单地拖拽即可实现软件原型组件之间，组件与页面之间以及页面之间的交互。</p> \n <p>5).其他功能</p> \n <p><a href=\"http://www.mockplus.cn/?hmsr=wen\" target=\"_blank\" rel=\"nofollow\"><strong>Mockplus</strong></a>还拥有其他简单且实用的功能，例如团队协作功能，8种演示和预览方式，各类软件项目，页面模板和示例等，帮你简单快速地提升和完善软件UI 设计。</p> \n <p>总之，无论你尝试设计哪种类型的手机美食App，简单快捷的Mockplus都可以成为你测试想法并将其以可视化原型呈现出来的最佳工具。</p> \n <p>结语</p> \n <p>网络时代，越来越多的餐厅/酒店/咖啡/水果店认识到网络的重要性，选择定制自己专属的手机美食App以增加其营业额。而这也逐渐成为一股势不可挡的潮流。然而，这一潮流给UI设计师们带来发展机遇的同时，也给设计师们带来了挑战，例如更加娴熟的界面设计技能要求，以及更加熟练掌握测试和迭代设计想法的原型工具使用技能的要求等。总之，无论是机遇还是挑战，都希望这篇文章搜集的10款最新优质美食软件界面设计实例和介绍的简单快速的原型工具能对你有所启发，有所帮助。</p> \n</div>',NULL,'2020-02-09 15:21:19',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226405922318942208',NULL,NULL,' 为什么这些UI设计很糟糕？什么是好的UI设计？  ','<div class=\"content\" id=\"articleContent\"> \n <p><a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\"><em><strong>UI（User Interface）</strong></em></a>，即界面设计，它是网站、App给用户在感觉（视觉、触觉、听觉等）和情感上带来的第一体验，包括人机交互、界面逻辑、界面美观设计三个方面 。简单来讲，UI不仅是一种表现形式，更是用户对界面的体验和信息交互意愿。显而易见，好的UI设计不仅让软件有个性、品位，还让用户操作简单舒适，从而进一步体现软件的定位和特点。那么，到底什么才算是好的UI设计呢？在UI设计中有哪些常见的错误呢？UI设计师还有哪些应该避免的问题呢？下面小编一一为你来解答。</p> \n <p><strong>好的UI设计 Vs. 糟糕的UI设计 ，区别在哪？</strong></p> \n <p>除了众所周知的Kiss（Keep it simple and easy）产品设计原则外，好的UI设计应该也符合4个E的标准，即：</p> \n <p>- Easy to use（方便使用）</p> \n <p>- Easy to understand（简单易懂）</p> \n <p>- Error-free（零错误）</p> \n <p>- Effective for the end-goal (or product)（有助于最终目标的实现）</p> \n <p>相反地，糟糕的UI设计给人一种复杂难懂、太过平凡甚至落后的感觉。如果是好的UI设计，会以一种直观的方式地让用户明白如何与网站进行交互，即便是首次访问某个页面或App，也能快速了解它的操作流程及原理；而坏的UI设计，不仅无法体现设计者的创意，而且会在无意中给用户传递误导的信息，从而带来不安感、糊涂感、挫折感、甚至愤怒感。当然，不好的UI设计会带来糟糕的用户体验，大家看看最新发布的iPhone X的“刘海儿”就知道了…</p> \n <p>那么，什么样的UI设计是糟糕的呢？下面列举了6个典型的例子及教训，供你参考。</p> \n <p><strong>六个糟糕的UI设计案例，看看你中枪没？</strong></p> \n <p>1. 缺乏对比</p> \n <p>当浏览网站时，我们喜欢看页面设计展示出干净、清爽的对比，这样不仅可以让内容可读，而且能毫不费力地引导用户。如图，如果没有足够的对比度的话，无论是颜色还是整体展示，都会让人觉得有点摸不着头脑，内容看起来可以说是相当费力了。</p> \n <p>错误案例示范：</p> \n <p><img alt=\"\" height=\"309\" src=\"https://static.oschina.net/uploads/space/2017/1031/115226_KCkP_3519468.png\" width=\"750\"></p> \n <p>正确案例示范：</p> \n <p><img alt=\"\" height=\"512\" src=\"https://static.oschina.net/uploads/space/2017/1031/115236_0j24_3519468.png\" width=\"768\"></p> \n <p>2. 非响应式的设计</p> \n <p>尤其对于在手机上浏览时要放大、缩小界面元素的用户来说，非响应式设计会造成诸多不便。我们没有任何借口去创建一个在手机上很难用的网站，除非前期做了大量的用户测试，并已经证明响应式设计并不是必需的 。像下面这样对移动用户不友好的购物网站，会流失很多核心用户及潜在客户也是意料之中的事 。</p> \n <p>错误案例示范：</p> \n <p><img alt=\"\" height=\"279\" src=\"https://static.oschina.net/uploads/space/2017/1031/115246_p2uI_3519468.png\" width=\"750\"></p> \n <p>正确案例示范：</p> \n <p><img alt=\"\" height=\"540\" src=\"https://static.oschina.net/uploads/space/2017/1031/115257_xyEt_3519468.jpg\" width=\"960\"></p> \n <p>3. 没有用户反馈、抄袭数据</p> \n <p>从别人的设计中获取灵感并不一定是件坏事，但前提要确保我们拥有足够多而且正确的用户数据，从而带来最佳的用户及设计价值。像下面这样的设计，就有种画虎不成反类犬的感觉了。</p> \n <p>错误案例示范：</p> \n <p><img alt=\"\" height=\"191\" src=\"https://static.oschina.net/uploads/space/2017/1031/115307_XvrE_3519468.png\" width=\"750\"></p> \n <p>正确案例示范：</p> \n <p><img alt=\"\" height=\"682\" src=\"https://static.oschina.net/uploads/space/2017/1031/115315_mT42_3519468.jpg\" width=\"960\"></p> \n <p>4. 混乱的架构</p> \n <p>每个设计师都希望自己的设计能脱颖而出、夺人眼球，但过于强调创造可能会带来组织架构的混乱。保持视觉层次结构平衡能给用户良好的初次印象。更重要的是，能向用户传递更多网页内容以外的信息。如图，下面这个网页的界面设计多少给人一种错乱、分不清楚重点的感觉。</p> \n <p>错误的案例示范：</p> \n <p><img alt=\"\" height=\"479\" src=\"https://static.oschina.net/uploads/space/2017/1031/115324_5i3j_3519468.png\" width=\"624\"></p> \n <p>正确的案例示范：</p> \n <p><img alt=\"\" height=\"825\" src=\"https://static.oschina.net/uploads/space/2017/1031/115336_yBNw_3519468.jpg\" width=\"960\"></p> \n <p>5. 不一致的风格</p> \n <p>混搭风格不一定都是糟糕的，但如果整体界面的看起来有巨大的、丑陋的视觉冲突，那么还是“回炉”重新设计较好。出色的UI设计具有一致性，它能让用户在访问网页时能清楚了解并控制当前的局面，从而提高工作效率。</p> \n <p>错误案例示范：</p> \n <p><img alt=\"\" height=\"204\" src=\"https://static.oschina.net/uploads/space/2017/1031/115345_6Tl9_3519468.gif\" width=\"512\"></p> \n <p>正确案例示范：</p> \n <p><img alt=\"\" height=\"204\" src=\"https://static.oschina.net/uploads/space/2017/1031/115354_hbN7_3519468.gif\" width=\"512\"></p> \n <p>6. 臃肿的表单</p> \n <p>有时候我们需要通过表单来收集必要的用户信息，但过长、内容过多的表单不仅很浪费时间，而且看起来也给人不清晰的感觉。因此考虑把表单精简或者进行分步骤展示，用户体验会更好。</p> \n <p>错误案例示范：</p> \n <p><img alt=\"\" height=\"663\" src=\"https://static.oschina.net/uploads/space/2017/1031/115403_gBRn_3519468.png\" width=\"921\"></p> \n <p>其实像用户表单、评论区这类带有社交性质的界面元素，已经被越来越多的网站及App重视和使用。如果能增加用户社交分享按钮（比如微信、QQ、微博），或者通过输入账号来订阅关注的信息，不仅可以增加有效的传播途径，还能增加用户留存率。下面的设计案例，倒是可以好好借鉴一下。</p> \n <p>正确案例示范：</p> \n <p><img alt=\"\" height=\"471\" src=\"https://static.oschina.net/uploads/space/2017/1031/115412_V8Mf_3519468.png\" width=\"960\"></p> \n <p><strong>UI设计中有哪些常见的问题？</strong></p> \n <p>常见的问题有以下五个：</p> \n <p><strong>1. 过分地限制设计探索。</strong>由于项目时间及风险等原因，不少UI设计师其实在规划设计方案前，并不能进行比较广泛、创意类的设计探索，从而无法大胆地提议、限制了自己的作品表现力。对于设计团队来说，用3－6个月的时间对产品迅速定位并配合产品运作模式来正面改变，是必需的。</p> \n <p><strong>2. 不够人性化。</strong>这是设计中最重要也较容易被忽视的一点。所有设计都应该以人为本、而不是照本宣科。我们需要有更多的数据分析及素材资源，确保设计想法最终能被用户接受并认可 。</p> \n <p><strong>3. 不清楚产品的受众。</strong>简而言之，应该根据自己的目标受众、而非自身的喜好来进行设计，打破设计格局，创造好的设计卖点。</p> \n <p><strong>4. 过早地精雕细琢。</strong>尤其在设计初期时，会想把脑海中浮现的酷炫概念不假思索地画出来，然后开始绘制高保真地模拟图等。但最好的做法，还是应该从不同的方面进行思考探索，挖掘更多、更有潜力的idea。</p> \n <p><strong>5. 过度地使用动效。</strong>说实话，无意义的动效设计几乎随处可见，这不仅阻碍了用户实现目标，而且让人看着很厌烦（如下）。因此避免使用装饰性的动画效果，让动画特效的真正用于加强网站及应用的用户体验中。</p> \n <p><img alt=\"\" height=\"600\" src=\"https://static.oschina.net/uploads/space/2017/1031/115425_OynD_3519468.gif\" width=\"600\"></p> \n <p><strong>结语</strong></p> \n <p>综上所述，好的UI设计一定是在保证美观的大前提下，保证结构清晰、注重用户体验、独特、统一、且简洁的。听起来很简单，对吧？实际要做到并不容易。即便能够吸收且确保前期的设计想法正确，但当实际运用时可能又会有很多未预料到的事情。从想法到落地的这一过程，才是真正考验个人能力的阶段。</p> \n <p>而一款好用的设计工具，不仅能够帮助你更好地展现想法，同时能让你在整个设计过程中避免很多不必要的错误操作。其中，国民原型设计软件<a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\"><em><strong>Mockplus</strong></em></a>提供脑图、UI流程图及多种导出格式的项目树，能直观地展现各页面之间的结构，设计思路没毛病！</p> \n <p>－海量封装的组件及UI图标，让你的设计外观有bigger、更better</p> \n <p>－多种交互命令及丰富的组件属性，让你的设计动效有逻辑、更帅气</p> \n <p>－各类项目例子和模板，让你的设计更有灵感、更轻松</p> \n <p><img alt=\"\" height=\"452\" src=\"https://static.oschina.net/uploads/space/2017/1031/115436_hw06_3519468.jpg\" width=\"905\"></p> \n <p>如果你对自己的设计有信心、想挑战优秀的设计达人，可以报名参加<a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\"><em><strong>Mockplus三周年设计大赛</strong></em></a>，作品提交并通过审核即有免费试用赠送。</p> \n</div>',NULL,'2020-02-09 15:22:12',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226406144285704192',NULL,NULL,' 设计师必看：8处满足原型设计的矢量图标根据地  ','<div class=\"content\" id=\"articleContent\"> \n <p>做原型设计时，我们往往感觉图标素材不够用，尤其是矢量图标不够。</p> \n <p>矢量图标是矢量图的一种，这种图形也叫做绘图图像，是各种设计中比较常用的图片格式之一。因为其是根据几何特性绘制，并且通过数学公式计算获得，所以，矢量图最大的特点就是可以无限根据设计需要放大或缩小，并且不会失真。那么，这么好用的矢量图标，要到哪里去找呢？今天我就和大家一起逛逛国内外比较常用的矢量图标的网站。</p> \n <p>1.&nbsp;<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"nofollow\">阿里巴巴矢量图标库</a></p> \n <p>在国内来说，Iconfont.cn可以说是国内设计师们的一块宝地。这是一个由阿里巴巴的UX部门推出的在线矢量图标分享管理平台。这个网站上的矢量图标数量在1000个以上，而且更新也相对比较活跃，Iconfont平台为用户提供在线图标搜索、图标分捡下载、在线储存、矢量格式转换、个人图标库管理及项目图标管理等基础功能。在该网站上，下载矢量图标是不需要登录的。</p> \n <p><img alt=\"\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/926f1b47-af39-4e0a-a976-0f393211a840.png\"></p> \n <p>2.&nbsp;<a href=\"http://www.easyicon.net/language.en\" target=\"_blank\" rel=\"nofollow\">Easyicon</a></p> \n <p>Easyicon作为图标分享平台，在数量上可以说是国内屈指可数的，总计50万个左右，而且数量仍然在不断增长。矢量图标在这五十万个图标中占比很大。而且图标不仅是黑色和灰色，如果希望提高设计的保真度，在这里还可以找到彩色的矢量图。同样的，这个矢量图标分享平台目前还没有限制用户必须登录才能下载。</p> \n <p><img alt=\"\" height=\"460\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/32623a20-38b6-4e38-8889-a9b1517aa9b1.png\" width=\"750\"></p> \n <p>3.&nbsp;<a href=\"http://www.lanrentuku.com/vector/icon/\" target=\"_blank\" rel=\"nofollow\">懒人图库</a></p> \n <p>懒人图库一直专注于提供网页素材下载，其内容涵盖网页素材，矢量素材，JS广告代码，小图片，网页背景，导航菜单，PNG图标等，让任何一个网页设计师都能轻松找到自己想要的素材！懒人图库可以说是受到了设计师们和站长们的广泛喜爱，每天来都会有一些素材更新。这个网站还在不断的成长过程中。</p> \n <p><img alt=\"\" height=\"429\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/36b992da-0e38-49b2-aad8-e70f1a51ec49.png\" width=\"750\"></p> \n <p>下边会介绍几个国外的网站，这些网站也都提供大量的免费矢量图标素材。</p> \n <p>4.&nbsp;<a href=\"http://www.freepik.com/\" target=\"_blank\" rel=\"nofollow\">Freepik</a></p> \n <p>Freepik是国外拥有相对较高人气的图片素材网站之一，每个月都会收到来自世界各地的230多个国家的超过2000万访问。着力于为用户提供高质量的图形设计，插图和图形资源：独家的设计团队，为用户提供丰富的内容，既可以用于个人收集也可以作为商业项目材料。网站的管理者也称：在Freepik，用户至上。</p> \n <p><img alt=\"\" height=\"410\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/fd6eabac-f18f-4317-b3d6-af974476cd1d.png\" width=\"750\"></p> \n <p>5.&nbsp;<a href=\"http://www.flaticon.com/\" target=\"_blank\" rel=\"nofollow\">Flaticon</a></p> \n <p>Flaticon提供给用户，高质量的图形设计：完全可编辑的矢量由我们的设计团队，为用户提供丰富的内容，既可以用在个人和商业项目精心挑选的。</p> \n <p>这段看上去是不是和Freepik很像？因为，其实Flaticon就是Freepik的创始人们组建的另一个平台。2010一批企业家联手创建Freepik。鉴于搜索图标的水平高，他们决定推出Flaticon。三年后，一个主要对矢量图标和矢量图标编辑的平台诞生了，它就是Flaticon。</p> \n <p>这个平台上图标的明显不同就是，可编辑。即使是免费用户，也提供了相应的编辑图标的方法。如果你想成为付费用户，也还是比较划算的，因为他们升级专业版的价格也比较低廉。</p> \n <p><img alt=\"\" height=\"400\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/3283b774-6918-4967-a338-9341c0d41f1b.png\" width=\"750\"></p> \n <p>6.&nbsp;<a href=\"https://www.vecteezy.com/\" target=\"_blank\" rel=\"nofollow\">Vecteezy</a></p> \n <p>Vecteezy号称是世界上最大的矢量图形社区。在这里，你可以探索和来自世界各地的讨论其他艺术家的创作，或是为你的下一个项目找到完美的免费素材。Vecteezy使得来自世界各地成千上万艺术家探讨矢量图形的更加方便，每组素材都会提供相应的评论区。这里的大多数文件都是可以免费下载的，根据许可证，可以免费使用在项目中。网站的标语说出了设计师们工作的目标：让内容说话。</p> \n <p><img alt=\"\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/b032e523-f4bf-412f-a399-03fee81d57b3.png\"></p> \n <p>7.&nbsp;<a href=\"http://vector4free.com/\" target=\"_blank\" rel=\"nofollow\">Vector 4 free</a></p> \n <p>vector4free.com是一个网站致力于免费矢量图形：Adobe Illustrator AI、EPS、PDF、SVG、Corel Draw CDR文件免费下载，你都可以在这里找到。为了方便工作的需要，每一个都免费的图标被分类并打上了标签。希望你也能享受到到vector4free.com方便和友好的。</p> \n <p><img alt=\"\" height=\"560\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/8bb8a881-dd46-40c6-b33d-8a6112ff5461.png\" width=\"750\"></p> \n <p>8.&nbsp;<a href=\"https://www.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">Mockplus</a></p> \n <p>你也许会感到很奇怪，为什么Mockplus会出现在这里？我来告诉你吧，如果你已经升级到了Mockplus，那么，你会在它的图标库中发现2600多个矢量图标以及400多个平面图标。我觉得，这个很实用。因为，大多数情况下，你不会需要在制作原型时，去打开其它网站搜寻图标。你需要做的，只是点击图标库，搜索一下。在线离线，网络稳定与否，完全不受影响。</p> \n <p><img alt=\"\" src=\"https://cdns-mockplus-cn.alikunlun.com/image/2016/11/9c8b960c-2f34-4f0d-a8c2-4e6657b2b432.png\"></p> \n</div>',NULL,'2020-02-09 15:23:05',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226406367338790912',NULL,NULL,' 免费框架那么多，为什么选择付费的框架  ','<div class=\"content\" id=\"articleContent\"> \n <p>&nbsp;</p> \n <p>　　我们先来谈谈前端框架.</p> \n <p>　　前端技术最近几年发展的特别迅速，可以说是百家争鸣。在底层的前端框架领域中，最早是jquery称霸互联网，近两年mvvm类型的框架慢慢成为主流，Vue、React和Angular三大框架并驾齐驱。可以说，目前这四种是开发者用的最多使用最广的底层框架，也由此衍生了大量基于这些框架的免费UI库。</p> \n <p>&nbsp;</p> \n <p>　　这是一个非常好的现象，越来越多的UI库推出，相互之间有了竞争会促进大家都把自家的产品做得更好一些，开发者也有更多的选择。最理想的状态就是：我要开发一套系统，所有UI控件都能从免费的UI库中找到现成的，然后拼拼凑凑的就能做出一个项目，节约大量的时间和精力，多余的时间可以学点别的或者喝喝茶聊聊天，项目做得好老板还会给我升值加薪，迎娶白富美走上人生巅峰。</p> \n <p>&nbsp;</p> \n <p>　　当你去使用某一套UI库时，你会发现想象很美好，现实很残酷。做个小东西还行，如果是企业级项目，网上下载的UI库很少有能满足所有需要的，你要从网上再去找一些别的内容，然后你会发现免费的东西十分浪费时间，因为这些不同来源的混着一起就产生了很多问题，比如风格不统一、功能上不兼容、样式相互覆盖、性能有影响、用法各成一派，甚至组件本身也功能不足，向作者提个bug要可能几个月后才修正。当你花了很多时间把这些都处理好以后，又很可能被客户抱怨界面不美观精致，用户体验不好。</p> \n <p>&nbsp;</p> \n <p>　　其实，正如那句话所说：免费的东西才是最贵的。那么收费的QUICKUI又有什么优势呢？</p> \n <p>&nbsp;</p> \n <p><strong>　　1、品质保障</strong></p> \n <p>&nbsp;</p> \n <p>　　QUICK&nbsp;UI从推出开始就是面向企业级应用的商业产品，所以对品质的要求非常高，我们的要求是：</p> \n <p>&nbsp;</p> \n <p>　　首先，UI组件种类和功能特性要足够丰富，用于满足企业开发遇到的各种可能的情况。现在的QUICK&nbsp;UI4.0包含了上百种组件，上千种示例演示功能特性，这些都是在7年间一直应用在商业项目从而总结出来的；</p> \n <p>&nbsp;</p> \n <p>　　第二，UI组件必须非常稳定高效。在企业级项目中，经常会出现复杂的使用场景和比较极端的场合。例如一个页面表格一页有一千行，或者点击一个下拉框里面嵌入一个表格等等。QUICK&nbsp;UI根据用户的反馈不断完善，可以满足各种复杂的使用场合，而且已经将bug的可能性降到最低；</p> \n <p>&nbsp;</p> \n <p>　　第三，UI组件必须美观精致，用户体验要很好。近几年大家的审美水平越来越高，美观和用户体验良好对项目的影响也是越来越大。很多UI库看上去就好像是生活在刀耕火种的时代，离现代人的品味差距太大。QUICK&nbsp;UI在这方面下足了功夫，精心设计的UI风格样式让人赏心悦目，提高客户对你的项目的评价。</p> \n <p>&nbsp;</p> \n <p><strong>　　刀耕火种时代的UI库</strong></p> \n <p><img height=\"194\" width=\"459\">&nbsp;<img alt=\"\" height=\"194\" src=\"https://static.oschina.net/uploads/space/2017/1018/152509_uyxd_3683197.png\" width=\"459\"></p> \n <p><strong>　　符合现代审美的UI库</strong></p> \n <p><img height=\"301\" width=\"553\">&nbsp;<img alt=\"\" height=\"538\" src=\"https://static.oschina.net/uploads/space/2017/1018/152519_aKIi_3683197.png\" width=\"989\"></p> \n <p><strong>　　2、皮肤机制</strong></p> \n <p>&nbsp;</p> \n <p>　　跟其他web前端框架仅仅是一套组件库不同，QUICK&nbsp;UI有一套很便利的皮肤机制，搭配皮肤包可以实现效果的千变万化，让你的项目不再是千篇一律的单调风格。</p> \n <p><img height=\"374\" width=\"554\">&nbsp;<img alt=\"\" height=\"662\" src=\"https://static.oschina.net/uploads/space/2017/1018/152530_NkMi_3683197.png\" width=\"980\"></p> \n <p>　　QUICK&nbsp;UI的外观界面解决方案采用现今流行的扁平化设计理念，推出了包括登录、响应式web、工作桌面、地图类、门户风格、大屏展示风格等等上百套制作精美、用户体验优秀的界面。这些界面是以皮肤包的形式发布，使用和更换都非常方便。</p> \n <p>&nbsp;</p> \n <p><strong>　　3、节约时间精力</strong></p> \n <p>&nbsp;</p> \n <p>　　QUICK&nbsp;UI上手开发非常容易，采用组件化思想，将开发人员从繁琐的JS编码中解脱出来，很大程度减少前台编码的出错率，对开发者技术要求也非常低，只需要了解html语法和一些简单的JS即可。我们甚至还做了一套后台服务用于演示前后台如何交互数据，为的是最大程度的节约学习成本，从而让开发者把更多精力放在业务功能的实现上，提高开发效率。</p> \n <p>&nbsp;</p> \n <p><strong>　　4、技术支持</strong></p> \n <p>&nbsp;</p> \n <p>　　跟很多个人开发者业余时间处理问题不同，我们有一个专业的技术团队为用户提供服务。付费用户在使用QUICK&nbsp;UI时，如果提出一个问题或者bug，将会很快得到回应。当遇到不容易描述的问题时，我们还提供电话支持和远程协助等方式，尽全力帮用户解决问题。此外我们还提供很多增值服务，例如皮肤定制、前端技术培训等等。</p> \n <p>&nbsp;</p> \n <p>　<strong>　5、兼容低版本IE</strong></p> \n <p>&nbsp;</p> \n <p>　　为了在现代浏览器中会有很好的效果，很多框架都舍弃了对低版本IE的支持。QUICK&nbsp;UI4.0虽然也使用了很多HTML5，CSS3技术用于提高表现力和用户体验，但考虑到国内依然有大量的用户在使用IE7、IE8等旧时代的浏览器，框架采用了渐进式思想，确保低版本浏览器也能正常使用。所以，QUICK&nbsp;UI兼容IE7以上所有主流浏览器。</p> \n <p>&nbsp;</p> \n <p>　<strong>　总之一句话：</strong>如果你喜欢自己研究怎么用别人的轮子给自己造辆车，它可能不适合你。如果你想节约时间和精力直接买一辆车去创造更大的价值，可以尝试一下QUICK&nbsp;UI。</p> \n <p>&nbsp;</p> \n <p>　　本文由UIleader原创，转载请注明来源！</p> \n</div>',NULL,'2020-02-09 15:23:58',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226406589611737088',NULL,NULL,' 不容错过！2016年度优秀UI/UX设计文章  ','<div class=\"content\" id=\"articleContent\"> \n <p>本文整理了一些2016年度最受欢迎的文章，例如有关UI / UX设计的理论知识，书籍和工具，如何做出更好的设计的方法和建议，以及新的设计趋势。</p> \n <p><img alt=\"\" height=\"685\" src=\"https://file.mockplus.cn/image/2016/12/b32745de-2d7d-4337-9278-4252cb48eced.png\" width=\"1465\"></p> \n <p>1.&nbsp;<a href=\"https://uxdesign.cc/ux-trends-2017-46a63399e3d2\" target=\"_blank\" rel=\"nofollow\">2017年用户体验设计趋势</a></p> \n <p>我们期待着2017年用户体验设计将如何发展。同时，我们对用户体验的过去，现在，以及对将来的预测都有一些看法。</p> \n <p>2.&nbsp;<a href=\"https://medium.com/the-year-of-the-looking-glass/why-design-f3c8546c9672\" target=\"_blank\" rel=\"nofollow\">设计是为什么？</a></p> \n <p>某些方面来讲，这种知识是苦乐参半的。 没有什么是永恒的。你想做一个改变世界的东西，但是在很久以前，世界就已经改变了。 它不再激发同样的奇迹。 考虑到时间问题，我们总是要求得更多。</p> \n <p>3.&nbsp;<a href=\"https://uxdesign.cc/design-better-forms-96fadca0f49c\" target=\"_blank\" rel=\"nofollow\">设计更好的表格</a></p> \n <p>无论是注册流程，多视点步进器还是单调数据输入接口，表单都是数字产品设计中最重要的组件之一。 本文重点介绍表单设计的常用做法和需要避免的地方。 但请记住，这些只是一般准则，每个规则都有例外。</p> \n <p>4.&nbsp;<a href=\"https://medium.com/@hellostanley/design-doesnt-scale-4d81e12cbc3e\" target=\"_blank\" rel=\"nofollow\">设计没有规模</a></p> \n <p>设计没有规模是过去四年一直困扰着我的一个问题。 2012年，我加入Spotify的设计团队时，其不一致和分散的程度令我震惊。 Up-close，类型，颜色，图像，布局，IA和交互的处理似乎没有任何地方一致。 当我提及到这一点时，我意识到整个团队也很沮丧。 我们的结论是，产品中的碎片只是反映了团队中的碎片化，设计师分散在这么多不同的项目，时区和紧凑的时间表，只是没有一个机会达到统一罢了。 毕竟，所有现代科技公司都不是存在这些固有的因素吗？ 那时，我第一次听到自己说，“设计没有规模”。</p> \n <p><img alt=\"\" height=\"900\" src=\"https://file.mockplus.cn/image/2016/12/48625190-78e5-415d-b378-1dd95b9dd2e5.png\" width=\"1880\"></p> \n <p>5.&nbsp;<a href=\"http://bit.ly/2hnHoKv\" target=\"_blank\" rel=\"nofollow\">UX和UI设计之间的区别——来自一个门外汉的指导</a></p> \n <p>走在世界科技中心的街道上，我们常常会听到一些讨论产品的“用户体验”或某网站糟糕的UI设计。 这些话听起来像是不能说的秘密？ 还是这些人只是为了扮酷？ 好吧，可能是后者。再往下看，了解下这些术语是什么意思，什么行业工资更高，以及如何成为UX设计师或UI设计师。 帖子的中间可以观看视频，会给让你真正的了解到UX或UI设计师的含义。</p> \n <p>6.&nbsp;<a href=\"https://www.mockplus.cn/blog/post/401\" target=\"_blank\" rel=\"nofollow\">UX、UI、 IA和IxD傻傻分不清</a></p> \n <p>在以前，一般所说的设计多半是指平面设计。随着数字时代的快速发展，涌现了一批新的职位，因此一些外行人士或者刚入行的人对设计相关的职位是傻傻分不清。这篇文章主要是对设计领域四个不同职位的一些概述，希望对你有一些帮助。</p> \n <p>7.&nbsp;<a href=\"https://medium.com/swarm-nyc/complexion-reduction-a-new-trend-in-mobile-design-cef033a0b978\" target=\"_blank\" rel=\"nofollow\">Complexion Reduction ---移动设计新趋势</a></p> \n <p>Facebook、Apple、Instagram、Airbnb……这些走在 APP 设计最前面的公司，似乎在最近几个月都选择了同一种方法来改进 UI（用户界面）。</p> \n <p>8.&nbsp;<a href=\"https://medium.com/@kollinz/hamburger-menu-alternatives-for-mobile-navigation-a3a3beb555b8\" target=\"_blank\" rel=\"nofollow\">汉堡菜单替代手机导航</a></p> \n <p>如果你正在研究数字产品，阅读了几十篇文章，你发现都是在讲述移动（桌面）端的汉堡导航的不易发现和低效率是如何不利于用户体验。</p> \n <p>9.&nbsp;<a href=\"https://medium.com/digital-experience-design/how-to-apply-a-design-thinking-hcd-ux-or-any-creative-process-from-scratch-b8786efbf812\" target=\"_blank\" rel=\"nofollow\">如何应用设计思维，HCD，UX</a></p> \n <p>这篇文章旨在为设计师，创意师甚至项目经理提供设置，框架，组织，结构，运行或管理设计挑战以及项目。</p> \n <p>10.&nbsp;<a href=\"https://uxplanet.org/best-practices-for-microinteractions-9456211aeed0\" target=\"_blank\" rel=\"nofollow\">微交互的最佳实践</a></p> \n <p>微交互是以完成单个任务为中心的微妙时刻。 我们几乎所有的应用程序都充满了微交互。</p> \n <p>这里只是几个例子：</p> \n <p>确认项目已添加到购物车</p> \n <p>使用“下拉式刷新”更新内容</p> \n <p>确认操作的界面动画（例如，切换按钮）</p> \n <p><img alt=\"\" height=\"449\" src=\"https://file.mockplus.cn/image/2016/12/4e7d8a9a-b6b3-4dee-b87f-36746682efdf.png\" width=\"800\"></p> \n <p>11.&nbsp;<a href=\"https://www.mockplus.cn/blog/post/421\" target=\"_blank\" rel=\"nofollow\">推荐给设计师的UI/UX书籍和资源</a></p> \n <p>如果你想成为一名优秀的设计师，想要阅读些设计类的书籍而又无从下手，或不知从哪里快速寻找正确有效的资源。那么，我这里整理了一份书单，根据各大专业博客的推荐书目或者业内关注度比较高的书籍中精选得出的。主要涵盖方向是UI设计、UX设计或网页设计。希望对你有帮助。罗列不全的，也请大家以评论的方式给我留言或者直接联系我补充、修订。</p> \n <p>12.&nbsp;<a href=\"http://bit.ly/2gNABt6\" target=\"_blank\" rel=\"nofollow\">12个 UI / UX设计工具和网站</a></p> \n <p>设计工具的不断改进，对可用性和用户体验有积极的影响，为设计师和用户提供了极大的便利。 因此，一个好的网页设计师往往会与前沿设计保持一致，掌握最新的工具。 数以百计的设计博客和网站发表设计相关的文章，分享设计技能，并推荐在互联网上比较流行的新工具。 这是设计师的重要信息来源。</p> \n <p>13.&nbsp;<a href=\"https://medium.com/the-year-of-the-looking-glass/8-unintuitive-lessons-on-being-a-designer-ca7e97a572ee\" target=\"_blank\" rel=\"nofollow\">作为设计师的不直观的教训</a></p> \n <p>我有时开玩笑说我从设计中学到的一切都是从我的第一份工作中学到的。 现在，这第一份工作已经延续了近十年，其灵魂深度一致的一致性是我在一开始根本无法想象的，即使其外在和色彩一直在向前推进。</p> \n</div>',NULL,'2020-02-09 15:24:51',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226406813730177024',NULL,NULL,' 国外排名前20的设计博客和网站资源   ','<div class=\"content\" id=\"articleContent\"> \n <p><img alt=\"top-ux-design-blogs-and-blog-websites-of-2016-image.jpg\" src=\"https://attachments.tower.im/tower/c457bccae2b54a00af596d7d86a1fac6?version=auto&amp;filename=top-ux-design-blogs-and-blog-websites-of-2016-image.jpg\"></p> \n <p>在各行各业，尤其用户体验/界面设计中，唯有变化从未改变。当下的流行语似乎人尽皆知，而能保持对行业最新动态以及理念的敏锐嗅觉，确并非易事。尤其随着各类资讯以及资源的大量涌现，能筛选并找到于自己而言真正有用的信息，看起来愈发困难了。</p> \n <p>基于这样的情况，下面收集了一些自2016年来对用户体验/界面设计的国外最佳博客和网站资源。其中有些推荐是只有一位博主专门撰写和维护，有些则汇聚了行业意见领袖和专家的智慧结晶。各个推荐之间没有先后、排名区分，让我们一起来看看吧！</p> \n <p><strong>1.&nbsp;UI/用户界面设计</strong></p> \n <p><img alt=\"image1-about-ui-interfaces-image.jpg\" src=\"https://attachments.tower.im/tower/1f7c8346b8d94f839d4eceb52dad66e8?version=auto&amp;filename=image1-about-ui-interfaces-image.jpg\"></p> \n <p>下面介绍的博客网站，提供关于如何建立有效的、吸引用户眼球的界面设计的建议和方法。内容包括，移动设备、网站以及软件产品的界面设计，不容错过哦！</p> \n <ul> \n  <li><a href=\"https://dribbble.com/\" target=\"_blank\" rel=\"nofollow\">Dribbble</a>—设计师聚集的专业社区，设计相关话题以及UI设计都可以在这里被展示和讨论。</li> \n  <li><a href=\"https://www.behance.net/\" target=\"_blank\" rel=\"nofollow\">Behance</a>—能激发设计灵感的强大网站，任何传统/非传统的平面设计以及高质量的设计项目都能在这里创建。它并不仅限于网页或者移动端的UI设计。</li> \n  <li><a href=\"https://www.siteinspire.com/\" target=\"_blank\" rel=\"nofollow\">Site&nbsp;Inspire</a>—提供基于网页的界面设计，能显示实时的网页快照和位置。目前为止，收录了2500个网站，并且可以按主题、类型以及风格来进行搜索。</li> \n  <li><a href=\"https://www.smashingmagazine.com/\" target=\"_blank\" rel=\"nofollow\">Smashing&nbsp;Magazine</a>—领先的博客网站，提供网页设计以及开发相关的资源和信息。非常注重博客的质量，具有行业权威性。</li> \n  <li><a href=\"http://usabilitypost.com/\" target=\"_blank\" rel=\"nofollow\">Usability&nbsp;Post</a>—内容包含大量的网页设计和可用性问题。其中，也有关于设计趋势的预测，以及对项目管理资源的推荐。</li> \n </ul> \n <p><strong>2.&nbsp;设计策略</strong></p> \n <p><img alt=\"image2-about-ui-strategy-image.jpg\" src=\"https://attachments.tower.im/tower/1dfecb5fb39a42dbbaacf524dc266b88?version=auto&amp;filename=image2-about-ui-strategy-image.jpg\"></p> \n <p>这些网站将提供一系列设计实践中的指导方针和方法技巧，内容丰富多彩，包括从设计理念到不同的项目管理方法。</p> \n <ul> \n  <li><a href=\"http://usabilitygeek.com/\" target=\"_blank\" rel=\"nofollow\">Usability&nbsp;Geek</a>—专注于设计与业务的交叉结合，有许多关于改进设计、提高转换率类相关的文章。</li> \n  <li><a href=\"https://medium.com/\" target=\"_blank\" rel=\"nofollow\">Medium</a>—与其他设计师进行故事互动的社区平台，每天都有成千上万的新故事持续更新。</li> \n  <li><a href=\"https://www.nngroup.com/\" target=\"_blank\" rel=\"nofollow\">Nielsen&nbsp;Norman&nbsp;Group</a>—发布关于用户体验设计的所有资讯，是一个提供与用户体验研究和报告相关的可信机构。</li> \n  <li><a href=\"http://www.webcredible.com/blog/\" target=\"_blank\" rel=\"nofollow\">Webcredible</a>—总部位于英国伦敦的UX设计机构，已与全球众多知名品牌合作，该博客包含UX相关的文章和资源。</li> \n </ul> \n <p><strong>3.&nbsp;UX/用户体验设计</strong></p> \n <p><img alt=\"image3-about-ux-design-image.jpg\" src=\"https://attachments.tower.im/tower/6f60cd60123146068a899094eca955e5?version=auto&amp;filename=image3-about-ux-design-image.jpg\"></p> \n <p>下列的资源网站，讨论以UX为主题的服务及产品，范围从UX行业发展趋势到给小白或者专家推荐的工具和软件。内容丰富，同样值得收藏、品读。</p> \n <ul> \n  <li><a href=\"http://www.awwwards.com/\" target=\"_blank\" rel=\"nofollow\">Awwwards</a>—行业领先的网站，会颁奖给挑选出来最好的移动和网页设计，读者也可以从中挖掘行业标准，把握最新的发展趋势。</li> \n  <li><a href=\"http://www.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">Mockplus</a>—优选用户体验、界面设计以及趋势预测的博客，所有文章都是经过精心挑选的，也提供如何进行有效设计的指南和技巧。</li> \n  <li><a href=\"http://designmodo.com/\" target=\"_blank\" rel=\"nofollow\">Designmodo</a>—综合性网站，提供标准/非标准的设计主题，以及一些设计发展，WordPress，教程，技巧类文章。</li> \n  <li><a href=\"http://uxmyths.com/\" target=\"_blank\" rel=\"nofollow\">UX&nbsp;Myths</a>—围绕用户体验设计，提供一些大家都可能都知道但并不正确的设计常规，博客会引用具体的学术调查，事实考察以及相关链接来进行论证。</li> \n  <li><a href=\"http://www.uxbooth.com/\" target=\"_blank\" rel=\"nofollow\">UX&nbsp;Booth</a>—知名度很高的出版商之一，读者可以通过子目录进行搜索，内容也包括内容策略和信息架构等。</li> \n  <li><a href=\"http://www.uxmatters.com/\" target=\"_blank\" rel=\"nofollow\">UX&nbsp;Matters</a>—可以激发设计灵感的网站，适合的人群既可以是在UX各方面都精通的专家，也可以是刚刚踏入UX设计领域的新手小白。</li> \n  <li>UX&nbsp;Movement—以UX设计为主题的博客网站，展示有用户界面将如何影响用户行为，并且会用实际的视觉例子举例说明。</li> \n  <li><a href=\"http://ux.stackexchange.com/\" target=\"_blank\" rel=\"nofollow\">User&nbsp;Ability&nbsp;Stack&nbsp;Exchange</a>—类似于国内“知乎”的问答社区。不同的是，它是专门为用户体验设计而服务的社区，许多偏生活化的专家意见也能在这里被发现。</li> \n </ul> \n <p><strong>4.&nbsp;设计工具及软件</strong></p> \n <p><img alt=\"image4-about-tools-software-image.jpg\" src=\"https://attachments.tower.im/tower/67de8d2a8d7b4228bdf93d11c2a4d302?version=auto&amp;filename=image4-about-tools-software-image.jpg\"></p> \n <p>这些网站的内容，包括对最新软件、UX工具、代码编程以及其他设计中必不可少的元素的介绍。其中还包括介绍有当下最流行、最实用设计工具的介绍。</p> \n <ul> \n  <li>&nbsp;<a href=\"http://www.creativebloq.com/\" target=\"_blank\" rel=\"nofollow\">Creative&nbsp;Bloq</a>—国外有名的博客网站站点，会定期推荐最新的UX设计工具以及书籍，同时也能从中找到自己最感兴趣的在线杂志。</li> \n  <li><a href=\"http://www.mockplus.cn/\" target=\"_blank\" rel=\"nofollow\">Mockplus</a>—推荐实用的软件资源和信息，其中对如何运用Mockplus进行快速原型设计有详细的指导说明。</li> \n  <li><a href=\"http://littlebigdetails.com/\" target=\"_blank\" rel=\"nofollow\">Little&nbsp;Blog&nbsp;Details</a>—精挑细选的博客文章，主要内容包括获取设计灵感、挑选最佳的设计软件，每天保持不断更新。</li> \n  <li><a href=\"http://boxesandarrows.com/\" target=\"_blank\" rel=\"nofollow\">Boxes&nbsp;and&nbsp;Arrows</a>—提供设计原则、方法、过程以及平面设计相关的博客文章，也有关于硬件/软件的文章内容。</li> \n  <li><a href=\"https://www.uxpin.com/studio/blog/\" target=\"_blank\" rel=\"nofollow\">UXPin</a>—国外市场上最流行的博客网站之一，主要从网站的角度来进行UX设计分析，有大量的文章资源，适合于硬件开发人员和设计人员。</li> \n </ul> \n <p>&nbsp;</p> \n <p>&nbsp;</p> \n</div>',NULL,'2020-02-09 15:25:45',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226407036351250432',NULL,NULL,' Mockplus: 一款简单而又强大的原型设计工具  ','<div class=\"content\" id=\"articleContent\"> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">在网络技术蓬勃发展的当今社会，各类线框图和原型设计工具也随之而大量涌现。但是，作为一款简单又不失强大的新型工具，Mockplus借着它的独特之处在市场中也占有着它的一席之地。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">作为一款简单，易学，易用，无代码的原型设计工具，Mockplus让用户更注重于设计本身而不需要花费大量的时间在软件的学习上。页面之间的链接只需一个“拖拽”选项就能搞定。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><img src=\"http://static.oschina.net/uploads/img/201511/12132828_BnKM.jpg\" alt=\"mockups-1\"></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">对于中小企业和团队来说，敏捷开发、快速迭代是他们最有效的快速融合并适应市场和消费者的方式。灵活，高效，低成本的原型设计对于现在的中小企业是至关重要的。总而言之，Mockplus是一款适用于敏捷开发的原型设计工具，也是软件开发公司用于原型构建的理想解决方案。鼠标驱动的组件视觉设计也省去了编程和培训成本。</p> \n <span id=\"OSC_h3_1\"></span> \n <h3>产品特色</h3> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">Mockplus提供各种桌面和移动设备组件以满足用户日益增长的需求。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">拖拽功能让设计变得简单，可以轻松的完成组件之间的交互功能。目前，Mockplus提供内置拖放组件，不久之后还会添加更为先进的交互式组件。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">“顶栏+菜单+底栏”的特性，Mockplus可以帮助你轻松的完成APP的页面设计，并且在各类组件之间随意标记。Mockplus的标记组件可以添加到你的原型设计中。可调节的新组件设置让APP页面设计变得更加方便。预设组件和内置图标让你的设计完成的更加简捷。内置图标也在不断的更新中。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\"><img src=\"http://static.oschina.net/uploads/img/201511/12132828_FDCU.jpg\" alt=\"mockups-2\"></p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">素描风格保证了设计草图的质量，并且手绘风格的组件能带给你真实的绘画体验感，无论是对线条还是对全局的把握。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">一体化的工具（包括免费版）能轻松的完成移动应用，桌面应用以及网页应用的原型设计。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">“组”功能可以实现设计预览，并分享到手机客户端而不需要借助于远程发布或者USB数据线。通过编辑，嵌套，或解散组的方式自定义组件组合。多页面和丰富的组件库让你的工作更有效率。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">页面和组件可以一键克隆。简单方便的Mockplus导出选项可以快速完成设计的图片或HTML输出。快捷页面和组件库有助于进一步提高工作效率。拖拽功能使交互设计变得可能,即将更新的版本将在原型设计的领域内做出全球性的改变。</p> \n <span id=\"OSC_h3_2\"></span> \n <h3>优势</h3> \n <ul> \n  <li><p>方便，快捷，免费</p></li> \n  <li><p>无需代码，无需培训</p></li> \n  <li><p>多项目，多页面</p></li> \n  <li><p>一体化工具</p></li> \n  <li><p>预构组件，内置图标</p></li> \n  <li><p>项目自动备份</p></li> \n  <li><p>可自定义</p></li> \n  <li><p>项目间自由复制</p></li> \n </ul> \n <span id=\"OSC_h3_3\"></span> \n <h3>改善空间</h3> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">试用版本不支持项目管理，PNG文件输出，HTML输出，以及打印功能。</p> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">用户需购买Mockplus专业版享受400+图标（免费版只提供100+），项目管理，PNG文件输出，HTML输出，以及打印功能。</p> \n <span id=\"OSC_h3_4\"></span> \n <h3>试一试吧！</h3> \n <p style=\"margin-top: 0px; padding: 0px; border: 0px; font-size: 14px; outline: 0px; vertical-align: baseline; color: rgb(99, 99, 99); font-family: \'Microsoft Yahei\'; line-height: 21px; white-space: normal; background: 0px 0px rgb(255, 255, 255);\">Mockplus在原型APP领域可能只是一个并不为大众所熟悉的名字，但是在不久的将来，它有希望会成为大家的正确选择。现在大多数的原型软件都会提供一个试用期，那为什么不尝试一下Mockplus，看看它是否能满足你的需求。欢迎大家提出宝贵意见和建议。</p> \n <p>原文：http://www.onextrapixel.com/2015/10/06/mockplus-a-simple-yet-powerful-prototype-design-tool/</p> \n</div>',NULL,'2020-02-09 15:26:38',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226407257844056064',NULL,NULL,' 成为一名自由UX设计师--你“够格”吗？  ','<div class=\"content\" id=\"articleContent\"> \n <p>和传统的朝九晚五，三点一线的生活状态相比，现在互联网时代下的年轻人更崇尚对自由的追求。“可任意支配时间”、“工作场所自由”和“收入高”是人们选择成为自由职业者的主要原因。特别是IT行业中的设计师群体，他们更希望成为自由UX设计师。</p> \n <p>一份自由职业者调查显示，IT相关的职业类型中，设计师、后端工程师和移动端开发人员是整个软件开发行业自由职业者的主要群体，占70%左右。其中设计师以UI/UX设计师为主，女性占46.81%，男性占53.19%。其次是产品经理和前端工程师，各占9%左右。7.65%的其它群体主要是全栈工程师，销售以及项目管理等。</p> \n <p>&nbsp;</p> \n <p><img src=\"http://upload-images.jianshu.io/upload_images/329666-6a2140527ffb8274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p> \n <p>&nbsp;</p> \n <p>一、自由UX设计师利弊分析</p> \n <p>近年来互联网和新创公司（startups）的成功，被归功于产品贴近用户的需求。物联网和穿戴式科技的盛行更加推动UX设计行业的发展，UX设计师的需求也与日俱增。市场需求和设计师们需要自我满足，追求自由的双重状态促使他们从全职设计师转变成为自由UX设计师。好处也是显而易见。</p> \n <p>1. 弹性工作时间</p> \n <p>不用朝九晚五，打卡上下班，有更多时间安排在设计或是深层次的学习上。</p> \n <p>2. 自由选择项目，不受公司限制，也不必担心你的设计再被老板挑三拣四。</p> \n <p>3. 和跨国公司合作，收入更高。</p> \n <p>但作为自由职业者，除了看得见的“自由”，也有他们无法言说的弊端。</p> \n <p>1. 没有稳定的项目来源</p> \n <p>和全职UX设计师相比，自由UX设计师更注重项目资源的稳定性。一旦没有项目可做，也就意味着没有收入，没有生活保障。</p> \n <p>2. 社会保障</p> \n <p>据统计，在纽约超过100万的自由职业者中，有84%的人在购买个人健康保险方面有困难。</p> \n <p>3. 个人精力有限</p> \n <p>某种程度上讲，自由UX设计师可以称为全栈设计师。创意思维，研究分析，策略制定，原型设计，交互设计等等一系列本应该有不同职能分工的事情变成了你自己一个人需要完成的事情。</p> \n <p>4. 如何成为一名优秀的自由UX设计师？</p> \n <p>自由职业不代表散漫，即便是独立的UX设计师，也应该规划好自己的职业生涯，尽量提升自己的专业能力。而这一点，在惰性和散漫面前，不可能每个人都能平衡得很好。</p> \n <p>二、自由UX设计师薪资状况</p> \n <p>如果你真的下定决心主导自己的工作和生活，那么，全职UX设计师和自由UX设计师的薪资水平将是一个决定性因素。</p> \n <p>全球UX设计师各工作经验水平阶段平均工资</p> \n <p>&nbsp;</p> \n <p><img src=\"http://upload-images.jianshu.io/upload_images/329666-e39e9785e437c3c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p> \n <p>(数据来源：<a href=\"http://uxdesignersalaries.com/\" target=\"_blank\" rel=\"nofollow\">http://uxdesignersalaries.com/</a>)</p> \n <p>全球自由UX设计师平均工资</p> \n <p>&nbsp;</p> \n <p><img src=\"http://upload-images.jianshu.io/upload_images/329666-51b3dcc1aba939bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p> \n <p>(数据来源：<a href=\"https://www.paysa.com/\" target=\"_blank\" rel=\"nofollow\">https://www.paysa.com/</a>)</p> \n <p>从图中可见，自由UX设计师的薪资由4部分构成：</p> \n <p>基础薪资：$96K。四分之一的自由UX设计师的基础工资低于82.5万美元。有一半的人基薪不到94.3万美元。榜首季度基薪超过108万美元。十分之一的人基薪超过$ 122K。</p> \n <p>年度奖金：$13K。四分之一的自由职业UX设计师年度奖金低于$ 9.2K。有一半的人不到12.3万美元。榜首季度奖金超过16.4万美元。十分之一的人奖金超过21.2万美元。</p> \n <p>年度权益：$24K。四分之一的自由UX设计师年度权益低于4.12万美元。其中有一半的人不到10万美元。榜首季度超过24.7万美元。十分之一的人年权超过$ 55.2K。</p> \n <p>一次性签约奖金：$17K。四分之一的自由UX设计师签约奖金低于$ 12.8K。一半的人签约奖金低于15.8万美元。榜首季度超过19.6万美元。只有十分之一的人签约奖金超过23.7万美元。</p> \n <p>三、如何寻找客户资源</p> \n <p>看来，让UX设计师们蠢蠢欲动的，不仅仅是“自由”。那作为一名自由UX设计师，怎样获取资源和人脉，怎样寻找客户呢？以下是我整理的一些资源。</p> \n <p><a href=\"https://www.toptal.com/designers/ux\" target=\"_blank\" rel=\"nofollow\">Toptal</a></p> \n <p>Toptal是一个全球精英自由职业者平台，号称只雇佣前3%的自由职业软件开发者和设计师。Toptal的自由职业者遍及全球93个国家，他们的职业是软件开发者或者设计师，有成千上万人。</p> \n <p><a href=\"https://dribbble.com/Mockplus\" target=\"_blank\" rel=\"nofollow\">Dribbble</a></p> \n <p>作为目前最有影响力、最被人讨论的针对设计者的线上社区之一。许多设计师为了寻找灵感，与设计师同行进行交流切磋等都会到Dribbble上去。很多公司或个人选择到dribbble雇佣自由UX设计师。</p> \n <p><a href=\"https://www.upwork.com/\" target=\"_blank\" rel=\"nofollow\">Upwork</a></p> \n <p>Upwork 是全球最大的最规范的综合类外包平台,目前拥有注册自由职业者1200万和500万企业客户,是全球最大的外包人力服务市场;自由职业者很容易在平台上接到诸如IT编程,翻译,写作,设计,采购,创意,法务等工作挣美元.雇主也很方便在平台上找到各种不同技能类型的服务商来加入自己的团队或项目。</p> \n <p>四、自由UX设计师如何提升自己</p> \n <p>那么自由UX设计师如何面对竞争越来越强的局面呢？答案就是提升自己!让自己成为众多设计师中最亮的一颗星。</p> \n <p>1. 建立自己的人脉圈</p> \n <p>《自品牌》里有一句话：你一生所经营的最重要的产品其实是你自己。获得良好工作的最佳方式就是与其他自由职业者交朋友。做好自己的工作，经营好自己的人脉圈。总有一天你会从中受益。</p> \n <p>2. 展示自己</p> \n <p>作为一个秘密自由UX设计师不是一个好策略。通过写博客，在社交平台上展示自己，参加各种UX活动，逛论坛，Quora，知乎等都是很好的展示和与人沟通的机会。</p> \n <p>3. 成为全栈设计师</p> \n <p>全栈设计师并不是指将整个产品的设计和开发过程揽于一身。更多是在强调，在整个项目的纵向维度里面，你能知晓与把控的越多越好。就好像你在参与产品与项目中，你了解上游的产品的核心目的以及逻辑，下游也懂基本的实现方式（并不是要你去写代码，当然会写当然也更好）。</p> \n <p>4. 学习使用新的工具</p> \n <p>工具对于自由UX设计师的重要性不言而喻。掌握更多的设计工具，只会事半功倍。最近进行的设计工具调查中表明Photoshop在设计师中正慢慢失宠,自由设计师更应该跟随潮流，学习新的设计工具和技术。从4000名来自近200个国家的受访者表明－设计师对新工具的态度是开放的，最重要的是工具能简化制作线框图、原型和设计的时间。</p> \n <p><a href=\"http://www.mockplus.cn/?hmsr=wen\" target=\"_blank\" rel=\"nofollow\">Mockplus</a>&nbsp;- 原型设计更快更简单。</p> \n <p><a href=\"https://www.goprospero.com/\" target=\"_blank\" rel=\"nofollow\">Prospero</a>&nbsp;- 专业的提案润色工具</p> \n <p><a href=\"https://www.usertesting.com/\" target=\"_blank\" rel=\"nofollow\">User Testing</a>&nbsp;- 记录用户如何与你的网站互动</p> \n <p>总结</p> \n <p>当自由UX设计师是一件很酷的事情，也希望你做决定时不是一时冲动，而是经过理性分析，权衡自由UX设计师和全职UX设计师各自的利弊，以及自己能得到什么。最终而做出的理智决定。</p> \n</div>',NULL,'2020-02-09 15:27:30',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226407480444157952',NULL,NULL,' 纸上原型设计 VS 桌面原型工具设计，你更喜欢谁？  ','<div class=\"content\" id=\"articleContent\"> \n <p>纸上原型设计，作为传统的原型设计方式，简单快速，成本低廉，为大部分设计师所喜爱。而桌面原型工具设计，作为伴随电脑科技发展而出现的原型设计方式，快速全面，高效保真，动效灵敏，专业优质，一经推出，就备受青睐，迅速在设计师群体之中普及。但作为网页或移动端应用UX/UI设计的你，更喜欢或更愿意使用他们中的哪一种来完成你的UX/UI设计呢？为方便大家选择，这里分别为设计师朋友们介绍两种原型设计方式的优缺点，希望对大家有所帮助：</p> \n <p><strong>首先，什么是纸上原型设计？</strong></p> \n <p>一般而言，纸上原型设计指的是UX/UI设计师们广泛采用的一种通过纸，笔，剪刀，便利贴之类办公用具来展示出设计理念的一种设计方式。换句话说，就是设计师们在纸上绘制出各种网页或手机端应用部件，（例如软件界面，按钮和各组件之类）完成原型设计，并检测其设计理念是否可行且适用的的一个过程。所以，从这当面而言，它也是设计师们创建原型，尽快获得真是用户或设计师关于设计实用性反馈的重要方式之一。</p> \n <p>&nbsp;<img alt=\"\" src=\"https://static.oschina.net/uploads/space/2018/0226/105535_i1rm_3519468.jpg\"></p> \n <p><strong>什么是桌面原型工工具设计？</strong></p> \n <p>而不同于纸上原型设计，桌面原型工具设计是一种基于桌面原型工具，实现网页或移动端软件应用原型设计的设计方式。而桌面原型工具是一种能够安装在电脑桌面上，帮助UX/UI&nbsp;设计师独自或以团队协作的方式创建和提升应用原型设计的设计工具。而且，通过优秀原型设计工具制作的软件原型一般细节详尽，交互灵敏且转化多样，能够更加全面的展现软件真实的界面和交互。因此，他们一般非常接近软件的最终产品，并且为设计师，产品经理和软件工程师研发出具有良好用户体验的网页或手机端软件应用发挥着重要作用。&nbsp;</p> \n <p>&nbsp;<img alt=\"\" src=\"https://static.oschina.net/uploads/space/2018/0226/105554_Cg4n_3519468.png\"></p> \n <p><strong>纸上原型设计</strong><strong>和桌面原型工具设计之间的区别有哪些？</strong></p> \n <p>事实上，在软件UX/UI设计方面，纸上原型设计和桌面原型设计都有其各自的优缺点。以下为方便大家区分和选择，对他们进行一个简单的比较：</p> \n <p><strong>1).&nbsp;</strong><strong>纸上原型设计的优点：</strong></p> \n <p><strong>*方便快速实现设计想法的更迭</strong></p> \n <p>作为以纸为基础的设计方式，纸上原型设计允许设计师简单的通过绘制新的组件，按钮和部件卡片快速的实现应用原型想法的更迭。哪里设计的不好，或是有全新的想法，重新绘制一张，然后无用或不好的设计稿直接扔进垃圾桶即可。方便快速，无需担忧。&nbsp;</p> \n <p><strong>*低成本，低投入</strong></p> \n <p>完成纸质原型所需的都是办公室随处可见的纸，笔，剪刀，便利贴之类的工具，&nbsp;成本低廉，投入低。</p> \n <p><strong>*易上手</strong></p> \n <p>完成纸上原型设计时，设计师只需要根据想法用画笔绘制出设计稿即可，无需使用其他复杂的工具。简单，易上手，且学习成本低。</p> \n <p><strong>纸上原型设计的缺点：</strong></p> \n <p><strong>*无法添加灵敏的交互和动画</strong></p> \n <p>尽管设计师们可以通过提前准备多样的原型按钮或部件卡片，实现纸质原型的“交互”。但这种交互也是非常有限的，而且在灵活度与可操作性上也是极差的。更不用说，纸上原型是完全不支持动画添加。</p> \n <p><strong>*不方便可行性测试</strong></p> \n <p>即使是添加了可活动的软件外框，表格及组件之类的部件，纸质原型能实现的可行性测试程度也是非常有限的。而且，来回的手动交换各种部件卡片，操作起来也不太方便。</p> \n <p><strong>*纸上原型并不能展现应用原型详尽细节</strong></p> \n <p>纸质原型通常需要设计师手绘原型部件，更多的是用来展现应用原型的大致流程，界面分布以及部分重要部件的设计等。所以，并不适合且不能完全的呈现软件所有细节。</p> \n <p><strong>*纸上绘图耗费大量的时间及精力</strong></p> \n <p>纸上绘制原型也是需要花费一定的时间跟精力。</p> \n <p><strong>&nbsp;<img alt=\"\" src=\"https://static.oschina.net/uploads/space/2018/0226/105611_Vm6M_3519468.png\"></strong></p> \n <p><strong>2).&nbsp;</strong><strong>桌面原型工具设计的优点：</strong></p> \n <p><strong>*详细展现应用软件细节</strong></p> \n <p>现今科技时代，大多优秀的桌面原型工具都自带强大的组件库和图标库，方便UX/UI设计师直接拖取所需应用原型组件和图片，展现软件详尽细节。例如，以下将要介绍的Mockplus,就封装了超过200个组件和3000个图标，能够满足用户设计各类软件所需的所有组件和图标需求。</p> \n <p>*<strong>快速添加个各式交互，动画和转化</strong></p> \n <p>与纸上原型不同，桌面原型工具允许设计师直接给网页或移动端应用原型添加各式交互，动画以及转化，是原型更加直观生动，也更接近软件最终成品。</p> \n <p><strong>*方便软件可行性和实用性测试</strong></p> \n <p>由于桌面原型工具创建的软件应用原型一般具有丰富的动效和细节，常常被设计师们用来测试其软件原型方案的可行性和实用性。而且，因为它们非常接近软件的最终效果，也时常被设计师们用作软件的最总设计方案，以便能够尽快获得真正用户或设计师的反馈。</p> \n <p><strong>*简单实现原型预览，云端同步和分享</strong></p> \n <p>现今，很多好用的桌面原型工具都自带原型项目预览，云端同步和分享的功能，方便设计师或产品经理共享原型资源和设计。</p> \n <p><strong>*实现团队协作</strong></p> \n <p>桌面原型工具同时也能够帮助设计师实现团队协作，共同编辑和提升某个团队原型项目。</p> \n <p><strong>桌面原型工具设计的缺点：</strong></p> \n <p><strong>*需要一定的时间学习原型工具</strong></p> \n <p>作为众多电脑桌面工具的一种，原型工具的使用也是需要设计师花费一定的时间学习。并不能入纸上原型设计般简单易上手。</p> \n <p><strong>*成本和投入相对更高</strong></p> \n <p>相较于纸上原型设计只需投入一些价格低廉的纸，笔，剪刀之类的办公工具，原型工具设计一般需要设计师购买原型设计工具。所以，相对而言需要的成本和投入会更高。</p> \n <p><strong>3).&nbsp;究竟该使用哪一种方式才能更好的完成原型设计呢？</strong></p> \n <p>事实上，我更赞成两种方式都使用，才能创建更加优秀的应用原型。例如，在原型设计初期，快速简洁的纸上原型方式，更易于设计师们尽快的锤炼和更迭其设计想法。然后，当想法更加成熟，并与相关设计师或产品经理讨论完善之后，使用更加全面的桌面原型工具设计，更易于设计师创建和呈现一个专业，高保真，动效丰富，界面美观的网站或移动端应用原型。</p> \n <p>当然，如果你认为制作纸上原型麻烦或者不太喜欢手绘完成原型设计，你也可以直接选择使用桌面原型工具进行设计。</p> \n <p>重要的是要选择一款有用且适合你的桌面原型工具。</p> \n <p><strong>哪些优秀的免费原型工具值得一试？</strong></p> \n <p>在详细了解了纸上原型设计和桌面原型工具之间的区别之后，忍不住想要试试桌面原型工具？这里罗列两款好用的免费原型工具：</p> \n <p><strong>1).&nbsp;<a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\"><em>Mockplus</em></a></strong></p> \n <p>支持平台：Windows&nbsp;和Mac OS</p> \n <p>Mockplus是一款免费，简单快速的桌面原型工具。它为设计师用户提供了很多强大的功能：</p> \n <p><strong>*它是一款简单快速且以用户为中心的原型工具</strong></p> \n <p>为满足设计师（无论是刚入行的设计新手，还是入行多年的专家）用户的各种UI/UX设计需求，Mockplus针对工具的每项操作，按钮，选项和功能的设计都做到尽可能的简洁快速。例如，使用Mockplus制作软件原型的过程中，设计师和产品经理可以一键快速创建，删除，保存，云端同步，预览和分享个人或团队项目。并且通过简单拖拽，实现组件之间，组件与网页之间以及网页之间的灵活交互。</p> \n <p><strong>*封装了强大的组件和图标库</strong></p> \n <p>Mockplus提供了超过200个组件和3000个图标库，方便用户简单拖拽添加软件原型部件。</p> \n <p><strong>*提供了8种原型预览和分享方式</strong></p> \n <p>为方便设计师分预览和分享各种原型项目，Mockplus提供了8种预览和分享方式。例如，直接导出原型图片预览，导出演示包预览，导出HTML预览，直接导出项目树预览以及快速扫码预览等。</p> \n <p><strong>*支持团队协作</strong></p> \n <p>Mockplus允许多个设计师<a href=\"http://doc.mockplus.cn/?p=2631\" target=\"_blank\" rel=\"nofollow\">创建团队项目</a>，共同编辑和提升同一原型项目。参与团队项目的设计师也可以审阅，评论并且为团队项目添加批注等。</p> \n <p><strong>*提供多样的项目例子和模板支持</strong></p> \n <p>Mockplus为设计师们封装了大量的项目例子和模板，方便设计师们直接导入，编辑， 创建新的应用原型。</p> \n <p><strong>*实现批量复制</strong></p> \n <p>其全新的各自功能允许设计师直接批量复制所需组件或部件组。</p> \n <p><strong>*支持图片及文本的自动填充</strong></p> \n <p>Mockplus提供的自动填充功能，支持文本和图片的批量填充。</p> \n <p><strong>*低学习成本，十分钟即可玩转Mockplus</strong></p> \n <p>作为一款简单快速的原型工具，Mockplus也是诸多原型软件中学习成本最低的，<a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\">十分钟就能玩转Mockplus</a>。</p> \n <p>总之，无论你是需要创建那种类型的应用原型，简单，快速且全面的Mockplus都能满足你的需求。</p> \n <p><img alt=\"\" src=\"https://static.oschina.net/uploads/space/2018/0226/105646_NKtF_3519468.png\"></p> \n <p><strong>2).&nbsp;<a href=\"https://balsamiq.com/\" target=\"_blank\" rel=\"nofollow\"><em>Balsamiq</em></a></strong></p> \n <p>支持平台：Windows&nbsp;和Mac OS</p> \n <p>Balsamiq是一款简洁的线框原型工具，具有独特的手绘风格。它旨在为设计师们提供一种直接用铅笔在纸上绘制原型的体验。所以，深受一些喜爱手绘原型的设计师喜爱。而且，Balsamiq也支持线框项目的在线团队协作。</p> \n <p>所以，如果你喜欢用铅笔手绘各种线框原型或需要在线共同协作完成线框原型，balsamiq会是不错的选择。</p> \n <p><img alt=\"\" src=\"https://static.oschina.net/uploads/space/2018/0226/105712_G4hv_3519468.png\"></p> \n <p><strong>&nbsp;</strong></p> \n <p><strong>结语：</strong></p> \n <p>网页或移动端软件原型设计方式多种多样，无论是纸上原型设计还是桌面原型工具设计，真正适合你的才是最有用的。所以，你需要根据自身的设计需求选择对应的设计方式。例如，如果你只是希望选择一种能够帮助你快速更迭原型设计想法的设计方式，纸上原型会是不错的选择。如果你是希望选择一种能够快速呈现想法，并将其转化成高保真，动效丰富，且专业美观的原型，类似简单快速的<a href=\"https://www.mockplus.cn/?hmsr=twx\" target=\"_blank\" rel=\"nofollow\"><em>Mockplus</em></a>之类的桌面原型工具会是很好的选择。</p> \n</div>',NULL,'2020-02-09 15:28:24',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226407704357076992',NULL,NULL,' 让你不再恋家的9款小众时尚的酒店网站设计  ','<div class=\"content\" id=\"articleContent\"> \n <p>一场说走就走的旅行少不了一家精挑细选的酒店。出门在外，没有一个舒适的住处，恐怕旅行的记忆也并不是那么美好。大牌酒店住不起，小众酒店性价比高，但哪家最合适？网上攻略必不可少。</p> \n <p>作为主观性非常强的视觉性动物，选择酒店的时候除了看价格，当然也会更看重酒店的网页设计风格。如果酒店的网站设计都乱糟糟，那酒店自身可想而知。作为提升酒店形象的门户，酒店网站设计一定不能马虎。</p> \n <p>如何设计具有现代感的酒店网站？个人分析可以从以下几点要素出发：</p> \n <p>1.&nbsp;响应式设计：网站必须支持跨设备浏览。</p> \n <p>2.&nbsp;卓越的用户体验：简化的网站浏览流程可以带来很好的用户体验。因为如果难以找到常见的页面或到达预订页面完成购买，很可能就会导致用户的流失。</p> \n <p>3.&nbsp;讲故事：你的网站是否了解一旦客人入住酒店会怎样？它是否可以为接下来的行程做指引？</p> \n <p>4.&nbsp;便捷预定：尽可能简化预订过程以获得最大回报。繁琐的用户信息和付款信息填写都有可能造成用户的流失。</p> \n <p>5.&nbsp;视觉逼真：最好和最有效的网站是吸引访问者花时间探索的网站。专业摄影和视频都是讲故事的绝佳媒介，尤其是对于酒店和度假村。</p> \n <p><strong>9款优秀的小众酒店网站设计</strong></p> \n <p>1.&nbsp;<a href=\"http://www.risveglio-akasaka.com/\" target=\"_blank\" rel=\"nofollow\">赤坂觉醒酒店</a></p> \n <p>酒店所在地：日本</p> \n <p>网站设计特色：动态天气图标&nbsp;，酒店内部背景图</p> \n <p>Hotel Risveglio Akasaka酒店是一家2015年开业的酒店，据住过的用户反馈是一家处处体现设计感的酒店。无论是酒店房间的设计还是酒店大厅的设计都赢得用户的好评。</p> \n <p>网站整体UI设计简洁，明了。网站首页以酒店内部装修图片作为背景。配上简洁的字体和图标，整个界面干净典雅。</p> \n <p>轮播图的展现方式给用户提供了多维度的空间体验感，黑白灰的建筑设计和恰到好处的灯光，舒适又不单调。城市和天气的设计非常的贴心，滚动导航自然引导用户到预订页面，提高网页会话率和订购量。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/8zdo1nwjzv.png?imageView2/0/w/1620\"></p> \n <p>2.&nbsp;<a href=\"http://www.casangelina.com/\" target=\"_blank\" rel=\"nofollow\">Casangelina</a></p> \n <p>酒店所在地：意大利</p> \n <p>网站设计特色：动态引导、背景音乐</p> \n <p>作为世界十大悬崖酒店之一的Casangelina酒店位于Amalfi海岸的悬崖上，客人可在酒店露台的全景室外游泳池放松身心，有摩洛哥风格的酒吧喝香槟，当然少不了私人厨房和管家服务，乘坐玻璃观景电梯下降200级台阶前往海滩，还能搭乘酒店的私人游船到其他岛屿晒太阳吃海鲜。</p> \n <p>网站UI设计仍以简洁风格为主，滚动区图片与字体的融合增强了网页浏览时的沉浸感。界面与用户体验设计融为一体。背景音乐和动态的酒店全景视频让你从它的网页设计就能感觉到整个酒店的优雅气息。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/rsx5ylbzof.png?imageView2/0/w/1620\"></p> \n <p>3.&nbsp;<a href=\"http://www.harbor-suites.com/\" target=\"_blank\" rel=\"nofollow\">Harbor Suites 酒店</a></p> \n <p>酒店所在地：希腊</p> \n <p>网站设计特色：响应式设计</p> \n <p>这个网站从它的网页导航图体现出这是一家为商务和休闲旅游游客而设计的酒店。优越的地理位置为商务人群或休闲游客都提供了极大的便利。</p> \n <p>网站的响应式布局为其一大特色。重要信息的展示如在线预订，房间预览和网站导航都在视觉的正中心和视觉焦点处，可以引导用户方便快速的打开网页。</p> \n <p>循序渐进的页面动画和卡片式信息展示增加了用户对该酒店特色的了解，网页资料展示非常丰富。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/g58jr3j9mr.png?imageView2/0/w/1620\"></p> \n <p>4.&nbsp;<a href=\"https://nisekohakuunso.com/ja/\" target=\"_blank\" rel=\"nofollow\">NISEKO HAKUUNSO</a></p> \n <p>酒店所在地：日本</p> \n <p>网站设计特色：季节性UI设计</p> \n <p>这个网站以冬夏为主题展示了不同季节里酒店的外部环境特色。默认的冬季主题以飘动的雪花和远处的富士山为背景，与酒店的“白云”主题呼应。虽然雪花的动态UI设计很吸引眼球，但也并不妨碍用户注意到深色背景上的白色导航栏。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/hub70bqdba.png?imageView2/0/w/1620\"></p> \n <p>5.&nbsp;<a href=\"https://www.swissotel.com/\" target=\"_blank\" rel=\"nofollow\">Swissotel</a></p> \n <p>酒店所在国家：瑞士</p> \n <p>网站设计特色：Banner横幅</p> \n <p>Swissotel是一个国际连锁酒店，白色背景加上深色色调，banner横幅整齐分隔，使得网站整体看起来非常整洁干净的感觉。CTA位置的留白使得你的网页布局有明显的对比，也适合用户的阅读习惯。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/v23al74vyf.png?imageView2/0/w/1620\"></p> \n <p>其他度假酒店网站设计：</p> \n <p>6. <a href=\"https://www.stmoritz.ch/\" target=\"_blank\" rel=\"nofollow\">圣莫里兹-世界之顶</a></p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/2sh2c7tcok.png?imageView2/0/w/1620\"></p> \n <p>7.&nbsp;<a href=\"http://www.carrier.co.uk/\" target=\"_blank\" rel=\"nofollow\">Carrier豪华定制假期</a></p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/olcryhduk6.png?imageView2/0/w/1620\"></p> \n <p>8.&nbsp;<a href=\"http://www.weslacotx.gov/\" target=\"_blank\" rel=\"nofollow\">德克萨斯州城市Weslaco网站</a></p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/p3jb739txf.png?imageView2/0/w/1620\"></p> \n <p>9.&nbsp;<a href=\"https://greenforest.com.mx/\" target=\"_blank\" rel=\"nofollow\">Ruta a la Aventura</a>- 绿色森林探险游网站</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/08sobaqytq.png?imageView2/0/w/1620\"></p> \n <p>一个酒店网站设计的成型一般会经历非常多的设计流程。从原型设计开始就奠定了整个网站的页面布局和排版。好用的工具将会助你事半功倍。我将以<a href=\"http://www.mockplus.cn/?hmsr=wen\" target=\"_blank\" rel=\"nofollow\">Mockplus</a>制作的网站原型设计为例，带你领略这款快速原型设计工具的魅力。</p> \n <p><strong>如何使用Mockplus设计属于您自己的酒店网站原型呢？</strong></p> \n <p>首先，我们需要总结以上9款小众酒店网站设计的5大共同点：</p> \n <ul> \n  <li>大图片背景</li> \n  <li>酒店名称或酒店主题Logo居中显示</li> \n  <li>导航栏信息靠网站边缘显示</li> \n  <li>辅助特色功能性图标展示</li> \n  <li>辅助GIF动态图片展示。</li> \n </ul> \n <p>总结出这些共同点之后，我们就可以开始着手使用Mockplus进行酒店或者其他类型的<strong>网站原型设计</strong>的创作了。如果你是个人用户，喜欢自由快速的原型设计，不受其他成员的干扰，可以选择使用Mockplus个人版。如果你是5人左右的小团队，需要团队协作和项目管理，可以使用Mockplus3.3的团队版功能。（<a href=\"https://www.mockplus.cn/newfeatures/post/881\" target=\"_blank\" rel=\"nofollow\">Mockplus3.3上新，免费体验团队管理和所有专业版功能！</a>）</p> \n <p>好了，废话不多说，开始准备你的网站原型设计吧。账号软件什么的自己去准备哈。（有的直接登录，没有的可以去官网<a href=\"https://www.mockplus.cn/user/register\" target=\"_blank\" rel=\"nofollow\">免费申请</a>。</p> \n <p>第一步，打开软件选择建立网页项目。</p> \n <p>第二步,熟悉软件界面：</p> \n <p>左侧从上到下依次为常用工具菜单栏，隐藏项目树，图标、组件库以及其细分栏目。</p> \n <p>中间为原型设计操作界面</p> \n <p>右侧为组件属性面板、交互参数属性面板以及页面属性面板。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/vj1k9p013v.png?imageView2/0/w/1620\"></p> \n <p>第三步：使用“图片”组件导入logo图片以及大张页面图片做网页背景图</p> \n <p>第四步：使用Mockplus快速功能：<a href=\"https://www.mockplus.cn/newfeatures/post/626\" target=\"_blank\" rel=\"nofollow\">格子和自动填充</a>功能快速制作相似格式的页面内容。&nbsp;</p> \n <p><a href=\"https://www.mockplus.cn/newfeatures/post/859\" target=\"_blank\" rel=\"nofollow\">组件样式功能</a>同时为多个同类型的组件进行样式设置，省时又便捷。</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/37mdd57enj.png?imageView2/0/w/1620\"></p> \n <p>第五步：添加交互：页面与页面间的跳转交互，或组件与组件间的交互。（<a href=\"http://doc.mockplus.cn/?p=1584\" target=\"_blank\" rel=\"nofollow\">如何在Mockplus中设置交互</a>）</p> \n <p>&nbsp;</p> \n <p><img src=\"https://ask.qcloudimg.com/draft/1341340/qe37zmuylh.png?imageView2/0/w/1620\"></p> \n <p>第六步：点击F5实时预览或导出演示包预览。</p> \n <p><strong>总结：</strong></p> \n <p><a href=\"http://www.mockplus.cn/?hmsr=wen\" target=\"_blank\" rel=\"nofollow\"><strong>Mockplus</strong></a>中还有许多有用的功能可以帮助你进行快速的网站原型设计或手机应用原型设计。以上的9款酒店网站设计案例也是相当不错的。闲暇时间，可以一边参考案例，一边利用Mockplus进行实例模拟，自己动手设计一个属于自己的酒店网站或者其他类型的网站。对于提升自己的设计水准和快速捕捉设计灵感也是一件非常不错的事。</p> \n</div>',NULL,'2020-02-09 15:29:17',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226407926470639616',NULL,NULL,' eclipse激活profile  ','<div class=\"content\" id=\"articleContent\"> \n <p>How to activate maven profile inside eclipse</p> \n <p>Normally maven is use for project dependency management and lifecycle, so there are several developers working on it. Each has its own development environment either in windows, linux or mac. To do this we create several profiles for each developer in pom.xml.</p> \n <p> &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;windows&lt;/id&gt; &lt;properties&gt; &lt;jboss.home&gt;C:/manaty/jboss-4.2.3.GA&lt;/jboss.home&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;linux&lt;/id&gt; &lt;properties&gt; &lt;jboss.home&gt;/home/project/jboss-4.2.3.GA&lt;/jboss.home&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt;</p> \n <p>And then invoke mvn with the -P argument. Example:</p> \n <p>mvn install -Pwindows mvn install -Plinux</p> \n <p>How could we do the same inside eclipse. There are 2 ways: 1.) Right click on the project-&gt;click properties-&gt;select maven menu</p> \n <p><img src=\"https://static.oschina.net/uploads/img/201701/09180406_tAB6.png\" alt=\"输入图片说明\" title=\"在这里输入图片标题\"></p> \n <p>If in case maven is not present, right click on project-&gt;Maven-&gt;Enable Maven Dependency 2.) Right click on project-&gt;Run As-&gt;Run Configurations-&gt;Maven Build-&gt;Add a new build (set profile and goal)</p> \n <p><img src=\"https://static.oschina.net/uploads/img/201701/09180633_j8iq.png\" alt=\"输入图片说明\" title=\"在这里输入图片标题\"></p> \n</div>',NULL,'2020-02-09 15:30:10',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226408149297233920',NULL,NULL,' eclise内存溢出解决  ','<div class=\"content\" id=\"articleContent\"> \n <p>Eclipse里启动Tomcat，配置内存大小</p> \n <p>2009年12月11日 星期五 10:50</p> \n <p>一般安装完eclipse之后，在安装目录下你应该可以看到有一个<span style=\"color: #ff0000;\">&nbsp;eclipse.ini</span>&nbsp;文件，对了，就是在这个文件里面修改，我打开同事机器上这个文件，里面的内容是：</p> \n <p><span style=\"color: #ff0000;\">-vmargs<br>-Dosgi.splashLocation=d:\\Program Files\\MyEclipse 5.5.1 GA\\eclipse\\MyEclipseSplash.bmp</span></p> \n <p><span style=\"color: #ff0000;\">-Dosgi.splashLocation=d:\\Program Files\\MyEclipse 5.1.1 GA\\eclipse\\MyEclipseSplash.bmp<br><br>-Xms64M&nbsp;<br>-Xmx128M</span></p> \n <p>呵呵，2G内存的机器，给eclipse这么点内存。。。介绍下参数的意思：</p> \n <p>-vmargs：说明后面是VM的参数</p> \n <p>-Dosgi.splashLocation：表示启动eclipse时你看到的界面（不知道他这里面怎么冒出了二句相同的）</p> \n <p>-Xms64M ：虚拟机占用系统的最小内存</p> \n <p>-Xmx128M：虚拟机占用系统的最大内存</p> \n <p>最后我把最大最小内存设置了下：</p> \n <p>设置为：</p> \n <p><span style=\"color: #ff0000;\">-Xms128M&nbsp;<br>-Xmx512M</span></p> \n <p>够用了，呵呵。</p> \n <p>还可以在这里面加一些参数，如：</p> \n <p>-XX:PermSize：最小堆大小。一般报内存不足时,都是说这个太小,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆空间剩余小于5%就会警告,建议把这个稍微设大一点,视自己机器内存大小来设置<br>-XX:MaxPermSize：最大堆大小。这个也适当大些<br>-Xmx512M的5%为25.6M，理论上要求-Xmx的数值与-XX:MaxPermSize必须大于25.6M</p> \n <ul> \n  <li><p><img src=\"http://static.oschina.net/uploads/img/201604/06190617_FFQO.jpg\" alt=\"\" height=\"214\" width=\"394\"></p><p><img src=\"http://static.oschina.net/uploads/img/201604/06190617_CxEL.jpg\" alt=\"\" height=\"192\" width=\"255\"></p><p><img src=\"http://static.oschina.net/uploads/img/201604/06190617_c6NJ.jpg\" alt=\"\" height=\"556\" width=\"671\"></p><p><img src=\"http://static.oschina.net/uploads/img/201604/06190618_MOsm.jpg\" alt=\"\" height=\"675\" width=\"776\"></p><p><br><a href=\"http://photo.blog.sina.com.cn/showpic.html#blogid=5f9d7ec40100dpjs&amp;url=http://static2.photo.sina.com.cn/orignal/5f9d7ec4t6c092e230261&amp;690\" target=\"_blank\" rel=\"nofollow\"><br></a></p><p>一般都是内存配置问题，&nbsp;<br>可以在Eclipse快捷上点右键，选属性，在目标中文字后加入一串参数:&nbsp;<br>-vmargs&nbsp;&nbsp; -Xms128M&nbsp;&nbsp; -Xmx256M&nbsp;&nbsp; -XX:PermSize=64M&nbsp;&nbsp; -XX:MaxPermSize=512M</p><p>&nbsp;</p><p>.昨天晚上通宵做毕业设计，没想到eclipse3.22总是说less than 5% of 64M,过不了几分钟就自动关闭。越急就越出问题，改了eclipse.ini 文件全部增加一倍还是不行，弄不好这个不能干活啊。</p><p>解决办法：快捷图标上-属性-目标后加上：<span style=\"font-family: 宋体;\">-XX:PermSize=64m -XX:MaxPermSize=128m</span></p><p>　重启动eclipse,搞定！</p><p>&lt;Eclipse_Home&gt;下面有一个eclipse.ini文件可以调整Eclipse最大使用内存，默认如下<br>-vmargs<br>-Xms40m<br>-Xmx256m<br><br><br>调整为：<br>-vmargs<br>-Xms40m<br>-Xmx256m<br>-XX:PermSize=64M<br>-XX:MaxPermSize=128M<br><br>1g内存推荐为：<br>-vmargs<br>-Xms128M<br>-Xmx512M<br>-XX:PermSize=64M<br>-XX:MaxPermSize=128M</p><p>&nbsp;</p><p>对于MyEclipse的话，直接修改MyEclipse在桌面的快捷方式的参数就可以啦。现在解释这些参数的意思。</p><p>-vmargs：说明后面是VM的参数<br>-Xms40m：虚拟机占用系统的最小内存<br>-Xmx256m：虚拟机占用系统的最大内存<br>-XX:PermSize：最小堆大小。一般报内存不足时,都是说这个太小,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆空间剩余小于5%就会警告,建议把这个稍微设<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 大一点,不过要视自己机器内存大小来设置<br>-XX:MaxPermSize：最大堆大小。这个也适当大些<br>-Xmx512M的5%为25.6M，理论上要求-Xmx的数值与-XX:MaxPermSize必须大于25.6M</p><p>把里面的参数改为<br>-vmargs&nbsp;<br>-Xms128M&nbsp;<br>-Xmx512M&nbsp;<br>-XX:PermSize=128M&nbsp;<br>-XX:MaxPermSize=256M</p><p>所以对于我而言，我只要把我的MyEclipse5.0改-XX:PermSize=128M-XX:MaxPermSize=256M，问题解决</p></li> \n </ul> \n <p><br></p> \n</div>',NULL,'2020-02-09 15:31:03',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226408370676793344',NULL,NULL,' 社区攻略转贴第五弹 | 创新开源自主可控云计算架构？这说的不是ZStack么？  ','<div class=\"content\" id=\"articleContent\"> \n <p style=\"text-align:center\">&nbsp;</p> \n <p style=\"text-align:justify\">前两天在github上hang out，看到有个人在说国内云计算现在架构都是基于国外某开源？我怎么突然蒙蔽了呢？那把ZStack置于何地呢？<strong>ZStack</strong>不<strong>就是全国产自研、自主创新、安全可控的云计算架构</strong>么？知识产权也是他们自己的吧。我觉得像这种国产自研的架构是没有国外的名声大，但使用起来未必比别的差，我研究ZStack也有一段时间了，欢迎各位对<strong>国产自研架构</strong>感兴趣的朋友和我交流，接下来是我的一些分享。</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\">ZStack官网上就可以下载到安装包，这是楼主费心搜罗来的ZStack近期发布的所有版本下载地址。这里都有汇总到，参考价值非常大，值得收藏。对了，社区版那个可以免费申请下载，提供基础的计算、网络、存储等IaaS软件的功能。如果是在正式生产环境中使用，需要下载ZStack企业版。</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\"><strong>1．ZStack全线产品汇总：</strong></p> \n <p style=\"text-align:justify\">社区版（免费）：https://www.zstack.io/product/zstack_open_source/</p> \n <p style=\"text-align:justify\">企业版下载：https://www.zstack.io/product/zstack_enterprise/#</p> \n <p style=\"text-align:justify\">混合云版：https://www.zstack.io/product/zstack_hybrid/</p> \n <p style=\"text-align:justify\">分布式存储：https://www.zstack.io/product/zstack_ceph/</p> \n <p style=\"text-align:justify\">ZStack Mini超融合一体机：https://www.zstack.io/product/zstack_mini/</p> \n <p style=\"text-align:justify\">ZStack CMP多云管理平台：https://www.zstack.io/product/zstack_cmp/</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\"><strong>2．要看不同版本的对比戳这里：</strong></p> \n <p style=\"text-align:justify\">版本对比：https://www.zstack.io/product/portfolio_comparison/</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\"><strong>3．最新版本特性看这里：</strong></p> \n <p style=\"text-align:justify\">差不多是一个半左右更新一次版本，这是3.5.0版本的特性：</p> \n <p style=\"text-align:justify\"><a href=\"https://www.zstack.io/help/release_notes/\" rel=\"nofollow\">https://www.zstack.io/help/release_notes/</a></p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\"><strong>4．产品Demo演示看这里：</strong></p> \n <p style=\"text-align:justify\">ZStack Mini &amp; ZStack CMP Demo：https://www.zstack.io/aboutus/conference/2019/</p> \n <p style=\"text-align:justify\">混合云+SD-WAN Demo：https://www.zstack.io/aboutus/conference/2018/</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\">今天就是突然觉得身为圈内的人不知道国内有自研可控的架构有点生气也有点无奈，的确近些年国外开源已经成为市场上的大多数选择，但是我们自己研究的架构更需要经过我们的不断研究测试才能使它更完善。</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\"><strong>ZStack架构也是开源的，开发者们可以去github上贡献一下</strong>：<a href=\"https://github.com/zstackio/zstack\" rel=\"nofollow\">https://github.com/zstackio/zstack</a></p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\">最后附一个<strong>产品手册</strong>：<a href=\"https://www.zstack.io/help/product_manuals/\" rel=\"nofollow\">https://www.zstack.io/help/product_manuals/</a></p> \n <p style=\"text-align:justify\">有需要的朋友自行下载学习，还有需要其他资料的也可以联系我，有的我都会分享出来。</p> \n <p style=\"text-align:justify\">&nbsp;</p> \n <p style=\"text-align:justify\">以上是一些简单的产品介绍和演示视频，欢迎感兴趣的小伙伴与我交流，后续我也会更新更多相关资料的。如果企业对他们产品感兴趣的话可以搜一下ZStack的官网，下面应该有商务电话可以咨询。</p> \n <div> \n  <div> \n   <p>&nbsp;</p> \n  </div> \n </div> \n</div>',NULL,'2020-02-09 15:31:56',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226408592194764800',NULL,NULL,' Oracle DBA必备：Oracle高级管理教程和排错、优化文档  ','<div class=\"content\" id=\"articleContent\"> \n <div class=\"Section0\"> \n  <p><span style=\"font-family:\'宋体\';font-size:16pt;font-weight:bold;mso-spacerun:\'yes\';\">Oracle&nbsp;DBA<span style=\"font-family:宋体;\">必备：</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">高级管理教程和排错、优化文档</span></span><span style=\"font-family:\'宋体\';font-size:16pt;font-weight:bold;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\">我们经常发现这样一种情况，我们在大学里所学的数据库那点东西，到了实际工作里往往让我们手足无措。看似简单的数据库却成了我们工作、学习最大的障碍。现在好了，小弟我为大家准备了一些</span><span style=\"font-family:\'Batang\';font-size:10.5pt;mso-spacerun:\'yes\';\">Oracle</span><span style=\"font-family:\'宋体\';font-size:10.5pt;mso-spacerun:\'yes\';\">的更实际的日常应用技巧和更加深入的教程。无论浏览这篇文章的你，是正在学校学习的小白还是已经工作的职场新人。都可以在这里找到适合你的内容：</span><span style=\"font-family:\'宋体\';font-size:10.5pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span><a href=\"http://down.51cto.com/zt/1469\" rel=\"nofollow\"><span style=\"font-family:\'宋体\';color:#0000ff;font-size:10pt;text-decoration:underline;mso-spacerun:\'yes\';\">Oracle&nbsp;VM<span style=\"font-family:宋体;\">教程和方案汇总</span></span></a></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\">本专题收集了<span style=\"font-family:Batang;\">Oracle&nbsp;VM</span><span style=\"font-family:宋体;\">相关资料：</span><span style=\"font-family:Batang;\">Oracle&nbsp;VM</span><span style=\"font-family:宋体;\">介绍、安装教程、解决方案等等。帮助大家搭建、管理</span><span style=\"font-family:Batang;\">Oracle&nbsp;VM</span><span style=\"font-family:宋体;\">，希望大家喜欢。&nbsp;</span></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span><a href=\"http://down.51cto.com/zt/1032\" rel=\"nofollow\"><span style=\"font-family:\'宋体\';color:#0000ff;font-size:10pt;text-decoration:underline;mso-spacerun:\'yes\';\">DBA<span style=\"font-family:宋体;\">必备宝典：</span><span style=\"font-family:\'Times New Roman\';\">Oracle</span><span style=\"font-family:宋体;\">高级管理文档汇总</span></span></a></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\">尽管数据库异军突起，但是在<span style=\"font-family:Batang;\">RDBMS</span><span style=\"font-family:宋体;\">领域</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">数据库依然傲视群雄。本专题提供的</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">数据库教程将由浅入深，全面讲解</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">数据库的性能优化、</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">数据库的容灾备份、</span><span style=\"font-family:Batang;\">Oracle&nbsp;DBA</span><span style=\"font-family:宋体;\">的日常工作。</span></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span><a href=\"http://down.51cto.com/zt/855\" rel=\"nofollow\"><span style=\"font-family:\'宋体\';color:#0000ff;font-size:10pt;text-decoration:underline;mso-spacerun:\'yes\';\">Oracle<span style=\"font-family:宋体;\">性能诊断及优化资料合集</span></span></a></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\">本专题收集了<span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">性能诊断和优化等高级管理相关的资料。内容有：</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">性能诊断艺术、&nbsp;</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">错误大全一览表、</span><span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">数据库</span><span style=\"font-family:Batang;\">RAC</span><span style=\"font-family:宋体;\">技术培训、</span><span style=\"font-family:Batang;\">orace</span><span style=\"font-family:宋体;\">性能优化高级培训、</span><span style=\"font-family:Batang;\">ORACLE</span><span style=\"font-family:宋体;\">系统权限分类等。</span></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span><a href=\"http://down.51cto.com/zt/799\" rel=\"nofollow\"><span style=\"font-family:\'宋体\';color:#0000ff;font-size:10pt;text-decoration:underline;mso-spacerun:\'yes\';\">Oracle<span style=\"font-family:宋体;\">使用疑难问题汇总</span></span></a></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\">本专题汇集了本人或其他论坛博客中总结的各类<span style=\"font-family:Batang;\">oracle</span><span style=\"font-family:宋体;\">疑难问题，都是一些很简单的解决方案，希望可以在大家遇到问题时给予一定的帮助，欢迎大家补充。</span></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span><a href=\"http://down.51cto.com/zt/91\" rel=\"nofollow\"><span style=\"font-family:\'宋体\';color:#0000ff;font-size:10pt;text-decoration:underline;mso-spacerun:\'yes\';\">Oracle<span style=\"font-family:宋体;\">数据库性能优化指南大全</span></span></a></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\">随着网络服务的不断发展，站点的访问量越来越大，如何使有限的计算机系统资源为更多的用户服务？如何保证用户的响应速度和服务质量？本专题就囊括了<span style=\"font-family:Batang;\">Oracle</span><span style=\"font-family:宋体;\">优化的各类方案，为您解决后顾之忧。</span></span><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n  <p><span style=\"font-family:\'宋体\';font-size:12pt;mso-spacerun:\'yes\';\"></span></p> \n </div> \n</div>',NULL,'2020-02-09 15:32:49',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226408815671476224',NULL,NULL,' 如何保证网站的安全架构，不被黑客攻击  ','<div class=\"content\" id=\"articleContent\"> \n <span id=\"OSC_h2_1\"></span> \n <h2>1. 网站安全的攻与防</h2> \n <p>互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：</p> \n <span id=\"OSC_h3_2\"></span> \n <h3>1.1. 跨站脚本攻击（XSS）</h3> \n <span id=\"OSC_h4_3\"></span> \n <h4>概念</h4> \n <p>跨站脚本攻击（Cross-Site Scripting, XSS），是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。</p> \n <p>XSS 攻击示例：</p> \n <p>假如有下面一个 textbox</p> \n <pre>&lt;input type=\"text\" name=\"address1\" value=\"value1from\"&gt;</pre> \n <p>value1from 是来自用户的输入，如果用户不是输入 value1from,而是输入&nbsp;<code>\"/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!-</code>那么就会变成：</p> \n <pre>&lt;input type=\"text\" name=\"address1\" value=\"\"/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;!- \"&gt;</pre> \n <p>嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。</p> \n <span id=\"OSC_h4_4\"></span> \n <h4>攻击手段和目的</h4> \n <p>常用的 XSS 攻击手段和目的有：</p> \n <ul> \n  <li>盗用 cookie，获取敏感信息。</li> \n  <li>利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li> \n  <li>利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li> \n  <li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li> \n  <li>在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。</li> \n </ul> \n <span id=\"OSC_h4_5\"></span> \n <h4>应对手段</h4> \n <ul> \n  <li><strong>过滤特殊字符</strong>&nbsp;- 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如&nbsp;<code>&gt;</code>&nbsp;转义为&nbsp;<code>&amp;gt</code>、<code>&lt;</code>&nbsp;转义为&nbsp;<code>&amp;lt</code>&nbsp;等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如&nbsp;<code>3&lt;5</code>&nbsp;中的&nbsp;<code>&lt;</code>&nbsp;需要进行文本匹配后再转移，如：<code>&lt;img src=</code>&nbsp;这样的上下文中的&nbsp;<code>&lt;</code>&nbsp;才转义。</li> \n  <li><strong>设置 Cookie 为 HttpOnly</strong>&nbsp;- 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</li> \n </ul> \n <span id=\"OSC_h3_6\"></span> \n <h3>1.2. 跨站请求伪造（CSRF）</h3> \n <span id=\"OSC_h4_7\"></span> \n <h4>概念</h4> \n <p>跨站请求伪造（Cross-site request forgery，CSRF），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p> \n <span id=\"OSC_h4_8\"></span> \n <h4>攻击手段和目的</h4> \n <p>可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。</p> \n <p>CSRF 能做的事太多：</p> \n <ul> \n  <li>以你名义发送邮件，发消息</li> \n  <li>用你的账号购买商品</li> \n  <li>用你的名义完成虚拟货币转账</li> \n  <li>泄露个人隐私</li> \n  <li>...</li> \n </ul> \n <span id=\"OSC_h4_9\"></span> \n <h4>应对手段</h4> \n <ul> \n  <li><strong>表单 Token</strong>&nbsp;- CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。</li> \n  <li><strong>验证码</strong>&nbsp;- 请求提交是，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。</li> \n  <li><strong>Referer check</strong>&nbsp;- HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。</li> \n </ul> \n <span id=\"OSC_h3_10\"></span> \n <h3>1.3. SQL 注入攻击</h3> \n <span id=\"OSC_h4_11\"></span> \n <h4>概念</h4> \n <p>SQL 注入攻击（SQL injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。</p> \n <p>攻击示例：</p> \n <p>考虑以下简单的登录表单：</p> \n <pre>&lt;form action=\"/login\" method=\"POST\"&gt;\r\n&lt;p&gt;Username: &lt;input type=\"text\" name=\"username\" /&gt;&lt;/p&gt;\r\n&lt;p&gt;Password: &lt;input type=\"password\" name=\"password\" /&gt;&lt;/p&gt;\r\n&lt;p&gt;&lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/p&gt;\r\n&lt;/form&gt;</pre> \n <p>我们的处理里面的 SQL 可能是这样的：</p> \n <pre>username:=r.Form.Get(\"username\")\r\npassword:=r.Form.Get(\"password\")\r\nsql:=\"SELECT * FROM user WHERE username=\'\"+username+\"\' AND password=\'\"+password+\"\'\"</pre> \n <p>如果用户的输入的用户名如下，密码任意</p> \n <pre>myuser\' or \'foo\' = \'foo\' --</pre> \n <p>那么我们的 SQL 变成了如下所示：</p> \n <pre>SELECT * FROM user WHERE username=\'myuser\' or \'foo\' = \'foo\' --\'\' AND password=\'xxx\'</pre> \n <p>在 SQL 里面&nbsp;<code>--</code>&nbsp;是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。</p> \n <p>对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。</p> \n <pre>sql:=\"SELECT * FROM products WHERE name LIKE \'%\"+prod+\"%\'\"\r\nDb.Exec(sql)</pre> \n <p>如果攻击提交&nbsp;<code>a%\' exec master..xp_cmdshell \'net user test testpass /ADD\' --</code>&nbsp;作为变量 prod 的值，那么 sql 将会变成</p> \n <pre>sql:=\"SELECT * FROM products WHERE name LIKE \'%a%\' exec master..xp_cmdshell \'net user test testpass /ADD\'--%\'\"</pre> \n <p>MSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。</p> \n <p>虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。</p> \n <span id=\"OSC_h4_12\"></span> \n <h4>攻击手段和目的</h4> \n <ul> \n  <li>数据表中的数据外泄，例如个人机密数据，账户数据，密码等。</li> \n  <li>数据结构被黑客探知，得以做进一步攻击（例如&nbsp;<code>SELECT * FROM sys.tables</code>）。</li> \n  <li>数据库服务器被攻击，系统管理员账户被窜改（例如&nbsp;<code>ALTER LOGIN sa WITH PASSWORD=\'xxxxxx\'</code>）。</li> \n  <li>获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。</li> \n  <li>经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell \"net stop iisadmin\"可停止服务器的 IIS 服务）。</li> \n  <li>破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell \"FORMAT C:\"）。</li> \n </ul> \n <span id=\"OSC_h4_13\"></span> \n <h4>应对手段</h4> \n <ul> \n  <li><strong>使用参数化查询</strong>&nbsp;- 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数&nbsp;<code>Prepare</code>&nbsp;和&nbsp;<code>Query</code>&nbsp;，或者&nbsp;<code>Exec(query string, args ...interface{})</code>。</li> \n  <li><strong>单引号转换</strong>&nbsp;- 在组合 SQL 字符串时，先针对所传入的参数作字符取代（将单引号字符取代为连续 2 个单引号字符）。</li> \n </ul> \n <span id=\"OSC_h3_14\"></span> \n <h3>1.4. 拒绝服务攻击（DoS）</h3> \n <p>拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p> \n <p>当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。</p> \n <span id=\"OSC_h4_15\"></span> \n <h4>攻击方式</h4> \n <ul> \n  <li>带宽消耗型攻击</li> \n  <li>资源消耗型攻击</li> \n </ul> \n <span id=\"OSC_h4_16\"></span> \n <h4>应对手段</h4> \n <ul> \n  <li>防火墙 - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。</li> \n  <li>路由器、交换机 - 具有速度限制和访问控制能力。</li> \n  <li>流量清洗 - 通过采用抗 DDoS 软件处理，将正常流量和恶意流量区分开。</li> \n </ul> \n <span id=\"OSC_h2_17\"></span> \n <h2>2. 加密技术及密钥安全管理</h2> \n <p>对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。</p> \n <p>信息加密技术一般分为：</p> \n <ul> \n  <li>消息摘要</li> \n  <li>加密算法 \n   <ul> \n    <li>对称加密</li> \n    <li>非对称加密</li> \n   </ul> </li> \n  <li>证书</li> \n </ul> \n <span id=\"OSC_h3_18\"></span> \n <h3>2.1. 消息摘要</h3> \n <p>常用数字签名算法：MD5、SHA 等。</p> \n <p>应用场景：将用户密码以消息摘要形式保存到数据库中。</p> \n <span id=\"OSC_h3_19\"></span> \n <h3>2.2. 加密算法</h3> \n <span id=\"OSC_h4_20\"></span> \n <h4>对称加密</h4> \n <p>对称加密指加密和解密所使用的密钥是同一个密钥。</p> \n <p>常用对称加密算法：DES 等。</p> \n <p>应用场景：Cookie 加密、通信机密等。</p> \n <span id=\"OSC_h4_21\"></span> \n <h4>非对称加密</h4> \n <p>非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。</p> \n <p>常用非对称加密算法：RSA 等。</p> \n <p>应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。</p> \n <span id=\"OSC_h4_22\"></span> \n <h4>2.3. 密钥安全管理</h4> \n <p>保证密钥安全的方法：</p> \n <ol> \n  <li>把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。</li> \n  <li>把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。</li> \n </ol> \n <span id=\"OSC_h3_23\"></span> \n <h3>2.3. 证书</h3> \n <p>证书可以称为信息安全加密的终极手段。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p> \n <p>透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。</p> \n <p>众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。</p> \n <span id=\"OSC_h4_24\"></span> \n <h4>概念</h4> \n <p>传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。</p> \n <span id=\"OSC_h4_25\"></span> \n <h4>证书原理</h4> \n <p>SSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p> \n <p>这里有两个问题：</p> \n <p>（1）<strong>如何保证公钥不被篡改？</strong></p> \n <p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p> \n <p>（2）<strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p> \n <p>解决方法：每一次对话（session），客户端和服务器端都生成一个\"对话密钥\"（session key），用它来加密信息。由于\"对话密钥\"是对称加密，所以运算速度非常快，而服务器公钥只用于加密\"对话密钥\"本身，这样就减少了加密运算的消耗时间。</p> \n <p>SSL/TLS 协议的基本过程是这样的：</p> \n <ol> \n  <li>客户端向服务器端索要并验证公钥。</li> \n  <li>双方协商生成\"对话密钥\"。</li> \n  <li>双方采用\"对话密钥\"进行加密通信。</li> \n </ol> \n <p><img alt=\"\" height=\"391\" src=\"https://oscimg.oschina.net/oscnet/60a931e94b6582c8fe906ddef486681a6c9.jpg\" width=\"1330\"></p> \n</div>',NULL,'2020-02-09 15:33:42',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226409037738901504',NULL,NULL,' java 中的static关键字  ','<div class=\"content\" id=\"articleContent\"> \n <p>1、<strong>方便在没有创建对象的情况下来进行调用（方法/变量）</strong></p> \n <ul> \n  <li>static方法就是没有this的方法</li> \n  <li>在static方法内部不能调用非静态方法，反过来是可以的</li> \n  <li>可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法（这实际上正是static方法的主要用途）</li> \n  <li>被static关键字修饰的方法或者变量，只要类被加载了，就可以通过类名去进行访问</li> \n  <li>可以编写static代码块来优化程序性能</li> \n </ul> \n <p>2、static方法</p> \n <ul> \n  <li>在静态方法中不能访问类的非静态成员变量和非静态成员方法</li> \n  <li>因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用</li> \n  <li>在非静态成员方法中是可以访问静态成员方法/变量的</li> \n </ul> \n <p>3、static变量</p> \n <ul> \n  <li>static成员变量的初始化顺序按照定义的顺序进行初始化</li> \n </ul> \n <p>4、static代码块</p> \n <ul> \n  <li>static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次</li> \n </ul> \n <p>5、<strong>构造器实际上不是静态方法</strong></p> \n <ul> \n  <li>在thinking in java中，第96页提到，“即使没有显示地使用static关键字，构造器实际上也是静态方法“</li> \n  <li>一篇大神的博客中得到了答案，那就是构造器不是静态方法</li> \n  <li>Java的实例构造器只负责初始化，不负责创建对象</li> \n  <li>new指令专门用于创建对象实例，而调用实例构造器则使用invokespecial指令</li> \n  <li>this是作为实例构造器的第一个实际参数传入的</li> \n  <li>静态方法中不能使用this，而构造器中可以使用this关键字</li> \n </ul> \n <p>6、Java中的static关键字不会影响到变量或者方法的作用域</p> \n <ul> \n  <li>Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字</li> \n </ul> \n <p>7、能通过this访问静态成员变量</p> \n <ul> \n  <li>this代表当前对象</li> \n  <li>static变量是被对象所享有的</li> \n </ul> \n <p>8、<strong>static是不允许用来修饰局部变量（Java语法的规定）</strong></p> \n <p><strong>9、静态内部类：</strong></p> \n <ul> \n  <li><strong>普通类是不允许声明为静态的，只有内部类才可以</strong></li> \n </ul> \n <p><img height=\"128\" src=\"https://oscimg.oschina.net/oscnet/f7337bdf07806225db9e22996b14e1de6dd.jpg\" width=\"643\"></p> \n <ul> \n  <li>要创建嵌套类的对象，并不需要其外围类的对象（<strong>但是还是会执行外部类的构造方法</strong>）</li> \n </ul> \n <p><img height=\"114\" src=\"https://oscimg.oschina.net/oscnet/699c19a322483cb953cdf688568eeac1ab3.jpg\" width=\"345\"></p> \n <ul> \n  <li><strong>内部静态类不需要有指向外部类的引用，但非静态内部类需要持有对外部类的引用</strong></li> \n  <li>非静态内部类能够访问外部类的静态和非静态成员，静态类不能访问外部类的非静态成员</li> \n </ul> \n <p>10、<strong>静态导入</strong></p> \n <ul> \n  <li>可以使被导入类的<strong>静态变量</strong>和<strong>静态方法</strong>在当前类<strong>直接可见，</strong>用这些静态成员无需再给出他们的类名</li> \n </ul> \n <p>　<strong>import static 包名.类名.静态成员变量;&nbsp;</strong></p> \n <p>　<strong>import static 包名.类名.静态成员函数;&nbsp;</strong></p> \n <p><img height=\"368\" src=\"https://oscimg.oschina.net/oscnet/6f42a1956908f1a9d0f85e3271eb7d2d935.jpg\" width=\"457\"></p> \n <p>11、代码执行结果&nbsp;</p> \n <pre><code class=\"language-java\">public class Test extends Base{\r\n \r\n    static{\r\n        System.out.println(\"test static\");\r\n    }\r\n     \r\n    public Test(){\r\n        System.out.println(\"test constructor\");\r\n    }\r\n     \r\n    public static void main(String[] args) {\r\n        new Test();\r\n    }\r\n}\r\n \r\nclass Base{\r\n     \r\n    static{\r\n        System.out.println(\"base static\");\r\n    }\r\n     \r\n    public Base(){\r\n        System.out.println(\"base constructor\");\r\n    }\r\n}</code></pre> \n <p><img height=\"106\" src=\"https://oscimg.oschina.net/oscnet/05b227d75a62948ce7546ec54205b967757.jpg\" width=\"206\"></p> \n <p>代码执行结果：</p> \n <ul> \n </ul> \n <pre><code class=\"language-java\">public class Test {\r\n    Person person = new Person(\"Test\");\r\n    static{\r\n        System.out.println(\"test static\");\r\n    }\r\n     \r\n    public Test() {\r\n        System.out.println(\"test constructor\");\r\n    }\r\n     \r\n    public static void main(String[] args) {\r\n        new MyClass();\r\n    }\r\n}\r\n \r\nclass Person{\r\n    static{\r\n        System.out.println(\"person static\");\r\n    }\r\n    public Person(String str) {\r\n        System.out.println(\"person \"+str);\r\n    }\r\n}\r\n \r\n \r\nclass MyClass extends Test {\r\n    Person person = new Person(\"MyClass\");\r\n    static{\r\n        System.out.println(\"myclass static\");\r\n    }\r\n     \r\n    public MyClass() {\r\n        System.out.println(\"myclass constructor\");\r\n    }\r\n}</code></pre> \n <ul> \n  <li>首先加载Test类，因此会执行Test类中的static块</li> \n  <li>main所在类会被优先加载</li> \n  <li>以类为标准进行加载，尽管在一个文件</li> \n  <li>接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类</li> \n  <li>加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类</li> \n  <li>就会执行MyClass类的中的static块</li> \n </ul> \n <p><img height=\"142\" src=\"https://oscimg.oschina.net/oscnet/094813ee8328c2a962ff542fc1f9e80becb.jpg\" width=\"218\"></p> \n <p>代码执行结果：</p> \n <pre><code class=\"language-java\">public class Test {\r\n     \r\n    static{\r\n        System.out.println(\"test static 1\");\r\n    }\r\n    public static void main(String[] args) {\r\n         \r\n    }\r\n     \r\n    static{\r\n        System.out.println(\"test static 2\");\r\n    }\r\n}</code></pre> \n <ul> \n  <li>static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行）</li> \n  <li>并且执行是按照static块的顺序执行的</li> \n </ul> \n <p><img height=\"71\" src=\"https://oscimg.oschina.net/oscnet/c8c0983fdf9314cd66a9141f7db69704738.jpg\" width=\"143\"></p> \n</div>',NULL,'2020-02-09 15:34:35',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226409260833931264',NULL,NULL,' java 中的CyclicBarrier  ','<div class=\"content\" id=\"articleContent\"> \n <p>CyclicBarrier是由ReentrantLock可重入锁和Condition共同实现的。</p> \n <ul> \n  <li>可循环（Cyclic）使用的屏障（Barrier）</li> \n  <li>实现原理： \n   <ul> \n    <li>在CyclicBarrier的内部定义了一个Lock对象，</li> \n    <li>每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1，</li> \n    <li>然后判断剩余拦截数是否为0， \n     <ul> \n      <li>如果不是，进入Lock对象的条件队列等待。</li> \n      <li>如果是，执行barrierAction对象的Runnable方法，</li> \n     </ul> </li> \n    <li>然后将锁的条件队列中的所有线程放入锁等待队列中，这些线程会依次的获取锁、释放锁，接着先从await方法返回，</li> \n    <li>再从CyclicBarrier的await方法中返回。</li> \n   </ul> </li> \n </ul> \n <p>================================================================</p> \n <p>1、回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行</p> \n <ul> \n  <li>第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务</li> \n  <li>第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务</li> \n </ul> \n <pre><code class=\"language-java\">public int await() throws InterruptedException, BrokenBarrierException { };\r\npublic int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException { };</code></pre> \n <p>2、举个栗子：</p> \n <pre><code class=\"language-java\">public class Test {\r\n&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int N = 4;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CyclicBarrier barrier&nbsp; = new CyclicBarrier(N);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int i=0;i&lt;N;i++)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Writer(barrier).start();\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;static class Writer extends Thread{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private CyclicBarrier cyclicBarrier;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Writer(CyclicBarrier cyclicBarrier) {\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.cyclicBarrier = cyclicBarrier;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void run() {\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(5000);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //以睡眠来模拟写入数据操作\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cyclicBarrier.await();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (InterruptedException e) {\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}catch(BrokenBarrierException e){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"所有线程写入完毕，继续处理其他任务...\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</code></pre> \n <ul> \n  <li>执行结果</li> \n </ul> \n <p><img height=\"209\" src=\"https://oscimg.oschina.net/oscnet/ee5982914b31e159b63e375ffa4e2a066d4.jpg\" width=\"436\"></p> \n <p>3、当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable</p> \n <pre><code class=\"language-java\">public class Test {\r\n    public static void main(String[] args) {\r\n        int N = 4;\r\n        CyclicBarrier barrier  = new CyclicBarrier(N,new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(\"当前线程\"+Thread.currentThread().getName());   \r\n            }\r\n        });\r\n \r\n        for(int i=0;i&lt;N;i++)\r\n            new Writer(barrier).start();\r\n    }\r\n    static class Writer extends Thread{\r\n        private CyclicBarrier cyclicBarrier;\r\n        public Writer(CyclicBarrier cyclicBarrier) {\r\n            this.cyclicBarrier = cyclicBarrier;\r\n        }\r\n \r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\");\r\n            try {\r\n                Thread.sleep(5000);      //以睡眠来模拟写入数据操作\r\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\");\r\n                cyclicBarrier.await();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }catch(BrokenBarrierException e){\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(\"所有线程写入完毕，继续处理其他任务...\");\r\n        }\r\n    }\r\n}</code></pre> \n <p><img height=\"218\" src=\"https://oscimg.oschina.net/oscnet/ae7081ccc8c690bc63856490fdfd5274dd6.jpg\" width=\"407\"></p> \n <p>4、故意让最后一个线程启动延迟</p> \n <ul> \n  <li>在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务</li> \n </ul> \n <pre><code class=\"language-java\">public class Test {\r\n    public static void main(String[] args) {\r\n        int N = 4;\r\n        CyclicBarrier barrier  = new CyclicBarrier(N);\r\n \r\n        for(int i=0;i&lt;N;i++) {\r\n            if(i&lt;N-1)\r\n                new Writer(barrier).start();\r\n            else {\r\n                try {\r\n                    Thread.sleep(5000);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                new Writer(barrier).start();\r\n            }\r\n        }\r\n    }\r\n    static class Writer extends Thread{\r\n        private CyclicBarrier cyclicBarrier;\r\n        public Writer(CyclicBarrier cyclicBarrier) {\r\n            this.cyclicBarrier = cyclicBarrier;\r\n        }\r\n \r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\");\r\n            try {\r\n                Thread.sleep(5000);      //以睡眠来模拟写入数据操作\r\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\");\r\n                try {\r\n                    cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);\r\n                } catch (TimeoutException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }catch(BrokenBarrierException e){\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(Thread.currentThread().getName()+\"所有线程写入完毕，继续处理其他任务...\");\r\n        }\r\n    }\r\n}</code></pre> \n <p><img height=\"411\" src=\"https://oscimg.oschina.net/oscnet/e6d4b9936c421476a7ef534e08232657d7d.jpg\" width=\"549\"></p> \n <p>5、CyclicBarrier是可以重用的</p> \n <ul> \n  <li>初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用</li> \n  <li>CountDownLatch无法进行重复使用</li> \n </ul> \n <pre><code class=\"language-java\">public class Test {\r\n    public static void main(String[] args) {\r\n        int N = 4;\r\n        CyclicBarrier barrier  = new CyclicBarrier(N);\r\n \r\n        for(int i=0;i&lt;N;i++) {\r\n            new Writer(barrier).start();\r\n        }\r\n \r\n        try {\r\n            Thread.sleep(25000);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n \r\n        System.out.println(\"CyclicBarrier重用\");\r\n \r\n        for(int i=0;i&lt;N;i++) {\r\n            new Writer(barrier).start();\r\n        }\r\n    }\r\n    static class Writer extends Thread{\r\n        private CyclicBarrier cyclicBarrier;\r\n        public Writer(CyclicBarrier cyclicBarrier) {\r\n            this.cyclicBarrier = cyclicBarrier;\r\n        }\r\n \r\n        @Override\r\n        public void run() {\r\n            System.out.println(\"线程\"+Thread.currentThread().getName()+\"正在写入数据...\");\r\n            try {\r\n                Thread.sleep(5000);      //以睡眠来模拟写入数据操作\r\n                System.out.println(\"线程\"+Thread.currentThread().getName()+\"写入数据完毕，等待其他线程写入完毕\");\r\n \r\n                cyclicBarrier.await();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }catch(BrokenBarrierException e){\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(Thread.currentThread().getName()+\"所有线程写入完毕，继续处理其他任务...\");\r\n        }\r\n    }\r\n}</code></pre> \n <p>&nbsp;</p> \n</div>',NULL,'2020-02-09 15:35:28',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226409482930716672',NULL,NULL,' Ignite.NET插件示例：分布式Semaphore（信号量）   ','<div class=\"content\" id=\"articleContent\"> \n <p>Ignite.NET从2.0版本开始，引入了<a href=\"https://liyuj.gitee.io/doc/net/ThirdPartyIntegrations.html#_4-插件\">插件系统</a>，插件可以仅在于.NET环境中，也可以在于.NET + Java混合环境中，本文会描述如何在后者实现插件。</p> \n <h2>为什么需要插件？</h2> \n <p>Ignite.NET构建于Ignite（用Java编写）之上，JVM会在.NET进程中启动，.NET部分与Java部分进行交互，并尽可能重用现有的Ignite功能。</p> \n <p>插件系统将此平台交互机制公开给第三方，主要场景之一是在.NET中可以使用Ignite和第三方Java API。</p> \n <p>这种API的一个典型事例是<a href=\"https://liyuj.gitee.io/doc/java/DistributedDataStructures.html#_6-semaphore（信号量）\">IgniteSemaphore</a>，该功能在Ignite.NET中尚不可用。</p> \n <h2>分布式Semaphore API</h2> \n <p>Ignite中的Semaphore类似于<code>System.Threading.Semaphore</code>（<a href=\"https://msdn.microsoft.com/en-us/library/system.threading.semaphore.aspx\">MSDN</a>），但是是在整个集群中生效的，限制在所有Ignite节点上执行指定代码段的线程数。</p> \n <p>代码大致如下：</p> \n <pre><code class=\"language-csharp\">IIgnite ignite = Ignition.GetIgnite();\nISemaphore semaphore = ignite.GetOrCreateSemaphore(name: \"foo\", count: 3);\n\nsemaphore.WaitOne();  // Enter the semaphore (may block)\n// Do work\nsemaphore.Release();\n</code></pre> \n <p>看起来很简单而且非常有用，与.NET内置的<code>Semaphore</code>API相同。显然不能更改<code>IIgnite</code>的接口，因此<code>GetOrCreateSemaphore</code>就是一个扩展点，下面会详细描述。</p> \n <h2>Java插件</h2> \n <p>先看Java端，这里需要一种调用<code>Ignite.semaphore()</code>的方法并向.NET平台提供访问该实例的方法。</p> \n <p>创建一个Java项目并通过Maven引用Ignite（具体内容请参见<a href=\"https://my.oschina.net/liyuj/blog/793938\">构建多平台Ignite集群</a>文章）。</p> \n <p>每个插件都以<code>PluginConfiguration</code>开始，本例的插件不需要任何配置属性，但是该类必须存在，因此只需创建一个简单的类即可：</p> \n <pre><code class=\"language-java\">public class IgniteNetSemaphorePluginConfiguration implements PluginConfiguration {}\n</code></pre> \n <p>然后是插件的入口：<code>PluginProvider&lt;PluginConfiguration&gt;</code>。该接口有很多方法，但是大多数方法都可以为空（<code>name</code>和<code>version</code>不能为空，因此需要为其赋值）。这里只需关注<code>initExtensions</code>方法，它是跨平台互操作的入口点，本例中做的就是注册<code>PlatformPluginExtension</code>实现：</p> \n <pre><code class=\"language-java\">public class IgniteNetSemaphorePluginProvider implements PluginProvider&lt;IgniteNetSemaphorePluginConfiguration&gt; {\n    public String name() { return \"DotNetSemaphore\"; }\n    public String version() { return \"1.0\"; }\n\n    public void initExtensions(PluginContext pluginContext, ExtensionRegistry extensionRegistry)\n            throws IgniteCheckedException {\n        extensionRegistry.registerExtension(PlatformPluginExtension.class,\n                new IgniteNetSemaphorePluginExtension(pluginContext.grid()));\n    }\n...\n}\n</code></pre> \n <p><code>PlatformPluginExtension</code>有一个唯一的<code>id</code>，用于从.NET端访问它，还有一个<code>PlatformTarget createTarget()</code>方法，用于创建可以从.NET端访问的对象。</p> \n <p>Java中的<a href=\"https://github.com/apache/ignite/blob/master/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformTarget.java\">PlatformTarget</a>会映射到.NET中的<a href=\"https://github.com/apache/ignite/blob/master/modules/platforms/dotnet/Apache.Ignite.Core/Interop/IPlatformTarget.cs\">IPlatformTarget</a>接口，当在.NET中调用<code>IPlatformTarget.InLongOutLong</code>时，就会调用Java实现中的<code>PlatformTarget.processInLongOutLong</code>。还有许多其他方法可以用于交换基本类型、序列化数据和对象。每个方法都有一个指定了操作代码的<code>type</code>参数，以防插件上有很多不同的方法。</p> \n <p>本例中需要两个<code>PlatformTarget</code>类：一个代表整个插件并具有<code>getOrCreateSemaphore</code>方法，另一个代表每个特定信号量。第一个应该持有字符串类型的名称和整型的计数器并返回一个对象，因此需要实现<code>PlatformTarget.processInStreamOutObject</code>，其他方法都不需要可以将其置空：</p> \n <pre><code class=\"language-java\">public class IgniteNetPluginTarget implements PlatformTarget {\n    private final Ignite ignite;\n\n    public IgniteNetPluginTarget(Ignite ignite) {\n        this.ignite = ignite;\n    }\n\n    public PlatformTarget processInStreamOutObject(int i, BinaryRawReaderEx binaryRawReaderEx) throws IgniteCheckedException {\n        String name = binaryRawReaderEx.readString();\n        int count = binaryRawReaderEx.readInt();\n\n        IgniteSemaphore semaphore = ignite.semaphore(name, count, true, true);\n\n        return new IgniteNetSemaphore(semaphore);\n    }\n...\n}\n</code></pre> \n <p>.NET中的每个<code>ISemaphore</code>对象在Java中都会有一个对应的<code>IgniteNetSemaphore</code>，它也是一个<code>PlatformTarget</code>。这个对象将处理<code>WaitOne</code>和<code>Release</code>方法，并将它们委托给底层的<code>IgniteSemaphore</code>对象。由于这两个方法都是返回void且是无参数的，因此最简单的<code>PlatformTarget</code>是：</p> \n <pre><code class=\"language-java\">public long processInLongOutLong(int i, long l) throws IgniteCheckedException {\n    if (i == 0) semaphore.acquire();\n    else semaphore.release();\n\n    return 0;\n}\n</code></pre> \n <p>这样Java部分就完成了！创建<code>resources\\META-INF.services\\org.apache.ignite.plugin.PluginProvider</code>文件，内容为类名，Java服务加载器就可以加载该类。使用Maven打包该项目（在终端中执行<code>mvn package</code>或使用IDE）后，target目录中就应该有一个<code>IgniteNetSemaphorePlugin-1.0-SNAPSHOT.jar</code>文件。</p> \n <h2>.NET插件</h2> \n <p>首先创建一个控制台项目，安装Ignite NuGet软件包，并以刚刚创建的jar文件的路径启动Ignite：</p> \n <pre><code class=\"language-csharp\">var cfg = new IgniteConfiguration\n{\n    JvmClasspath = @\"..\\..\\..\\..\\Java\\target\\IgniteNetSemaphorePlugin-1.0-SNAPSHOT.jar\"\n};\n\nIgnition.Start(cfg);\n</code></pre> \n <p>Ignite节点启动后就可以在日志中看到插件的名称：</p> \n <pre><code>[16:02:38] Configured plugins:\n[16:02:38]   ^-- DotNetSemaphore 1.0\n</code></pre> \n <p>对于.NET部分将采用API优先的方法：首先实现扩展方法，然后从那里继续。</p> \n <pre><code class=\"language-csharp\">public static class IgniteExtensions\n{\n    public static Semaphore GetOrCreateSemaphore(this IIgnite ignite, string name, int count)\n    {\n        return ignite.GetPlugin&lt;SemaphorePlugin&gt;(\"semaphorePlugin\").GetOrCreateSemaphore(name, count);\n    }\n}\n</code></pre> \n <p>为了使该<code>GetPlugin</code>方法生效，需要配置<code>IgniteConfiguration.PluginConfigurations</code>属性，它持有<code>IPluginConfiguration</code>实现的集合，并且每个实现又必须链接到<code>IPluginProvider</code>的实现：</p> \n <pre><code class=\"language-csharp\">[PluginProviderType(typeof(SemaphorePluginProvider))]\nclass SemaphorePluginConfiguration : IPluginConfiguration  {...}\n</code></pre> \n <p>在节点启动时，Ignite.NET会迭代插件配置，实例化插件提供者，并调用其<code>Start(IPluginContext&lt;SemaphorePluginConfiguration&gt; context)</code>方法，然后对<code>IIgnite.GetPlugin</code>的调用会委托给指定名字的提供者的<code>IPluginProvider.GetPlugin</code>。</p> \n <pre><code class=\"language-csharp\">class SemaphorePluginProvider : IPluginProvider&lt;SemaphorePluginConfiguration&gt;\n{\n    private SemaphorePlugin _plugin;\n\n    public T GetPlugin&lt;T&gt;() where T : class\n    {\n        return _plugin as T;\n    }\n\n    public void Start(IPluginContext&lt;SemaphorePluginConfiguration&gt; context)\n    {\n        _plugin = new SemaphorePlugin(context);\n    }\n\n    ...\n\n}\n</code></pre> \n <p>通过<code>IPluginContext</code>可以访问Ignite实例、Ignite和插件的配置，还有<code>GetExtension</code>方法，会委托给Java中的<code>PlatformPluginExtension.createTarget()</code>方法，这样就可以在两个平台之间“建立连接”。.NET中的<code>IPlatformTarget</code>链接到Java中的<code>PlatformTarget</code>，它们可以相互调用，并且Java对象的生存周期与.NET对象的生存周期是关联的，即一旦垃圾收集器回收了.NET对象，也会释放Java对象的引用，因此Java对象也会被回收。</p> \n <p>下面的实现很简单，只调用了对应的<code>IPlatformTarget</code>方法：</p> \n <pre><code class=\"language-csharp\">class SemaphorePlugin\n{\n    private readonly IPlatformTarget _target;  // Refers to IgniteNetPluginTarget in Java\n\n    public SemaphorePlugin(IPluginContext&lt;SemaphorePluginConfiguration&gt; context)\n    {\n        _target = context.GetExtension(100);\n    }\n\n    public Semaphore GetOrCreateSemaphore(string name, int count)\n    {\n        var semaphoreTarget = _target.InStreamOutObject(0, w =&gt;\n        {\n            w.WriteString(name);\n            w.WriteInt(count);\n        });\n\n        return new Semaphore(semaphoreTarget);\n    }\n}\n\nclass Semaphore\n{\n    private readonly IPlatformTarget _target;  // Refers to IgniteNetSemaphore in Java\n\n    public Semaphore(IPlatformTarget target)\n    {\n        _target = target;\n    }\n\n    public void WaitOne()\n    {\n        _target.InLongOutLong(0, 0);\n    }\n\n    public void Release()\n    {\n        _target.InLongOutLong(1, 0);\n    }\n}\n</code></pre> \n <p>这样就可以了，并且向现有插件添加更多逻辑也很容易，只需在两侧实现一对方法即可。Ignite使用<a href=\"https://en.wikipedia.org/wiki/Java_Native_Interface\">JNI</a>和非托管内存在.NET和Java平台之间使用一个进程交换数据，既简单又高效。</p> \n <h2>测试</h2> \n <p>为了演示Semaphore的分布式特性，可以运行多个Ignite节点，每个节点都调用<code>WaitOne()</code>，就会看到一次只有两个节点能够获取信号量：</p> \n <pre><code class=\"language-csharp\">var ignite = Ignition.Start(cfg);\nvar sem = ignite.GetOrCreateSemaphore(\"foo\", 2);\n\nConsole.WriteLine(\"Trying to acquire semaphore...\");\n\nsem.WaitOne();\n\nConsole.WriteLine(\"Semaphore acquired. Press any key to release.\");\nConsole.ReadKey();\n</code></pre> \n</div>',NULL,'2020-02-09 15:36:21',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226409704914255872',NULL,NULL,' JUC锁框架——Semaphore  ','<div class=\"content\" id=\"articleContent\"> \n <h1>Semaphore简单介绍</h1> \n <p>Semaphore是计数信号量。Semaphore管理一系列许可证。每个acquire方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个release方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。</p> \n <h1>Semaphore的简单示例</h1> \n <p>Semaphore经常用于限制获取某种资源的线程数量。下面举个例子，比如说操场上有5个跑道，一个跑道一次只能有一个学生在上面跑步，一旦所有跑道在使用，那么后面的学生就需要等待，直到有一个学生不跑了，下面是这个例子：</p> \n <pre><code class=\"language-java\">public class Playground {\n    private String[] tracks = {\"跑道1\",\"跑道2\",\"跑道3\",\"跑道4\",\"跑道5\"};//一共有5个跑道\n    private volatile boolean[] used = new boolean[5];//标记跑道是否被占用\n\n    private Semaphore semaphore = new Semaphore(5, true);\n\n    //获取一个跑道\n    public String getTrack() throws InterruptedException {\n        semaphore.acquire(1);\n        return getNextAvailableTrack();\n    }\n\n    //返回一个跑道\n    public void releaseTrack(String track) {\n        if (makeAsUnused(track))\n            semaphore.release(1);\n    }\n\n    //遍历，找到一个没人用的跑道\n    private String getNextAvailableTrack() {\n        for (int i = 0; i &lt; used.length; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                return tracks[i];\n            }\n        }\n        return null;\n    }\n\n    //释放跑道，将使用标志设置为false\n    private boolean makeAsUnused(String track) {\n        for (int i = 0; i &lt; used.length; i++) {\n            if (tracks[i].equals(track)) {\n                if (used[i]) {\n                    used[i] = false;\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Executor executor = Executors.newCachedThreadPool();\n        Playground playground = new Playground();\n        Runnable runnable = ()-&gt;{\n            try {\n                String track = playground.getTrack();//获取跑道\n                if (track != null) {\n                    System.out.println(\"学生\" + Thread.currentThread().getId() + \"在\" + track.toString() + \"上跑步\");\n                    TimeUnit.SECONDS.sleep(2);\n                    System.out.println(\"学生\" + Thread.currentThread().getId() + \"释放\" + track.toString());\n                    playground.releaseTrack(track);//释放跑道\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n        for (int i = 0; i &lt; 100; i++) {\n            executor.execute(runnable);\n        }\n    }\n}\n</code></pre> \n <h1>Semaphore的源码解析</h1> \n <h2>semaphore的构造方法</h2> \n <pre><code class=\"language-java\">public Semaphore(int permits) {\n    sync = new NonfairSync(permits);//提供许可数量，默认为非公平模式\n}\n\npublic Semaphore(int permits, boolean fair) {\n    //提供许可数量，指定是否为公平模式\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n</code></pre> \n <h2>Sync类</h2> \n <p>Semaphore内部基于AQS的共享模式，所以实现都委托给了Sync类。</p> \n <pre><code class=\"language-java\">NonfairSync(int permits) {\n    super(permits);\n}\n</code></pre> \n <pre><code class=\"language-java\">Sync(int permits) {\n    setState(permits);//AQS的state表示许可证的数量\n}\n</code></pre> \n <h2>Semaphore的acquire获取许可方法</h2> \n <pre><code class=\"language-java\">public void acquire(int permits) throws InterruptedException {\n    if (permits &lt; 0) throw new IllegalArgumentException();\n    sync.acquireSharedInterruptibly(permits);\n}\n</code></pre> \n <pre><code class=\"language-java\">public final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    //如果线程被中断了，抛出异常\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    //获取许可失败，将线程加入到等待队列中\n    if (tryAcquireShared(arg) &lt; 0)\n        doAcquireSharedInterruptibly(arg);\n}\n</code></pre> \n <h3>NonfairSync中tryAcquireShared方法的实现</h3> \n <p>AQS子类如果要使用共享模式的话，需要实现tryAcquireShared方法，下面看NonfairSync的该方法实现：</p> \n <pre><code class=\"language-java\">protected int tryAcquireShared(int acquires) {\n    return nonfairTryAcquireShared(acquires);\n}\n</code></pre> \n <p>该方法调用了父类中的nonfairTyAcquireShared方法，如下：</p> \n <pre><code class=\"language-java\">final int nonfairTryAcquireShared(int acquires) {\n    for (;;) {\n        //获取剩余许可数量\n        int available = getState();\n        //计算给完这次许可数量后的个数\n        int remaining = available - acquires;\n        //如果许可不够(获取许可失败)或者可以将许可数量重置（获取许可成功）的话，返回。\n        //只有在许可不够时返回值才会小于0，其余返回的都是剩余许可数量，这也就解释了，一旦许可不够，后面的线程将会阻塞。\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n</code></pre> \n <h3>FairSync中tryAcquireShared方法的实现</h3> \n <pre><code class=\"language-java\">protected int tryAcquireShared(int acquires) {\n    for (;;) {\n        //如果前面有线程再等待，直接返回-1\n        if (hasQueuedPredecessors())\n            return -1;\n        //后面与非公平一样\n        int available = getState();\n        int remaining = available - acquires;\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n            return remaining;\n    }\n}\n</code></pre> \n <p>FairSync与NonFairSync的区别就在于会首先判断当前队列中有没有线程在等待，如果有，就老老实实进入到等待队列；而不像NonfairSync一样首先试一把，说不定就恰好获得了一个许可，这样就可以插队了。</p> \n <h2>Semaphore的release()释放许可方法</h2> \n <pre><code class=\"language-java\">public void release(int permits) {\n    if (permits &lt; 0) throw new IllegalArgumentException();\n    sync.releaseShared(permits);\n}\n</code></pre> \n <p>releaseShared方法在AQS中，如下：</p> \n <pre><code class=\"language-java\">public final boolean releaseShared(int arg) {\n    //如果改变许可数量成功\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();//一旦CAS改变许可数量成功，就调用该方法释放阻塞的线程。\n        return true;\n    }\n    return false;\n}\n</code></pre> \n <p>AQS子类实现共享模式的类需要实现tryReleaseShared类来判断是否释放成功，实现如下：</p> \n <pre><code class=\"language-java\">protected final boolean tryReleaseShared(int releases) {\n    for (;;) {\n        //获取当前许可数量\n        int current = getState();\n        //计算回收后的数量\n        int next = current + releases;\n        if (next &lt; current) // overflow\n            throw new Error(\"Maximum permit count exceeded\");\n        //CAS改变许可数量成功，返回true\n        if (compareAndSetState(current, next))\n            return true;\n    }\n}\n</code></pre> \n <h2>Semaphore的reducePermits减小许可数量方法</h2> \n <pre><code class=\"language-java\">protected void reducePermits(int reduction) {\n    if (reduction &lt; 0) throw new IllegalArgumentException();\n    sync.reducePermits(reduction);\n}\n</code></pre> \n <p>可以看到，委托给了Sync，Sync的reducePermits方法如下：</p> \n <pre><code class=\"language-java\"> final void reducePermits(int reductions) {\n    for (;;) {\n        //得到当前剩余许可数量\n        int current = getState();\n        //得到减完之后的许可数量\n        int next = current - reductions;\n        if (next &gt; current) // underflow\n            throw new Error(\"Permit count underflow\");\n        //如果CAS改变成功\n        //CAS改变AQS中的state变量，因为该变量代表许可证的数量。\n        if (compareAndSetState(current, next))\n            return;\n    }\n}\n</code></pre> \n <h2>Semaphore的drainPermits获取剩余许可数量</h2> \n <p>Semaphore还可以一次将剩余的许可数量全部取走，该方法是drain方法，如下：</p> \n <pre><code class=\"language-java\">public int drainPermits() {\n    return sync.drainPermits();\n}\n</code></pre> \n <p>Sync的实现如下：</p> \n <pre><code class=\"language-java\"> final int drainPermits() {\n     for (;;) {\n         int current = getState();\n         if (current == 0 || compareAndSetState(current, 0))//CAS将许可数量置为0。\n             return current;\n     }\n }\n</code></pre> \n <h1>总结</h1> \n <p>Semaphore是信号量，用于管理一组资源。其内部是基于AQS的共享模式，AQS的状态表示许可证的数量，在许可证数量不够时，线程将会被挂起；而一旦有一个线程释放一个资源，那么就有可能重新唤醒等待队列中的线程继续执行。</p> \n <p>参考地址：</p> \n <ul> \n  <li><a href=\"https://blog.csdn.net/qq_19431333/article/details/70212663\">https://blog.csdn.net/qq_19431333/article/details/70212663</a></li> \n </ul> \n</div>',NULL,'2020-02-09 15:37:14',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java'),
('1226409927065567232',NULL,NULL,' Java信号量_Semaphore  ','<div class=\"content\" id=\"articleContent\"> \n <p>﻿Java信号量_Semaphore</p> \n <p>计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。</p> \n <p>Semaphore中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。<span style=\"background-color:rgb(255, 192, 0)\"><em><strong>在执行操作时，可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。</strong></em></span></p> \n <p><span style=\"background-color:rgb(255, 192, 0)\"><em><strong>如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。</strong></em></span>计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore。二值信号量可以用来做互斥体，并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。</p> \n <p>示例代码：</p> \n <pre><code>package&nbsp;com.lyx;\n\nimport&nbsp;java.util.Collections;\nimport&nbsp;java.util.HashSet;\nimport&nbsp;java.util.Set;\nimport&nbsp;java.util.concurrent.Semaphore;\n\npublic&nbsp;class&nbsp;BoundHashSet&lt;T&gt;&nbsp;{\n	private&nbsp;final&nbsp;Set&lt;T&gt;&nbsp;set;\n	private&nbsp;final&nbsp;Semaphore&nbsp;semaphore;\n\n	public&nbsp;BoundHashSet(int&nbsp;bound)&nbsp;{\n		this.set&nbsp;=&nbsp;Collections.synchronizedSet(new&nbsp;HashSet&lt;T&gt;());\n		this.semaphore&nbsp;=&nbsp;new&nbsp;Semaphore(bound);\n	}\n\n	public&nbsp;boolean&nbsp;add(T&nbsp;o)&nbsp;throws&nbsp;InterruptedException&nbsp;{\n		this.semaphore.acquire();\n		boolean&nbsp;wasAdded&nbsp;=&nbsp;false;\n		try&nbsp;{\n			wasAdded&nbsp;=&nbsp;this.set.add(o);\n			return&nbsp;wasAdded;\n		}&nbsp;finally&nbsp;{\n			if&nbsp;(!wasAdded)&nbsp;{\n				this.semaphore.release();\n			}\n		}\n	}\n\n	public&nbsp;boolean&nbsp;remove(Object&nbsp;o)&nbsp;{\n		boolean&nbsp;wasRemoved&nbsp;=&nbsp;this.set.remove(o);\n		if&nbsp;(wasRemoved)&nbsp;{\n			this.semaphore.release();\n		}\n		return&nbsp;wasRemoved;\n	}\n\n}</code></pre> \n <p>=============END=============</p> \n</div>',NULL,'2020-02-09 15:38:07',NULL,NULL,NULL,0,NULL,NULL,'1',NULL,NULL,'Java');

/*Table structure for table `t_exam_dept` */

DROP TABLE IF EXISTS `t_exam_dept`;

CREATE TABLE `t_exam_dept` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `dept_name` varchar(50) NOT NULL COMMENT '部门名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;

/*Data for the table `t_exam_dept` */

insert  into `t_exam_dept`(`id`,`dept_name`) values 
(13,'开发四部'),
(14,'开发三部'),
(15,'军情六畜'),
(16,'保卫科'),
(17,'局座'),
(18,'系统部'),
(19,'人力资源保障局'),
(20,'运行与维护中心'),
(21,'杰尼事务所'),
(22,'中铁九局'),
(23,'凤阳实业'),
(24,'トヨタ自動車株式会社'),
(25,'Netflix'),
(26,'系统一部（珠海基地）'),
(27,'测试1');

/*Table structure for table `t_exam_paper` */

DROP TABLE IF EXISTS `t_exam_paper`;

CREATE TABLE `t_exam_paper` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL COMMENT '试卷名',
  `score` double(5,2) NOT NULL COMMENT '分数',
  `dept_flag` int(5) NOT NULL COMMENT '部门等级',
  `time` int(5) NOT NULL COMMENT '答题时间',
  `status` char(1) DEFAULT '0' COMMENT '0-启用，1-作废',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

/*Data for the table `t_exam_paper` */

insert  into `t_exam_paper`(`id`,`name`,`score`,`dept_flag`,`time`,`status`) values 
(1,'开发四部综合测试',100.00,13,60,'1'),
(2,'系统一部期末测试',100.00,13,45,'0'),
(4,'通用卷纸',50.00,22,50,'0'),
(5,'测试1',50.00,22,60,'0'),
(6,'人力资源保障局Exp综合测试',60.00,19,30,'0'),
(7,'开发四部N4日语能力考试',100.00,13,30,'1'),
(8,'阿里开发手册1（编程规约测试）',100.00,13,30,'0');

/*Table structure for table `t_exam_paper_question` */

DROP TABLE IF EXISTS `t_exam_paper_question`;

CREATE TABLE `t_exam_paper_question` (
  `pid` int(11) NOT NULL COMMENT '卷纸id',
  `qid` int(11) NOT NULL COMMENT '题目id',
  PRIMARY KEY (`pid`,`qid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_exam_paper_question` */

insert  into `t_exam_paper_question`(`pid`,`qid`) values 
(1,3),
(1,4),
(1,8),
(1,9),
(1,10),
(1,11),
(1,12),
(1,13),
(1,14),
(1,15),
(1,17),
(1,23),
(1,24),
(2,11),
(2,17),
(5,12),
(6,3),
(6,4),
(6,8),
(6,9),
(6,10),
(7,32),
(7,33),
(7,34),
(7,35),
(7,36),
(7,37),
(7,38),
(7,39),
(7,41),
(7,42),
(8,43),
(8,45),
(8,46),
(8,47),
(8,48),
(8,49),
(8,50),
(8,51),
(8,52),
(8,53),
(8,54),
(8,55),
(8,56),
(8,57),
(8,58),
(8,59),
(8,60),
(8,61),
(8,63),
(8,64);

/*Table structure for table `t_exam_question` */

DROP TABLE IF EXISTS `t_exam_question`;

CREATE TABLE `t_exam_question` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `content` varchar(300) NOT NULL COMMENT '题内容',
  `answer` varchar(50) NOT NULL COMMENT '答案',
  `score` double(5,2) NOT NULL COMMENT '分数',
  `type` varchar(200) DEFAULT NULL,
  `option_map_string` varchar(200) NOT NULL COMMENT '选项',
  `reason` varchar(500) DEFAULT NULL COMMENT '原因',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8;

/*Data for the table `t_exam_question` */

insert  into `t_exam_question`(`id`,`content`,`answer`,`score`,`type`,`option_map_string`,`reason`) values 
(3,'Python的设计具有很强的可读性，相比其他语言具有的特色语法有以下选项，正确的是()：\n','A',2.00,'python','{\"A\":\"A   交互式\",\"B\":\"B   解释型 \",\"C\":\"C   面向对象 \",\"D\":\"D   服务端语言\"}',NULL),
(4,'php是最好的语言？\n','B',2.00,'php','{\"A\":\"A.是的 \",\"B\":\"B.不是 \",\"C\":\"C.弃权 \",\"D\":\"D.呵呵\"}',NULL),
(8,'提供Java存取数据库能力的包是（）\n\n','A',2.00,'java','{\"A\":\"A．java.sql\",\"B\":\"B．java.awt\",\"C\":\"C．java.lang\",\"D\":\"D．java.swing\"}',NULL),
(9,'不能用来修饰interface的有（）\n','A',2.00,'java','{\"A\":\"A．private\",\"B\":\"B．public\",\"C\":\"C．protected\",\"D\":\"D．static\"}',NULL),
(10,'下列关于修饰符混用的说法，错误的是（ ）：\n','D',2.00,'java','{\"A\":\"A．abstract不能与final并列修饰同一个类\",\"B\":\"B．abstract类中可以有private的成员\",\"C\":\"C．abstract方法必须在abstract类中\",\"D\":\"D．static方法中能处理非static的属性\"}',NULL),
(11,'测试1：我帅吗？','A',2.00,'python','{\"A\":\"A.帅\",\"B\":\"B.不帅\",\"C\":\"C.丑比\",\"D\":\"D.一般\"}',NULL),
(12,'测试2','A',2.00,'python','{\"A\":\"A.xx\",\"B\":\"B.xx\",\"C\":\"C.7777777777\",\"D\":\"D.xx\"}',NULL),
(13,'测试3','A',2.00,'python','{\"A\":\"xx\",\"B\":\"sssssssssssssssssssssss\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(14,'测试4','A',2.00,'python','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"jjjjjjjjjjjjj\",\"D\":\"xx\"}',NULL),
(15,'测试5','A',2.00,'python','{\"A\":\"sdffdsfgds\",\"B\":\"xx\",\"C\":\"dsfsdfdsfd\",\"D\":\"xx\"}',NULL),
(16,'测试6','C',2.00,'python','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(17,'java是什么？','A',3.00,'java','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(18,'测试11','A',1.00,'java','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(19,'测试12','D',2.00,'java','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(20,'测试13','D',2.00,'java','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(21,'测试14','B',2.00,'java','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(22,'测试15','A',2.00,'php','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(23,'测试16','A',2.00,'C#','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(24,'测试17','A',2.00,'C#','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(25,'测试18','A',2.00,'Oracle','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(26,'测试20','A',2.00,'C++','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(27,'测试21','A',2.00,'R','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(28,'测试22','A',2.00,'R','{\"A\":\"xx\",\"B\":\"xx\",\"C\":\"xx\",\"D\":\"xx\"}',NULL),
(29,'《周公解梦》的作者是？','C',2.00,'文学历史','{\"A\":\"A.文相比干\",\"B\":\"B.文王姬昌\",\"C\":\"C.姬旦\",\"D\":\"D.刘伯温\"}',NULL),
(30,'問題１：男の人と女の人が話しています、\n　　以上の言葉はどういう意味か','C',2.00,'日本語','{\"A\":\"知らん\",\"B\":\"ふさわしいという\",\"C\":\"つまらないチャット\",\"D\":\"えろい言葉\"}',NULL),
(31,'php俗称什么？','D',2.00,'php','{\"A\":\"A.平衡盘\",\"B\":\"B.盘后票\",\"C\":\"C.平衡片\",\"D\":\"D.拍簧片\"}',NULL),
(32,'田中さん＿＿日本人です','A',10.00,'日语','{\"A\":\"A.は\",\"B\":\"B.か\",\"C\":\"C.で\",\"D\":\"D.の\"}',NULL),
(33,'吉田さんは東京大学④＿＿留学生＿＿ありません','B',10.00,'日语','{\"A\":\"A.の∕で\",\"B\":\"B.の∕では\",\"C\":\"C.は∕では\",\"D\":\"D.は∕で\"}',NULL),
(34,'甲：こんにちは﹑吉田さんですか。  乙：＿＿。','A',10.00,'日语','{\"A\":\"A.はい、吉田です\",\"B\":\"B.いいえ、そうです\",\"C\":\"C.はい、ちがいます  \",\"D\":\"D.はい、ちがいます  \"}',NULL),
(35,'健康になりたいなら、毎日運動する＿だった。','B',10.00,'日语','{\"A\":\"A.ばかり\",\"B\":\"B.こと\",\"C\":\"C.ほど\",\"D\":\"D.もの\"}',NULL),
(36,'明日図書館があいている＿どうかしっていますか。','D',10.00,'日语','{\"A\":\"A.が\",\"B\":\"B.を\",\"C\":\"C.に\",\"D\":\"D.か\"}',NULL),
(37,'今ご飯を食べたばかりです。','A',10.00,'日语','{\"A\":\"A.今ご飯を食べているところです。\",\"B\":\"B.ご飯の準備ができました。\",\"C\":\"C.まだご飯を食べていない\",\"D\":\"D.ご馳走さまでした\"}',NULL),
(38,'あの会社は大勢の人にやめられて大変です。','C',10.00,'日语','{\"A\":\"A.あの会社は今困っている。\",\"B\":\"B.大勢の人は今困っている。\",\"C\":\"C.あの会社はたくさんの人をやめさせました。\",\"D\":\"D.たくさんのひとは首になった。\"}',NULL),
(39,'多額の借金をかえすため____、どんな仕事でもやらざるを得ない。','C',10.00,'日语','{\"A\":\"A.として\",\"B\":\"B.とあれば\",\"C\":\"C.というより\",\"D\":\"D.ときたら\"}',NULL),
(40,'あの二人は結婚当時貧乏で、新婚旅行_3_結婚式もしていない','D',10.00,'日语','{\"A\":\"A.あって\",\"B\":\"B.伴って\",\"C\":\"C.はおろか\",\"D\":\"D.にもまして\"}',NULL),
(41,'风邪__学校へ行きませんでした','D',10.00,'日语','{\"A\":\"A.の\",\"B\":\"B.に\",\"C\":\"C.が\",\"D\":\"D.で\"}',NULL),
(42,'きのうは、2时间___テレビを见ました','C',10.00,'日语','{\"A\":\"A.まで\",\"B\":\"B.までに\",\"C\":\"C.ぐらい\",\"D\":\"D.ごろ\"}',NULL),
(43,'关于命名风格，以下哪个命名符合规范？ ','D',5.00,'阿里开发1','{\"A\":\"A._name\",\"B\":\"B.$name\",\"C\":\"C.name$_\",\"D\":\"D.a\"}','【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束'),
(44,'S试试','A',2.00,'测试1','{\"A\":\"A.啊啊啊\",\"B\":\"B.啊\",\"C\":\"C.啊啊\",\"D\":\"D. 啊啊\"}','嘻嘻嘻嘻嘻嘻嘻嘻寻寻88888888888888'),
(45,'下列命名正确的有？','A',5.00,'阿里开发1','{\"A\":\"A.alibaba \",\"B\":\"B.DaZhePromotion \",\"C\":\"C. getPingfenByName()\",\"D\":\"D.int 某变量 = 3\"}','【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式 也要避免采用'),
(46,'方法名、参数名、成员变量、局部变量都统一使用__命名形式？','A',5.00,'阿里开发1','{\"A\":\"A.驼峰式命名\",\"B\":\"B.全部大写式命名\",\"C\":\"C.见名之意命名\",\"D\":\"D.彩虹模式\"}','【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从 驼峰形式。 正例： localValue / getHttpMessage() / inputUserId'),
(47,'以下符合常量命名规范的是？','D',5.00,'阿里开发1','{\"A\":\"A.max_value\",\"B\":\"B.maxValue\",\"C\":\"C.MAXVALUE\",\"D\":\"D.MAX_VALUE\"}','【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例：MAX_STOCK_COUNT 反例：MAX_COUNT'),
(48,'下列描述中错误的是？','D',5.00,'阿里手册1','{\"A\":\"A.抽象类命名使用 Abstract 或 Base 开头\",\"B\":\"B.异常类命名使用 Exception 结尾\",\"C\":\"C.测试类以 Test 结尾\",\"D\":\"D.抽象类不可以被继承\"}','【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类 命名以它要测试的类的名称开始，以 Test 结尾'),
(49,'以下数组定义格式不符合阿里手册开发规范的是？','B',5.00,'阿里开发1','{\"A\":\"A. int[] arrayDemo = new int[]{};\",\"B\":\"B.String args[];\",\"C\":\"C.boolean[] b = {\\\"true\\\",\\\"false\\\"}; \",\"D\":\"D.int [] []arr = [][]{}; \"}','【强制】类型与中括号紧挨相连来表示数组。 正例：定义整形数组 int[] arrayDemo; 反例：在 main 参数中，使用 String args[]来定义'),
(50,'以下符合阿里规范的包名是？','A',5.00,'阿里开发1','{\"A\":\"A.com.icbc.a\",\"B\":\"B.com.ICBC.a\",\"C\":\"C.COM.ICBC.A\",\"D\":\"D.Com.Icbc.A\"}','【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（此规则参考 spring 的框架结构'),
(51,'【强制】所有的覆写方法，必须加__?__ 注解','A',5.00,'阿里开发1','{\"A\":\"A.@Override\",\"B\":\"B.@Overload\",\"C\":\"C.@Autowird\",\"D\":\"D.@FunctionInterface\"}','说明：getObject()与 get0bject()的问题。一个是字母的 O，一个是数字的 0，加@Override 可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编 译报错'),
(52,'以下哪种写法会出现空指针异常？','A',5.00,'阿里开发1','{\"A\":\"A.object.equals(\\\"test\\\");\",\"B\":\"B.\\\"test\\\"equals(object\",\"C\":\"C.“\\\".equals(\\\"\\\");\",\"D\":\"D.Objects.equals(\\\"A\\\",\\\"B\\\");\"}','【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。'),
(53,'下列哪一个不属于java的基本类型?','B',5.00,'java','{\"A\":\"A.int\",\"B\":\"B.String\",\"C\":\"C.byte\",\"D\":\"D.double\"}','String是引用数据类型'),
(54,'关于基本数据类型与包装数据类型的使用标准，下列描述错误的有？','D',5.00,'阿里开发1','{\"A\":\"A.【强制】所有的 POJO 类属性必须使用包装数据类型。\",\"B\":\"B.【强制】RPC 方法的返回值和参数必须使用包装数据类型。\",\"C\":\"C.【推荐】所有的局部变量使用基本数据类型。\",\"D\":\"D.【强制】所有的 POJO 类属性不必使用包装数据类型\"}','阿里规范是A.【强制】所有的 POJO 类属性必须使用包装数据类型。'),
(55,'以下描述有误的是？','D',5.00,'阿里开发1','{\"A\":\"A.【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值\",\"B\":\"B.【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败\",\"C\":\"C.【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中\",\"D\":\"D.【强制】pojo中，尽可能多赋予默认值，方便调用\"}','我瞎编的'),
(56,'【强制】POJO 类必须写 __?__方法','A',5.00,'阿里开发1','{\"A\":\"A. toString ()\",\"B\":\"B.super()\",\"C\":\"C.hashCode()\",\"D\":\"D.equals()\"}','【强制】POJO 类必须写 toString 方法'),
(57,'final 可以声明类、成员变量、方法、以及本地变量，以下描述有误的是？','D',5.00,'阿里开发1','{\"A\":\"A.不允许被继承的类，如：String 类\",\"B\":\"B.不允许修改引用的域对象。\",\"C\":\"C.不允许被重写的方法，如：POJO 类的 setter 方法\",\"D\":\"D.被final修饰的类，在内存中只有一份，为了给子类继承\"}','ABC都对'),
(58,'以下关于“【推荐】类成员与方法访问控制从严：”描述错误的是？','D',5.00,'阿里开发1','{\"A\":\"A.如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。\",\"B\":\"B.工具类不允许有 public 或 default 构造方法\",\"C\":\"C.类非 static 成员变量并且与子类共享，必须是 protected\",\"D\":\"D. 被static修饰的成员存放在栈中，并且只有一份 \"}','被static修饰的成员存放在静态区'),
(59,'关于 hashCode 和 equals 的处理，以下描述错误的是？','D',5.00,'阿里开发1','{\"A\":\"A.只要重写 equals，就必须重写 hashCode\",\"B\":\"B.因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的 对象必须重写这两个方法\",\"C\":\"C.如果自定义对象作为 Map 的键，那么必须重写 hashCode 和 equals\",\"D\":\"D. hashCode 是一个基于二叉树的算法\"}','ABC都对'),
(60,'以下哪个不属于java面向对象的三大特征','D',5.00,'java','{\"A\":\"A.封装\",\"B\":\"B.继承\",\"C\":\"C.多态\",\"D\":\"D.跨平台\"}','java面向对象的三大特征 封装，继承，多态'),
(61,'下列说法正确的是？','A',5.00,'java','{\"A\":\"A.JAVA程序的main方法必须写在类里面\",\"B\":\"B.JAVA程序中可以有多个main方法\",\"C\":\"C.JAVA程序中类名必须与文件名一样\",\"D\":\"D. JAVA程序的main方法中如果只有一条语句，可以不用{}(大括号)括起来\"}','xxx'),
(62,'Java中，在如下所示的Test类中，共有（）个构造方法。\n\npublic class Test{\n\nprivate int x;\n\npublic Test(){\n\nx=35;\n\n}\n\npublic void Test(double f){\n\nThis.x=(int)f;\n\n}\n\npublic Test(String s){}\n\n}','C',5.00,'java','{\"A\":\"A.0\",\"B\":\"B.1\",\"C\":\"C.2\",\"D\":\"D.3\"}','xxx'),
(63,'变量命名规范说法正确的是（）','B',5.00,'java','{\"A\":\"A. 变量由字母、下划线、数字、$符号随意组成；\",\"B\":\"B.变量不能以数字作为开头；\",\"C\":\"C.A和a在java中是同一个变量；\",\"D\":\"D.不同类型的变量，可以起相同的名字；\"}','xxx'),
(64,'下列值不为true的表达式有（）。','C',5.00,'java','{\"A\":\"A.\\\"john\\\" == \\\"john\\\"\",\"B\":\"B.\\\"john\\\".equals(\\\"john\\\")\",\"C\":\"C.\\\"john\\\" = \\\"john\\\"\",\"D\":\"D.\\\"john\\\".equals(new String(\\\"john\\\"))\"}','xx');

/*Table structure for table `t_exam_question_option` */

DROP TABLE IF EXISTS `t_exam_question_option`;

CREATE TABLE `t_exam_question_option` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `option` varchar(50) NOT NULL COMMENT '选项',
  `qid` varchar(50) DEFAULT NULL COMMENT '题目id',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='题目选项表';

/*Data for the table `t_exam_question_option` */

/*Table structure for table `t_exam_test_history` */

DROP TABLE IF EXISTS `t_exam_test_history`;

CREATE TABLE `t_exam_test_history` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `paper_id` int(10) NOT NULL COMMENT '卷纸id',
  `paper_name` varchar(200) NOT NULL COMMENT '卷纸名称',
  `src_score` double(5,2) NOT NULL COMMENT '原卷纸分数',
  `user_score` double(5,2) NOT NULL COMMENT '用户考得分数',
  `user_id` varchar(200) NOT NULL COMMENT '用户id',
  `create_date` datetime DEFAULT NULL COMMENT '考试时间',
  `dept_flag` int(5) NOT NULL COMMENT '用户部门标识',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=108 DEFAULT CHARSET=utf8 COMMENT='历史考试表';

/*Data for the table `t_exam_test_history` */

insert  into `t_exam_test_history`(`id`,`paper_id`,`paper_name`,`src_score`,`user_score`,`user_id`,`create_date`,`dept_flag`) values 
(1,1,'学习考试1',100.00,60.00,'admin','2020-02-03 00:00:00',13),
(47,8,'阿里开发手册1（编程规约测试）',100.00,10.00,'admin','2020-02-03 18:08:50',13),
(50,8,'阿里开发手册1（编程规约测试）',100.00,80.00,'zk','2020-02-03 21:25:41',13),
(51,8,'阿里开发手册1（编程规约测试）',100.00,80.00,'zk','2020-02-03 21:28:02',13),
(52,8,'阿里开发手册1（编程规约测试）',100.00,35.00,'admin','2020-02-03 21:31:43',13),
(53,8,'阿里开发手册1（编程规约测试）',100.00,90.00,'ccq','2020-02-04 09:41:33',13),
(54,8,'阿里开发手册1（编程规约测试）',100.00,85.00,'kfzx-duanqm','2020-02-04 09:43:08',13),
(55,8,'阿里开发手册1（编程规约测试）',100.00,100.00,'cc','2020-02-04 09:56:23',13),
(56,8,'阿里开发手册1（编程规约测试）',100.00,100.00,'99','2020-02-04 10:30:16',13),
(57,8,'阿里开发手册1（编程规约测试）',100.00,80.00,'qj','2020-02-04 14:43:25',13),
(58,8,'阿里开发手册1（编程规约测试）',100.00,100.00,'qj','2020-02-04 14:45:48',13),
(59,2,'系统一部期末测试',100.00,0.00,'admin','2020-02-04 17:33:06',13),
(60,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:33:29',13),
(61,2,'系统一部期末测试',100.00,0.00,'admin','2020-02-04 17:37:28',13),
(62,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:38:10',13),
(63,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:40:24',13),
(64,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:40:55',13),
(65,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:40:57',13),
(66,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:40:58',13),
(67,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:40:59',13),
(68,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:00',13),
(69,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:09',13),
(70,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:10',13),
(71,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:10',13),
(72,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:24',13),
(73,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:25',13),
(74,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:26',13),
(75,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:26',13),
(76,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:41:26',13),
(77,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:42:01',13),
(78,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:42:39',13),
(79,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:49:49',13),
(80,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:51:00',13),
(81,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:52:00',13),
(82,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:52:15',13),
(83,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:52:16',13),
(84,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:52:17',13),
(85,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:52:18',13),
(86,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 17:52:19',13),
(87,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 18:06:32',13),
(88,2,'系统一部期末测试',100.00,0.00,'admin','2020-02-04 18:06:40',13),
(89,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 18:06:56',13),
(90,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 18:14:08',13),
(91,2,'系统一部期末测试',100.00,5.00,'admin','2020-02-04 19:27:23',13),
(92,2,'系统一部期末测试',100.00,0.00,'admin','2020-04-04 15:10:09',13),
(93,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-11 15:22:46',13),
(94,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-11 18:25:30',13),
(95,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-11 18:45:53',13),
(96,8,'阿里开发手册1（编程规约测试）',100.00,0.00,'admin','2020-04-11 18:47:57',13),
(97,2,'系统一部期末测试',100.00,5.00,'admin','2020-04-11 18:52:04',13),
(98,2,'系统一部期末测试',100.00,5.00,'admin','2020-04-12 11:26:07',13),
(99,2,'系统一部期末测试',100.00,5.00,'admin','2020-04-12 11:26:15',13),
(100,2,'系统一部期末测试',100.00,3.00,'admin','2020-04-12 11:26:27',13),
(101,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-12 11:29:44',13),
(102,2,'系统一部期末测试',100.00,5.00,'admin','2020-04-12 11:40:39',13),
(103,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-12 11:41:12',13),
(104,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-12 11:43:39',13),
(105,2,'系统一部期末测试',100.00,2.00,'admin','2020-04-12 11:50:50',13),
(106,8,'阿里开发手册1（编程规约测试）',100.00,0.00,'admin','2020-04-12 12:29:06',13),
(107,2,'系统一部期末测试',100.00,5.00,'admin','2020-04-12 16:05:25',13);

/*Table structure for table `t_exam_user` */

DROP TABLE IF EXISTS `t_exam_user`;

CREATE TABLE `t_exam_user` (
  `username` varchar(100) NOT NULL COMMENT '用户名（主键）',
  `icbc_id` varchar(20) DEFAULT NULL COMMENT '统一认证',
  `email` varchar(20) DEFAULT NULL COMMENT '邮箱',
  `password` varchar(50) NOT NULL COMMENT '密码',
  `dept_flag` int(5) NOT NULL COMMENT '所属部门标识',
  `nick_name` varchar(100) DEFAULT NULL COMMENT '昵称',
  `avatar` varchar(200) DEFAULT NULL COMMENT '头像',
  `create_time` date DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_exam_user` */

insert  into `t_exam_user`(`username`,`icbc_id`,`email`,`password`,`dept_flag`,`nick_name`,`avatar`,`create_time`) values 
('555020636','555020636',NULL,'09aaffcefac181639e8d8fb07e6c7d59',13,NULL,NULL,NULL),
('admin','555051443','aaaaaaaaaaaaaaaa','113e3d4f73da90f393e0e6b6e1cfc2f3',13,'sssssssssss','http://127.0.0.1/avatar/1246396913004097536.jpg',NULL),
('admin1',NULL,NULL,'0608790a8db3008736f40e9883fac019',16,NULL,NULL,NULL),
('admin22',NULL,NULL,'4337443a1f0420020d80f9771a947a9b',14,NULL,NULL,NULL),
('cc','001094440',NULL,'6cd69705e5030ab3210fb991217f584a',13,NULL,NULL,NULL),
('ccq','000856627',NULL,'f241e880720c4e64aa90ed85f45cccf1',13,NULL,NULL,NULL),
('ceshi1','525151',NULL,'27335e12f26bffccce9410b37c643702',13,NULL,NULL,NULL),
('dqm','dqm',NULL,'582bd910302c21282e8472f9c3cb6d56',13,NULL,NULL,NULL),
('fdp','555022722',NULL,'3889e6fa2f5c18f6e13bed046a6c86b5',13,NULL,NULL,NULL),
('hp','001149119 ',NULL,'f0d504c33cd9b7aa070214a0da0b4827',13,NULL,NULL,NULL),
('hss','001192062',NULL,'73f012057aa25363b67e37c2392d4e50',13,NULL,NULL,NULL),
('kfzx-duanqm','001192032',NULL,'d2d02f6e41c1d5947564e69ff48b2da5',13,NULL,NULL,NULL),
('kfzx-wum','001094437',NULL,'0ca5a7f556c4882711de1ca24c1ab5cb',19,NULL,NULL,NULL),
('lzq','555023218',NULL,'7384234c30970eb83b75032d2be4f210',13,NULL,NULL,NULL),
('nimo','123456',NULL,'60c8f3a9689bc22cfaf7fc1b7a9c0639',13,NULL,NULL,NULL),
('qj','555017484',NULL,'79030a43342b892530ebadf3f76f6445',13,NULL,NULL,NULL),
('xiaoming','554454145',NULL,'2600b7b388873268551cde3b96cd1a87',19,NULL,NULL,NULL),
('zk','000831472',NULL,'746847880d3996b6a3558751bb589800',13,NULL,NULL,NULL);

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
